This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, line numbers have been added.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: logs, *.log, npm-debug.log*, yarn-debug.log*, yarn-error.log*, pnpm-debug.log*, lerna-debug.log*, .cache/, .parcel-cache/, node_modules, dist, dist-ssr, *.local, .vscode/*, *.suo, *.ntvs*, *.njsproj, *.sln, *.sw?, ._*, .Spotlight-V100, .Trashes, ehthumbs.db, Thumbs.db, .vscode/, .idea/, .env.local, .env.development.local, .env.test.local, .env.production.local, *.tmp, *.temp
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
public/
  vite.svg
scripts/
  lighthouse-ci.js
src/
  __tests__/
    components/
      CareLogForm.test.tsx
      Dashboard.test.tsx
      LogCare.test.tsx
      PlantRegistrationForm.test.tsx
      PlantReminderSettings.test.tsx
      PlantStageDisplay.test.tsx
      ReminderPreferencesSection.test.tsx
      SoilMixtureSelector.test.tsx
    database/
      integration.test.ts
      plantService.test.ts
      varietyService.test.ts
    integration/
      plantDetailReminderSettings.test.tsx
      plantManagement.test.tsx
      smartDefaultsIntegration.test.tsx
      stageCalculationDisplay.test.tsx
      taskGroupingService.test.tsx
    services/
      careSchedulingService.test.ts
      growthStageService.test.ts
      smartDefaultsService.test.ts
    utils/
      growthStage.test.ts
      plantDisplay.test.ts
      plantFactory.test.ts
      plantFactory.ts
      testHelpers.tsx
      varietyGrowthStages.test.ts
  assets/
    react.svg
  components/
    layouts/
      EmptyState.tsx
      Welcome.tsx
    plant/
      CareActivityItem.tsx
      CareHistory.tsx
      CustomVarietyForm.tsx
      NextTaskDisplay.tsx
      PlantRegistrationForm.tsx
      PlantReminderSettings.tsx
      PlantStageDisplay.tsx
      ReminderPreferencesSection.tsx
      SoilMixtureSelector.tsx
    ui/
      Button.tsx
      Card.tsx
      DarkModeToggle.tsx
      LoadingSpinner.tsx
      LocationToggle.tsx
      OfflineIndicator.tsx
      StatusBadge.tsx
      Switch.tsx
    Navigation.tsx
  data/
    seedVarieties.ts
  db/
    schema.ts
    seedData.ts
  hooks/
    useAppInitialization.ts
    useDarkMode.ts
    useDynamicStage.ts
    useFirstTimeUser.ts
    useNextPlantTask.ts
  pages/
    care/
      CareLogForm.tsx
      LogCare.tsx
      PhotoCapture.tsx
      QuickCompletionButtons.tsx
    dashboard/
      index.tsx
      TaskGroup.tsx
      TaskItem.tsx
    plants/
      AddPlant.tsx
      PlantDetail.tsx
      Plants.tsx
  services/
    sync/
      syncService.ts
    careSchedulingService.ts
    growthStageService.ts
    smartDefaultsService.ts
    taskGroupingService.ts
  styles/
    globals.css
  types/
    core.ts
    database.ts
    index.ts
    scheduling.ts
    user.ts
  utils/
    cn.ts
    dateUtils.ts
    growthStage.ts
    plantDisplay.ts
    waterConversion.ts
  App.css
  App.tsx
  index.css
  jest.polyfills.ts
  main.tsx
  setupTests.ts
  vite-env.d.ts
tests/
  e2e/
    pwa-functionality.spec.ts
.gitignore
eslint.config.js
index.html
jest.config.ts
package.json
postcss.config.js
print_structure.py
README.md
repomix.config.json
tailwind.config.js
tsconfig.app.json
tsconfig.json
tsconfig.node.json
tsconfig.tsbuildinfo
vite.config.ts

================================================================
Files
================================================================

================
File: public/vite.svg
================
1: <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: scripts/lighthouse-ci.js
================
 1: const lighthouse = require("lighthouse");
 2: const chromeLauncher = require("chrome-launcher");
 3: 
 4: async function runLighthouse() {
 5:   const chrome = await chromeLauncher.launch({ chromeFlags: ["--headless"] });
 6: 
 7:   const options = {
 8:     logLevel: "info",
 9:     output: "html",
10:     onlyCategories: ["performance", "pwa", "accessibility"],
11:     port: chrome.port,
12:   };
13: 
14:   const runnerResult = await lighthouse("http://localhost:3000", options);
15: 
16: 
17:   const { performance, pwa, accessibility } = runnerResult.lhr.categories;
18: 
19:   console.log("Lighthouse Scores:");
20:   console.log(`Performance: ${Math.round(performance.score * 100)}`);
21:   console.log(`PWA: ${Math.round(pwa.score * 100)}`);
22:   console.log(`Accessibility: ${Math.round(accessibility.score * 100)}`);
23: 
24: 
25:   if (performance.score < 0.9 || pwa.score < 0.9 || accessibility.score < 0.9) {
26:     process.exit(1);
27:   }
28: 
29:   await chrome.kill();
30: }
31: 
32: runLighthouse().catch(console.error);

================
File: src/__tests__/components/LogCare.test.tsx
================
 1: import { describe, it, expect, beforeEach } from "@jest/globals";
 2: import { render, screen } from "@testing-library/react";
 3: import { MemoryRouter } from "react-router-dom";
 4: import LogCare from "../../pages/care/LogCare";
 5: import { initializeDatabase } from "@/db/seedData";
 6: 
 7: 
 8: jest.mock("@/pages/care/CareLogForm", () => ({
 9:   CareLogForm: ({ preselectedPlantId }: { preselectedPlantId?: string }) => (
10:     <div data-testid="care-log-form">
11:       {preselectedPlantId && (
12:         <div data-testid="pre-selected-plant-id">{preselectedPlantId}</div>
13:       )}
14:     </div>
15:   ),
16: }));
17: 
18: describe("LogCare", () => {
19:   beforeEach(async () => {
20:     await initializeDatabase();
21:   });
22: 
23:   it("renders without a pre-selected plant", () => {
24:     render(
25:       <MemoryRouter initialEntries={["/log-care"]}>
26:         <LogCare />
27:       </MemoryRouter>
28:     );
29: 
30:     expect(screen.getByText("Log Care Activity")).toBeInTheDocument();
31:     expect(screen.getByTestId("care-log-form")).toBeInTheDocument();
32:     expect(
33:       screen.queryByTestId("pre-selected-plant-id")
34:     ).not.toBeInTheDocument();
35:   });
36: 
37:   it("passes pre-selected plant ID from URL params to CareLogForm", () => {
38:     const testPlantId = "test-plant-123";
39: 
40:     render(
41:       <MemoryRouter initialEntries={[`/log-care?plantId=${testPlantId}`]}>
42:         <LogCare />
43:       </MemoryRouter>
44:     );
45: 
46:     expect(screen.getByText("Log Care Activity")).toBeInTheDocument();
47:     expect(screen.getByTestId("care-log-form")).toBeInTheDocument();
48:     expect(screen.getByTestId("pre-selected-plant-id")).toHaveTextContent(
49:       testPlantId
50:     );
51:   });
52: });

================
File: src/__tests__/components/PlantReminderSettings.test.tsx
================
  1: import { render, screen, waitFor } from "@testing-library/react";
  2: import userEvent from "@testing-library/user-event";
  3: import PlantReminderSettings from "@/components/plant/PlantReminderSettings";
  4: import { plantService } from "@/types/database";
  5: import toast from "react-hot-toast";
  6: 
  7: 
  8: jest.mock("@/types/database", () => ({
  9:   plantService: {
 10:     updatePlant: jest.fn(),
 11:   },
 12: }));
 13: 
 14: jest.mock("react-hot-toast", () => ({
 15:   __esModule: true,
 16:   default: {
 17:     success: jest.fn(),
 18:     error: jest.fn(),
 19:   },
 20: }));
 21: 
 22: jest.mock("@/components/plant/ReminderPreferencesSection", () => ({
 23:   __esModule: true,
 24: 
 25:   default: ({ preferences, onChange }: any) => (
 26:     <div data-testid="reminder-preferences-section">
 27:       <button
 28:         data-testid="toggle-watering"
 29:         onClick={() =>
 30:           onChange({ ...preferences, watering: !preferences.watering })
 31:         }
 32:       >
 33:         Toggle Watering: {preferences.watering ? "ON" : "OFF"}
 34:       </button>
 35:     </div>
 36:   ),
 37: }));
 38: 
 39: const mockPlantService = plantService as jest.Mocked<typeof plantService>;
 40: const mockToast = toast as jest.Mocked<typeof toast>;
 41: 
 42: describe("PlantReminderSettings", () => {
 43:   const mockPlant = {
 44:     id: "test-plant-1",
 45:     varietyId: "tomato-1",
 46:     varietyName: "Roma Tomato",
 47:     name: "My Tomato",
 48:     plantedDate: new Date("2024-01-01"),
 49:     currentStage: "vegetative" as const,
 50:     location: "Indoor",
 51:     container: "5 gallon pot",
 52:     isActive: true,
 53:     notes: [],
 54:     createdAt: new Date(),
 55:     updatedAt: new Date(),
 56:     reminderPreferences: {
 57:       watering: true,
 58:       fertilizing: true,
 59:       observation: false,
 60:       lighting: true,
 61:       pruning: false,
 62:     },
 63:   };
 64: 
 65:   const mockOnUpdate = jest.fn();
 66: 
 67:   beforeEach(() => {
 68:     jest.clearAllMocks();
 69:     mockPlantService.updatePlant.mockResolvedValue(undefined);
 70:   });
 71: 
 72:   it("renders with current plant preferences", () => {
 73:     render(<PlantReminderSettings plant={mockPlant} onUpdate={mockOnUpdate} />);
 74: 
 75:     expect(
 76:       screen.getByTestId("reminder-preferences-section")
 77:     ).toBeInTheDocument();
 78:     expect(screen.getByText("Toggle Watering: ON")).toBeInTheDocument();
 79:   });
 80: 
 81:   it("shows 'No Changes' button when preferences haven't changed", () => {
 82:     render(<PlantReminderSettings plant={mockPlant} onUpdate={mockOnUpdate} />);
 83: 
 84:     const saveButton = screen.getByRole("button", { name: /no changes/i });
 85:     expect(saveButton).toBeDisabled();
 86:   });
 87: 
 88:   it("shows 'Save Changes' button when preferences change", async () => {
 89:     const user = userEvent.setup();
 90: 
 91:     render(<PlantReminderSettings plant={mockPlant} onUpdate={mockOnUpdate} />);
 92: 
 93: 
 94:     const toggleButton = screen.getByTestId("toggle-watering");
 95:     await user.click(toggleButton);
 96: 
 97:     await waitFor(() => {
 98:       const saveButton = screen.getByRole("button", { name: /save changes/i });
 99:       expect(saveButton).not.toBeDisabled();
100:     });
101:   });
102: 
103:   it("saves preferences successfully", async () => {
104:     const user = userEvent.setup();
105: 
106:     render(<PlantReminderSettings plant={mockPlant} onUpdate={mockOnUpdate} />);
107: 
108: 
109:     const toggleButton = screen.getByTestId("toggle-watering");
110:     await user.click(toggleButton);
111: 
112: 
113:     const saveButton = screen.getByRole("button", { name: /save changes/i });
114:     await user.click(saveButton);
115: 
116:     await waitFor(() => {
117:       expect(mockPlantService.updatePlant).toHaveBeenCalledWith(
118:         "test-plant-1",
119:         {
120:           reminderPreferences: {
121:             watering: false,
122:             fertilizing: true,
123:             observation: false,
124:             lighting: true,
125:             pruning: false,
126:           },
127:           updatedAt: expect.any(Date),
128:         }
129:       );
130:     });
131: 
132:     expect(mockOnUpdate).toHaveBeenCalledWith({
133:       ...mockPlant,
134:       reminderPreferences: {
135:         watering: false,
136:         fertilizing: true,
137:         observation: false,
138:         lighting: true,
139:         pruning: false,
140:       },
141:     });
142: 
143:     expect(mockToast.success).toHaveBeenCalledWith(
144:       "Reminder preferences updated!"
145:     );
146:   });
147: 
148:   it("handles save errors gracefully", async () => {
149:     const user = userEvent.setup();
150:     mockPlantService.updatePlant.mockRejectedValue(new Error("Database error"));
151: 
152:     render(<PlantReminderSettings plant={mockPlant} onUpdate={mockOnUpdate} />);
153: 
154: 
155:     const toggleButton = screen.getByTestId("toggle-watering");
156:     await user.click(toggleButton);
157: 
158: 
159:     const saveButton = screen.getByRole("button", { name: /save changes/i });
160:     await user.click(saveButton);
161: 
162:     await waitFor(() => {
163:       expect(mockToast.error).toHaveBeenCalledWith(
164:         "Failed to update preferences"
165:       );
166:     });
167: 
168:     expect(mockOnUpdate).not.toHaveBeenCalled();
169:   });
170: 
171:   it("shows loading state during save", async () => {
172:     const user = userEvent.setup();
173: 
174: 
175:     mockPlantService.updatePlant.mockImplementation(
176:       () => new Promise(() => {})
177:     );
178: 
179:     render(<PlantReminderSettings plant={mockPlant} onUpdate={mockOnUpdate} />);
180: 
181: 
182:     const toggleButton = screen.getByTestId("toggle-watering");
183:     await user.click(toggleButton);
184: 
185: 
186:     const saveButton = screen.getByRole("button", { name: /save changes/i });
187:     await user.click(saveButton);
188: 
189: 
190:     expect(screen.getByText("Saving...")).toBeInTheDocument();
191:     expect(saveButton).toBeDisabled();
192:   });
193: 
194:   it("uses default preferences when plant has none", () => {
195:     const plantWithoutPreferences = {
196:       ...mockPlant,
197:       reminderPreferences: undefined,
198:     };
199: 
200:     render(
201:       <PlantReminderSettings
202:         plant={plantWithoutPreferences}
203:         onUpdate={mockOnUpdate}
204:       />
205:     );
206: 
207: 
208:     expect(screen.getByText("Toggle Watering: ON")).toBeInTheDocument();
209:   });
210: });

================
File: src/__tests__/components/PlantStageDisplay.test.tsx
================
 1: import { render, screen } from "@testing-library/react";
 2: import PlantStageDisplay from "@/components/plant/PlantStageDisplay";
 3: import { PlantRecord } from "@/types/database";
 4: 
 5: 
 6: jest.mock("@/hooks/useDynamicStage", () => ({
 7:   useDynamicStage: jest.fn(),
 8: }));
 9: 
10: import { useDynamicStage } from "@/hooks/useDynamicStage";
11: const mockUseDynamicStage = useDynamicStage as jest.MockedFunction<
12:   typeof useDynamicStage
13: >;
14: 
15: describe("PlantStageDisplay", () => {
16:   const mockPlant: PlantRecord = {
17:     id: "test-plant",
18:     varietyId: "test-variety",
19:     varietyName: "Test Variety",
20:     name: "Test Plant",
21:     plantedDate: new Date(),
22:     currentStage: "vegetative",
23:     location: "Indoor",
24:     container: "5 gallon",
25:     isActive: true,
26:     createdAt: new Date(),
27:     updatedAt: new Date(),
28:   };
29: 
30:   beforeEach(() => {
31:     mockUseDynamicStage.mockReturnValue("flowering");
32:   });
33: 
34:   afterEach(() => {
35:     jest.clearAllMocks();
36:   });
37: 
38:   it("displays plant stage without emoji by default", () => {
39:     render(<PlantStageDisplay plant={mockPlant} />);
40: 
41:     expect(screen.getByText("Stage: flowering")).toBeInTheDocument();
42:     expect(screen.queryByText("🌱")).not.toBeInTheDocument();
43:   });
44: 
45:   it("displays plant stage with emoji when showEmoji is true", () => {
46:     render(<PlantStageDisplay plant={mockPlant} showEmoji={true} />);
47: 
48:     expect(screen.getByText("Stage: flowering")).toBeInTheDocument();
49:     expect(screen.getByText("🌱")).toBeInTheDocument();
50:   });
51: 
52:   it("applies custom className when provided", () => {
53:     render(<PlantStageDisplay plant={mockPlant} className="custom-class" />);
54: 
55:     const stageDisplay = screen.getByText(/Stage:/).closest("div");
56:     expect(stageDisplay).toHaveClass("custom-class");
57:   });
58: 
59:   it("uses calculated stage from useDynamicStage hook", () => {
60:     mockUseDynamicStage.mockReturnValue("harvest");
61: 
62:     render(<PlantStageDisplay plant={mockPlant} />);
63: 
64:     expect(screen.getByText("Stage: harvest")).toBeInTheDocument();
65:     expect(mockUseDynamicStage).toHaveBeenCalledWith(mockPlant);
66:   });
67: });

================
File: src/__tests__/components/ReminderPreferencesSection.test.tsx
================
  1: import { render, screen } from "@testing-library/react";
  2: import userEvent from "@testing-library/user-event";
  3: import ReminderPreferencesSection from "@/components/plant/ReminderPreferencesSection";
  4: 
  5: describe("ReminderPreferencesSection", () => {
  6:   const defaultPreferences = {
  7:     watering: true,
  8:     fertilizing: true,
  9:     observation: true,
 10:     lighting: true,
 11:     pruning: true,
 12:   };
 13: 
 14:   const mockOnChange = jest.fn();
 15: 
 16:   beforeEach(() => {
 17:     jest.clearAllMocks();
 18:   });
 19: 
 20:   it("renders all reminder types with correct labels", () => {
 21:     render(
 22:       <ReminderPreferencesSection
 23:         preferences={defaultPreferences}
 24:         onChange={mockOnChange}
 25:       />
 26:     );
 27: 
 28:     expect(screen.getByText("Reminder Preferences")).toBeInTheDocument();
 29:     expect(screen.getByText("Watering")).toBeInTheDocument();
 30:     expect(screen.getByText("Fertilizing")).toBeInTheDocument();
 31:     expect(screen.getByText("Health Checks")).toBeInTheDocument();
 32:     expect(screen.getByText("Lighting")).toBeInTheDocument();
 33:     expect(screen.getByText("Maintenance")).toBeInTheDocument();
 34: 
 35: 
 36:     expect(
 37:       screen.getByText("Get notified when watering is due")
 38:     ).toBeInTheDocument();
 39:     expect(
 40:       screen.getByText("Reminders for feeding schedule")
 41:     ).toBeInTheDocument();
 42:     expect(
 43:       screen.getByText("Regular observation reminders")
 44:     ).toBeInTheDocument();
 45:   });
 46: 
 47:   it("displays current preference states correctly", () => {
 48:     const mixedPreferences = {
 49:       watering: true,
 50:       fertilizing: false,
 51:       observation: true,
 52:       lighting: false,
 53:       pruning: true,
 54:     };
 55: 
 56:     render(
 57:       <ReminderPreferencesSection
 58:         preferences={mixedPreferences}
 59:         onChange={mockOnChange}
 60:       />
 61:     );
 62: 
 63: 
 64:     const switches = screen.getAllByRole("switch");
 65:     expect(switches).toHaveLength(5);
 66: 
 67: 
 68:     expect(switches[0]).toHaveAttribute("aria-checked", "true");
 69: 
 70:     expect(switches[1]).toHaveAttribute("aria-checked", "false");
 71: 
 72:     expect(switches[2]).toHaveAttribute("aria-checked", "true");
 73: 
 74:     expect(switches[3]).toHaveAttribute("aria-checked", "false");
 75: 
 76:     expect(switches[4]).toHaveAttribute("aria-checked", "true");
 77:   });
 78: 
 79:   it("calls onChange when a switch is toggled", async () => {
 80:     const user = userEvent.setup();
 81: 
 82:     render(
 83:       <ReminderPreferencesSection
 84:         preferences={defaultPreferences}
 85:         onChange={mockOnChange}
 86:       />
 87:     );
 88: 
 89: 
 90:     const wateringSwitch = screen.getAllByRole("switch")[0];
 91:     await user.click(wateringSwitch);
 92: 
 93:     expect(mockOnChange).toHaveBeenCalledWith({
 94:       watering: false,
 95:       fertilizing: true,
 96:       observation: true,
 97:       lighting: true,
 98:       pruning: true,
 99:     });
100:   });
101: 
102:   it("toggles multiple preferences correctly", async () => {
103:     const user = userEvent.setup();
104: 
105:     render(
106:       <ReminderPreferencesSection
107:         preferences={defaultPreferences}
108:         onChange={mockOnChange}
109:       />
110:     );
111: 
112: 
113:     const fertilizingSwitch = screen.getAllByRole("switch")[1];
114:     await user.click(fertilizingSwitch);
115: 
116:     expect(mockOnChange).toHaveBeenCalledWith({
117:       watering: true,
118:       fertilizing: false,
119:       observation: true,
120:       lighting: true,
121:       pruning: true,
122:     });
123: 
124: 
125:     const lightingSwitch = screen.getAllByRole("switch")[3];
126:     await user.click(lightingSwitch);
127: 
128:     expect(mockOnChange).toHaveBeenCalledWith({
129:       watering: true,
130:       fertilizing: true,
131:       observation: true,
132:       lighting: false,
133:       pruning: true,
134:     });
135:   });
136: 
137:   it("has proper accessibility attributes", () => {
138:     render(
139:       <ReminderPreferencesSection
140:         preferences={defaultPreferences}
141:         onChange={mockOnChange}
142:       />
143:     );
144: 
145:     const switches = screen.getAllByRole("switch");
146:     switches.forEach((switchElement) => {
147:       expect(switchElement).toHaveAttribute("aria-checked");
148:       expect(switchElement).not.toHaveAttribute("aria-disabled");
149:     });
150:   });
151: });

================
File: src/__tests__/components/SoilMixtureSelector.test.tsx
================
  1: import { render, screen, waitFor } from "@testing-library/react";
  2: import userEvent from "@testing-library/user-event";
  3: import { PlantCategory } from "@/types";
  4: import SoilMixtureSelector from "@/components/plant/SoilMixtureSelector";
  5: 
  6: describe("SoilMixtureSelector", () => {
  7:   const user = userEvent.setup();
  8:   const mockOnMixtureChange = jest.fn();
  9: 
 10:   beforeEach(() => {
 11:     jest.clearAllMocks();
 12:   });
 13: 
 14:   const renderSelector = (props = {}) => {
 15:     return render(
 16:       <SoilMixtureSelector onMixtureChange={mockOnMixtureChange} {...props} />
 17:     );
 18:   };
 19: 
 20:   describe("Initial Rendering", () => {
 21:     it("renders with default state", () => {
 22:       renderSelector();
 23: 
 24:       expect(screen.getByText("Soil Mixture")).toBeInTheDocument();
 25:       expect(
 26:         screen.getByText(
 27:           "Choose a preset mixture or create your own custom blend"
 28:         )
 29:       ).toBeInTheDocument();
 30:       expect(screen.getByText("🧪 Create Custom Mixture")).toBeInTheDocument();
 31:     });
 32: 
 33:     it("displays all preset mixtures", () => {
 34:       renderSelector();
 35: 
 36: 
 37:       expect(screen.getByText("Leafy Greens Mix")).toBeInTheDocument();
 38:       expect(screen.getByText("Root Vegetables Mix")).toBeInTheDocument();
 39:       expect(screen.getByText("Mediterranean Herbs Mix")).toBeInTheDocument();
 40:       expect(screen.getByText("Berry & Fruit Mix")).toBeInTheDocument();
 41:       expect(screen.getByText("Fruiting Plants Mix")).toBeInTheDocument();
 42:       expect(screen.getByText("Universal Garden Mix")).toBeInTheDocument();
 43:     });
 44: 
 45:     it("shows mixture descriptions and components", () => {
 46:       renderSelector();
 47: 
 48:       expect(
 49:         screen.getByText(
 50:           "Nutrient-rich blend perfect for arugula, spinach, and lettuce"
 51:         )
 52:       ).toBeInTheDocument();
 53:       expect(
 54:         screen.getByText(
 55:           /40% Coco Coir, 25% Perlite, 25% Vermiculite, 10% Worm Castings/
 56:         )
 57:       ).toBeInTheDocument();
 58:     });
 59:   });
 60: 
 61:   describe("Category-based Recommendations", () => {
 62:     it("shows recommended badge for matching category", () => {
 63:       renderSelector({ plantCategory: "leafy-greens" as PlantCategory });
 64: 
 65: 
 66:       const leafyGreensCard =
 67:         screen.getByText("Leafy Greens Mix").closest("[data-testid]") ||
 68:         screen.getByText("Leafy Greens Mix").closest("div")?.closest("div");
 69:       expect(leafyGreensCard).toHaveTextContent("Recommended");
 70:     });
 71: 
 72:     it("prioritizes category-specific mixtures first", () => {
 73:       renderSelector({ plantCategory: "herbs" as PlantCategory });
 74: 
 75:       const cards = screen.getAllByText(/Mix$/);
 76: 
 77:       expect(cards[0]).toHaveTextContent("Mediterranean Herbs Mix");
 78:     });
 79: 
 80:     it("still shows all mixtures when category provided", () => {
 81:       renderSelector({ plantCategory: "herbs" as PlantCategory });
 82: 
 83: 
 84:       expect(screen.getByText("Leafy Greens Mix")).toBeInTheDocument();
 85:       expect(screen.getByText("Universal Garden Mix")).toBeInTheDocument();
 86:     });
 87:   });
 88: 
 89:   describe("Preset Selection", () => {
 90:     it("calls onMixtureChange when preset is selected", async () => {
 91:       renderSelector();
 92: 
 93: 
 94:       const clickableCards = document.querySelectorAll(".cursor-pointer");
 95: 
 96: 
 97:       let leafyGreensCard: Element | null = null;
 98:       clickableCards.forEach((card) => {
 99:         if (card.textContent?.includes("Leafy Greens Mix")) {
100:           leafyGreensCard = card;
101:         }
102:       });
103: 
104: 
105:       if (!leafyGreensCard) {
106:         const leafyGreensText = screen.getByText("Leafy Greens Mix");
107: 
108:         let current = leafyGreensText.parentElement;
109:         while (current && !current.classList.contains("cursor-pointer")) {
110:           current = current.parentElement;
111:         }
112:         leafyGreensCard = current;
113:       }
114: 
115:       expect(leafyGreensCard).toBeTruthy();
116:       await user.click(leafyGreensCard!);
117: 
118:       expect(mockOnMixtureChange).toHaveBeenCalledWith(
119:         "Leafy Greens Mix: 40% Coco Coir, 25% Perlite, 25% Vermiculite, 10% Worm Castings"
120:       );
121:     });
122: 
123:     it("shows selected state when mixture is selected", () => {
124:       renderSelector({
125:         selectedMixture:
126:           "Leafy Greens Mix: 40% Coco Coir, 25% Perlite, 25% Vermiculite, 10% Worm Castings",
127:       });
128: 
129:       const leafyGreensText = screen.getByText("Leafy Greens Mix");
130:       const leafyGreensCard =
131:         leafyGreensText.closest(".cursor-pointer") ||
132:         leafyGreensText.closest("div")?.closest("div")?.closest("div");
133: 
134: 
135:       expect(leafyGreensCard).toHaveClass("cursor-pointer");
136: 
137:       expect(leafyGreensCard).toHaveClass(
138:         "ring-4",
139:         "ring-green-500",
140:         "bg-green-100"
141:       );
142:     });
143: 
144:     it("displays selected mixture information", () => {
145:       const selectedMixture =
146:         "Root Vegetables Mix: 40% Coco Coir, 30% Perlite, 25% Vermiculite, 5% Worm Castings";
147:       renderSelector({ selectedMixture });
148: 
149:       expect(screen.getByText("Selected Mixture:")).toBeInTheDocument();
150:       expect(screen.getByText(selectedMixture)).toBeInTheDocument();
151:     });
152:   });
153: 
154:   describe("Custom Mixture Functionality", () => {
155:     it("switches to custom mode when button clicked", async () => {
156:       renderSelector();
157: 
158:       const customButton = screen.getByText("🧪 Create Custom Mixture");
159:       await user.click(customButton);
160: 
161:       expect(screen.getByText("Custom Soil Mixture")).toBeInTheDocument();
162:       expect(screen.getByText("Mixture Description")).toBeInTheDocument();
163:       expect(screen.getByPlaceholderText(/40% coco coir/)).toBeInTheDocument();
164:     });
165: 
166:     it("allows typing in custom mixture textarea", async () => {
167:       renderSelector();
168: 
169:       const customButton = screen.getByText("🧪 Create Custom Mixture");
170:       await user.click(customButton);
171: 
172:       const textarea = screen.getByPlaceholderText(/40% coco coir/);
173:       await user.type(textarea, "50% peat moss, 30% perlite, 20% sand");
174: 
175:       expect(textarea).toHaveValue("50% peat moss, 30% perlite, 20% sand");
176:     });
177: 
178:     it("calls onMixtureChange when custom mixture is submitted", async () => {
179:       renderSelector();
180: 
181:       const customButton = screen.getByText("🧪 Create Custom Mixture");
182:       await user.click(customButton);
183: 
184:       const textarea = screen.getByPlaceholderText(/40% coco coir/);
185:       await user.type(textarea, "Custom mix");
186: 
187:       const useButton = screen.getByRole("button", {
188:         name: /use this mixture/i,
189:       });
190:       await user.click(useButton);
191: 
192:       expect(mockOnMixtureChange).toHaveBeenCalledWith("Custom mix");
193:     });
194: 
195:     it("disables submit button when textarea is empty", async () => {
196:       renderSelector();
197: 
198:       const customButton = screen.getByText("🧪 Create Custom Mixture");
199:       await user.click(customButton);
200: 
201:       const useButton = screen.getByRole("button", {
202:         name: /use this mixture/i,
203:       });
204:       expect(useButton).toBeDisabled();
205:     });
206: 
207:     it("returns to presets when back button clicked", async () => {
208:       renderSelector();
209: 
210: 
211:       const customButton = screen.getByText("🧪 Create Custom Mixture");
212:       await user.click(customButton);
213: 
214: 
215:       const backButton = screen.getByRole("button", {
216:         name: /back to presets/i,
217:       });
218:       await user.click(backButton);
219: 
220: 
221:       expect(screen.getByText("Leafy Greens Mix")).toBeInTheDocument();
222:       expect(screen.queryByText("Custom Soil Mixture")).not.toBeInTheDocument();
223:     });
224: 
225:     it("closes custom mode after successful submission", async () => {
226:       renderSelector();
227: 
228:       const customButton = screen.getByText("🧪 Create Custom Mixture");
229:       await user.click(customButton);
230: 
231:       const textarea = screen.getByPlaceholderText(/40% coco coir/);
232:       await user.type(textarea, "Custom mix");
233: 
234:       const useButton = screen.getByRole("button", {
235:         name: /use this mixture/i,
236:       });
237:       await user.click(useButton);
238: 
239: 
240:       await waitFor(() => {
241:         expect(screen.getByText("Leafy Greens Mix")).toBeInTheDocument();
242:         expect(
243:           screen.queryByText("Custom Soil Mixture")
244:         ).not.toBeInTheDocument();
245:       });
246:     });
247:   });
248: 
249:   describe("Mixture Information Display", () => {
250:     it("shows components for different mixtures", () => {
251:       renderSelector();
252: 
253: 
254:       const leafyGreensComponents = screen.getAllByText(
255:         /40% Coco Coir, 25% Perlite, 25% Vermiculite, 10% Worm Castings/
256:       );
257:       expect(leafyGreensComponents.length).toBeGreaterThan(0);
258: 
259:       const rootVegComponents = screen.getAllByText(
260:         /40% Coco Coir, 30% Perlite, 25% Vermiculite, 5% Worm Castings/
261:       );
262:       expect(rootVegComponents.length).toBeGreaterThan(0);
263:     });
264: 
265:     it("shows amendments when available", () => {
266:       renderSelector();
267: 
268:       expect(
269:         screen.getByText(/Compost \(½–1 cup per cubic foot\)/)
270:       ).toBeInTheDocument();
271:       expect(
272:         screen.getByText(/Bone Meal \(1 tsp per gallon\)/)
273:       ).toBeInTheDocument();
274:     });
275: 
276:     it("shows suitable plants information", () => {
277:       renderSelector();
278: 
279:       expect(
280:         screen.getByText(/Arugula, Spinach, Lettuce, Kale/)
281:       ).toBeInTheDocument();
282:       expect(
283:         screen.getByText(/Carrots, Beets, Onions, Radishes/)
284:       ).toBeInTheDocument();
285:     });
286:   });
287: 
288:   describe("Edge Cases", () => {
289:     it("handles undefined selectedMixture gracefully", () => {
290:       renderSelector({ selectedMixture: undefined });
291: 
292:       expect(screen.getByText("Soil Mixture")).toBeInTheDocument();
293:       expect(screen.queryByText("Selected Mixture:")).not.toBeInTheDocument();
294:     });
295: 
296:     it("handles empty selectedMixture gracefully", () => {
297:       renderSelector({ selectedMixture: "" });
298: 
299:       expect(screen.getByText("Soil Mixture")).toBeInTheDocument();
300:       expect(screen.queryByText("Selected Mixture:")).not.toBeInTheDocument();
301:     });
302: 
303:     it("handles undefined plantCategory gracefully", () => {
304:       renderSelector({ plantCategory: undefined });
305: 
306:       expect(screen.getByText("Soil Mixture")).toBeInTheDocument();
307: 
308: 
309: 
310: 
311:       expect(screen.getByText("Universal Garden Mix")).toBeInTheDocument();
312:     });
313: 
314:     it("handles custom mixture with only whitespace", async () => {
315:       renderSelector();
316: 
317:       const customButton = screen.getByText("🧪 Create Custom Mixture");
318:       await user.click(customButton);
319: 
320:       const textarea = screen.getByPlaceholderText(/40% coco coir/);
321:       await user.type(textarea, "   ");
322: 
323:       const useButton = screen.getByRole("button", {
324:         name: /use this mixture/i,
325:       });
326:       expect(useButton).toBeDisabled();
327:     });
328:   });
329: 
330:   describe("Accessibility", () => {
331:     it("has proper labels and structure", () => {
332:       renderSelector();
333: 
334:       expect(screen.getByText("Soil Mixture")).toBeInTheDocument();
335:       expect(
336:         screen.getByText(
337:           "Choose a preset mixture or create your own custom blend"
338:         )
339:       ).toBeInTheDocument();
340:     });
341: 
342:     it("has accessible buttons", () => {
343:       renderSelector();
344: 
345:       const customButton = screen.getByRole("button", {
346:         name: /create custom mixture/i,
347:       });
348:       expect(customButton).toBeInTheDocument();
349:     });
350: 
351:     it("maintains accessibility in custom mode", async () => {
352:       renderSelector();
353: 
354:       const customButton = screen.getByText("🧪 Create Custom Mixture");
355:       await user.click(customButton);
356: 
357: 
358:       expect(screen.getByLabelText("Mixture Description")).toBeInTheDocument();
359:       expect(
360:         screen.getByRole("button", { name: /use this mixture/i })
361:       ).toBeInTheDocument();
362:       expect(
363:         screen.getByRole("button", { name: /back to presets/i })
364:       ).toBeInTheDocument();
365:     });
366:   });
367: });

================
File: src/__tests__/database/plantService.test.ts
================
 1: import { plantService, PlantRecord } from "../../types/database";
 2: 
 3: describe("plantService", () => {
 4:   beforeEach(async () => {
 5: 
 6:     const db = await import("../../types/database").then((m) => m.db);
 7:     await db.plants.clear();
 8:   });
 9: 
10:   it("adds and retrieves a plant", async () => {
11:     const plantData: Omit<PlantRecord, "id" | "createdAt" | "updatedAt"> = {
12:       varietyId: "test-variety",
13:       name: "Test Plant",
14:       varietyName: "Test Variety",
15:       plantedDate: new Date("2024-01-01"),
16:       currentStage: "seedling",
17:       location: "Indoor",
18:       container: "Test Container",
19:       isActive: true,
20:       notes: ["Test note"],
21:     };
22: 
23:     const plantId = await plantService.addPlant(plantData);
24:     expect(plantId).toBeDefined();
25: 
26:     const retrievedPlant = await plantService.getPlant(plantId);
27:     expect(retrievedPlant).toBeDefined();
28:     expect(retrievedPlant?.name).toBe("Test Plant");
29:     expect(retrievedPlant?.varietyId).toBe("test-variety");
30:   });
31: 
32:   it("retrieves only active plants", async () => {
33: 
34:     await plantService.addPlant({
35:       varietyId: "active-variety",
36:       varietyName: "Active Variety",
37:       plantedDate: new Date(),
38:       currentStage: "vegetative",
39:       location: "Location 1",
40:       container: "Container 1",
41:       isActive: true,
42:     });
43: 
44: 
45:     const inactiveId = await plantService.addPlant({
46:       varietyId: "inactive-variety",
47:       varietyName: "Inactive Variety",
48:       plantedDate: new Date(),
49:       currentStage: "vegetative",
50:       location: "Location 2",
51:       container: "Container 2",
52:       isActive: true,
53:     });
54: 
55: 
56:     await plantService.updatePlant(inactiveId, { isActive: false });
57: 
58:     const activePlants = await plantService.getActivePlants();
59:     expect(activePlants).toHaveLength(1);
60:     expect(activePlants[0].varietyId).toBe("active-variety");
61:   });
62: });

================
File: src/__tests__/integration/plantDetailReminderSettings.test.tsx
================
 1: import { render, screen, waitFor } from "@testing-library/react";
 2: import userEvent from "@testing-library/user-event";
 3: import { BrowserRouter } from "react-router-dom";
 4: import PlantDetail from "@/pages/plants/PlantDetail";
 5: import { plantService } from "@/types/database";
 6: 
 7: 
 8: jest.mock("react-router-dom", () => ({
 9:   ...jest.requireActual("react-router-dom"),
10:   useParams: () => ({ plantId: "test-plant-1" }),
11:   useNavigate: () => jest.fn(),
12: }));
13: 
14: describe("PlantDetail Reminder Settings Integration", () => {
15:   it("shows and hides reminder settings when settings button is clicked", async () => {
16:     const user = userEvent.setup();
17: 
18: 
19:     jest.spyOn(plantService, "getPlant").mockResolvedValue({
20:       id: "test-plant-1",
21:       varietyId: "tomato-1",
22:       varietyName: "Roma Tomato",
23:       name: "My Tomato",
24:       plantedDate: new Date(),
25:       currentStage: "vegetative",
26:       location: "Indoor",
27:       container: "5 gallon pot",
28:       isActive: true,
29:       notes: [],
30:       createdAt: new Date(),
31:       updatedAt: new Date(),
32:       reminderPreferences: {
33:         watering: true,
34:         fertilizing: false,
35:         observation: true,
36:         lighting: false,
37:         pruning: true,
38:       },
39:     });
40: 
41:     render(
42:       <BrowserRouter>
43:         <PlantDetail />
44:       </BrowserRouter>
45:     );
46: 
47:     await waitFor(() => {
48:       expect(screen.getByText("My Tomato")).toBeInTheDocument();
49:     });
50: 
51: 
52:     expect(screen.queryByText("Notification Settings")).not.toBeInTheDocument();
53: 
54: 
55:     const settingsButton = screen.getByRole("button", { name: /settings/i });
56:     await user.click(settingsButton);
57: 
58: 
59:     await waitFor(() => {
60:       expect(screen.getByText("Notification Settings")).toBeInTheDocument();
61:     });
62: 
63: 
64:     await user.click(settingsButton);
65: 
66:     await waitFor(() => {
67:       expect(
68:         screen.queryByText("Notification Settings")
69:       ).not.toBeInTheDocument();
70:     });
71:   });
72: 
73:   it.skip("displays active reminder preferences correctly", async () => {
74: 
75: 
76:   });
77: });

================
File: src/__tests__/integration/plantManagement.test.tsx
================
  1: import { render, screen, waitFor } from "@testing-library/react";
  2: import { BrowserRouter } from "react-router-dom";
  3: import Dashboard from "@/pages/dashboard";
  4: import PlantDetail from "@/pages/plants/PlantDetail";
  5: import {
  6:   plantService,
  7:   careService,
  8:   varietyService,
  9:   CareRecord,
 10: } from "@/types/database";
 11: import { initializeDatabase } from "@/db/seedData";
 12: import { subDays } from "date-fns";
 13: 
 14: 
 15: const mockNavigate = jest.fn();
 16: const mockUseParams = jest.fn();
 17: 
 18: jest.mock("react-router-dom", () => ({
 19:   ...jest.requireActual("react-router-dom"),
 20:   useNavigate: () => mockNavigate,
 21:   useParams: () => mockUseParams(),
 22: }));
 23: 
 24: describe("Plant Management Integration", () => {
 25:   beforeEach(async () => {
 26:     jest.clearAllMocks();
 27:     mockUseParams.mockReturnValue({ plantId: "test-plant-id" });
 28: 
 29: 
 30:     const { db } = await import("@/types/database");
 31:     await db.plants.clear();
 32:     await db.varieties.clear();
 33:     await db.careActivities.clear();
 34:     await initializeDatabase();
 35:   });
 36: 
 37:   describe("Complete Plant Lifecycle Workflow", () => {
 38:     it("completes full plant lifecycle workflow", async () => {
 39: 
 40:       const varieties = await varietyService.getAllVarieties();
 41:       const testVariety = varieties[0];
 42: 
 43:       const plantId = await plantService.addPlant({
 44:         varietyId: testVariety.id,
 45:         varietyName: testVariety.name,
 46:         name: "Integration Test Plant",
 47:         plantedDate: subDays(new Date(), 14),
 48:         currentStage: "seedling",
 49:         location: "Indoor",
 50:         container: "5 gallon pot",
 51:         isActive: true,
 52:       });
 53: 
 54: 
 55:       const { unmount } = render(
 56:         <BrowserRouter>
 57:           <Dashboard />
 58:         </BrowserRouter>
 59:       );
 60: 
 61:       await waitFor(() => {
 62:         const plantElements = screen.getAllByText("Integration Test Plant");
 63:         expect(plantElements.length).toBeGreaterThan(0);
 64:       });
 65: 
 66: 
 67:       unmount();
 68: 
 69: 
 70:       await careService.addCareActivity({
 71:         plantId,
 72:         type: "water",
 73:         date: new Date(),
 74:         details: {
 75:           type: "water",
 76:           amount: { value: 16, unit: "oz" },
 77:           moistureReading: {
 78:             before: 3,
 79:             after: 7,
 80:             scale: "1-10",
 81:           },
 82:           notes: "Regular watering",
 83:         },
 84:       });
 85: 
 86: 
 87:       const savedCareHistory = await careService.getPlantCareHistory(plantId);
 88:       expect(savedCareHistory).toHaveLength(1);
 89:       expect(savedCareHistory[0].details.notes).toBe("Regular watering");
 90: 
 91: 
 92:       mockUseParams.mockReturnValue({ plantId });
 93: 
 94:       render(
 95:         <BrowserRouter>
 96:           <PlantDetail />
 97:         </BrowserRouter>
 98:       );
 99: 
100: 
101:       await waitFor(() => {
102:         expect(screen.getByText("Integration Test Plant")).toBeInTheDocument();
103:       });
104: 
105: 
106:       await waitFor(
107:         () => {
108: 
109:           expect(screen.getByText("Care History")).toBeInTheDocument();
110: 
111:           expect(screen.getByText("Watering (16 oz)")).toBeInTheDocument();
112:         },
113:         { timeout: 5000 }
114:       );
115: 
116: 
117:       const savedPlant = await plantService.getPlant(plantId);
118:       const careHistory = await careService.getPlantCareHistory(plantId);
119: 
120:       expect(savedPlant).toBeTruthy();
121:       expect(savedPlant!.name).toBe("Integration Test Plant");
122:       expect(careHistory).toHaveLength(1);
123:       expect(careHistory[0].details.notes).toBe("Regular watering");
124:     });
125: 
126:     it("handles plant status changes throughout lifecycle", async () => {
127:       const varieties = await varietyService.getAllVarieties();
128:       const testVariety = varieties[0];
129: 
130: 
131:       const plantId = await plantService.addPlant({
132:         varietyId: testVariety.id,
133:         varietyName: testVariety.name,
134:         plantedDate: subDays(new Date(), 5),
135:         currentStage: "germination",
136:         location: "Indoor",
137:         container: "4 inch pot",
138:         isActive: true,
139:       });
140: 
141: 
142:       await plantService.updatePlant(plantId, {
143:         currentStage: "seedling",
144:         updatedAt: new Date(),
145:       });
146: 
147:       await plantService.updatePlant(plantId, {
148:         currentStage: "vegetative",
149:         updatedAt: new Date(),
150:       });
151: 
152: 
153:       const plant = await plantService.getPlant(plantId);
154:       expect(plant!.currentStage).toBe("vegetative");
155:     });
156:   });
157: 
158:   describe("Plant Deletion and Cleanup", () => {
159:     it("handles plant soft deletion correctly", async () => {
160:       const varieties = await varietyService.getAllVarieties();
161:       const testVariety = varieties[0];
162: 
163: 
164:       const plantId = await plantService.addPlant({
165:         varietyId: testVariety.id,
166:         varietyName: testVariety.name,
167:         plantedDate: subDays(new Date(), 30),
168:         currentStage: "vegetative",
169:         location: "Indoor",
170:         container: "5 gallon pot",
171:         isActive: true,
172:       });
173: 
174: 
175:       const careActivities = [
176:         {
177:           type: "water" as const,
178:           date: subDays(new Date(), 5),
179:           details: {
180:             type: "water" as const,
181:             amount: { value: 16, unit: "oz" as const },
182:           },
183:         },
184:         {
185:           type: "fertilize" as const,
186:           date: subDays(new Date(), 10),
187:           details: {
188:             type: "fertilize" as const,
189:             product: "General fertilizer",
190:             dilution: "1:10",
191:             amount: "1 tbsp",
192:           },
193:         },
194:         {
195:           type: "observe" as const,
196:           date: subDays(new Date(), 3),
197:           details: {
198:             type: "observe" as const,
199:             healthAssessment: "good" as const,
200:             observations: "Looking healthy",
201:             notes: "Plant appears healthy",
202:           },
203:         },
204:       ];
205: 
206:       for (const activity of careActivities) {
207:         await careService.addCareActivity({
208:           plantId,
209:           ...activity,
210:         });
211:       }
212: 
213: 
214:       const initialCareHistory = await careService.getPlantCareHistory(plantId);
215:       expect(initialCareHistory).toHaveLength(3);
216: 
217: 
218:       await plantService.deletePlant(plantId);
219: 
220: 
221:       const deletedPlant = await plantService.getPlant(plantId);
222:       expect(deletedPlant).toBeTruthy();
223:       expect(deletedPlant!.isActive).toBe(false);
224: 
225: 
226:       const remainingCareHistory = await careService.getPlantCareHistory(
227:         plantId
228:       );
229:       expect(remainingCareHistory).toHaveLength(3);
230: 
231: 
232:       const activePlants = await plantService.getActivePlants();
233:       expect(activePlants.find((p) => p.id === plantId)).toBeUndefined();
234:     });
235: 
236:     it("handles multiple plant soft deletion independently", async () => {
237:       const varieties = await varietyService.getAllVarieties();
238:       const testVariety = varieties[0];
239: 
240: 
241:       const plantIds: string[] = [];
242:       for (let i = 0; i < 3; i++) {
243:         const plantId = await plantService.addPlant({
244:           varietyId: testVariety.id,
245:           varietyName: testVariety.name,
246:           plantedDate: subDays(new Date(), 30),
247:           currentStage: "vegetative",
248:           location: `Location ${i}`,
249:           container: "5 gallon pot",
250:           isActive: true,
251:         });
252:         plantIds.push(plantId);
253: 
254: 
255:         await careService.addCareActivity({
256:           plantId,
257:           type: "water",
258:           date: new Date(),
259:           details: {
260:             type: "water",
261:             amount: { value: 16, unit: "oz" },
262:           },
263:         });
264:       }
265: 
266: 
267:       await plantService.deletePlant(plantIds[1]);
268: 
269: 
270:       const remainingActivePlants = await plantService.getActivePlants();
271:       expect(remainingActivePlants).toHaveLength(2);
272:       expect(
273:         remainingActivePlants.find((p) => p.id === plantIds[1])
274:       ).toBeUndefined();
275: 
276: 
277:       const deletedPlant = await plantService.getPlant(plantIds[1]);
278:       expect(deletedPlant).toBeTruthy();
279:       expect(deletedPlant!.isActive).toBe(false);
280: 
281: 
282:       const plant0Care = await careService.getPlantCareHistory(plantIds[0]);
283:       const plant2Care = await careService.getPlantCareHistory(plantIds[2]);
284:       expect(plant0Care).toHaveLength(1);
285:       expect(plant2Care).toHaveLength(1);
286: 
287: 
288:       const deletedPlantCare = await careService.getPlantCareHistory(
289:         plantIds[1]
290:       );
291:       expect(deletedPlantCare).toHaveLength(1);
292:     });
293: 
294:     it("demonstrates hard delete with cascade cleanup", async () => {
295:       const varieties = await varietyService.getAllVarieties();
296:       const testVariety = varieties[0];
297: 
298:       const plantId = await plantService.addPlant({
299:         varietyId: testVariety.id,
300:         varietyName: testVariety.name,
301:         plantedDate: subDays(new Date(), 30),
302:         currentStage: "vegetative",
303:         location: "Indoor",
304:         container: "5 gallon pot",
305:         isActive: true,
306:       });
307: 
308: 
309:       await careService.addCareActivity({
310:         plantId,
311:         type: "water",
312:         date: new Date(),
313:         details: {
314:           type: "water",
315:           amount: { value: 16, unit: "oz" },
316:         },
317:       });
318: 
319: 
320:       const { db } = await import("@/types/database");
321: 
322: 
323:       await db.careActivities.where("plantId").equals(plantId).delete();
324: 
325: 
326:       await db.plants.delete(plantId);
327: 
328: 
329:       const deletedPlant = await plantService.getPlant(plantId);
330:       expect(deletedPlant).toBeUndefined();
331: 
332: 
333:       const remainingCareHistory = await careService.getPlantCareHistory(
334:         plantId
335:       );
336:       expect(remainingCareHistory).toHaveLength(0);
337:     });
338:   });
339: 
340:   describe("Cross-Service Integration", () => {
341:     it("integrates care scheduling with plant management", async () => {
342:       const varieties = await varietyService.getAllVarieties();
343:       const testVariety = varieties[0];
344: 
345: 
346:       const plantId = await plantService.addPlant({
347:         varietyId: testVariety.id,
348:         varietyName: testVariety.name,
349:         plantedDate: subDays(new Date(), 14),
350:         currentStage: "seedling",
351:         location: "Indoor",
352:         container: "4 inch pot",
353:         isActive: true,
354:         reminderPreferences: {
355:           watering: true,
356:           fertilizing: true,
357:           observation: true,
358:           lighting: true,
359:           pruning: true,
360:         },
361:       });
362: 
363: 
364:       const { CareSchedulingService } = await import(
365:         "@/services/careSchedulingService"
366:       );
367: 
368: 
369:       const tasks = await CareSchedulingService.getUpcomingTasks();
370:       const plantTasks = tasks.filter((task) => task.plantId === plantId);
371: 
372:       expect(plantTasks.length).toBeGreaterThan(0);
373: 
374: 
375:       plantTasks.forEach((task) => {
376:         expect(task.plantId).toBe(plantId);
377:         expect(task.dueDate).toBeInstanceOf(Date);
378:         expect(["low", "medium", "high"]).toContain(task.priority);
379:       });
380:     });
381: 
382:     it("integrates smart defaults with plant history", async () => {
383:       const varieties = await varietyService.getAllVarieties();
384:       const testVariety = varieties.find(
385:         (v) =>
386:           v.protocols?.watering && Object.keys(v.protocols.watering).length > 0
387:       );
388: 
389:       if (!testVariety) return;
390: 
391:       const plantId = await plantService.addPlant({
392:         varietyId: testVariety.id,
393:         varietyName: testVariety.name,
394:         plantedDate: subDays(new Date(), 30),
395:         currentStage: "vegetative",
396:         location: "Indoor",
397:         container: "5 gallon pot",
398:         isActive: true,
399:       });
400: 
401: 
402:       await careService.addCareActivity({
403:         plantId,
404:         type: "water",
405:         date: subDays(new Date(), 2),
406:         details: {
407:           type: "water",
408:           amount: { value: 20, unit: "oz" },
409:           moistureReading: {
410:             before: 4,
411:             after: 8,
412:             scale: "1-10",
413:           },
414:         },
415:       });
416: 
417:       const plant = await plantService.getPlant(plantId);
418:       const { SmartDefaultsService } = await import(
419:         "@/services/smartDefaultsService"
420:       );
421: 
422:       const defaults = await SmartDefaultsService.getDefaultsForPlant(plant!);
423:       const quickOptions = await SmartDefaultsService.getQuickCompletionOptions(
424:         plant!,
425:         "water"
426:       );
427: 
428:       expect(defaults).toBeTruthy();
429:       expect(defaults!.watering).toBeTruthy();
430:       expect(quickOptions).toBeTruthy();
431: 
432:       if (quickOptions && quickOptions.length > 0) {
433:         expect(quickOptions[0].values.waterValue).toBeGreaterThan(0);
434:       }
435:     });
436:   });
437: 
438:   describe("Error Handling and Edge Cases", () => {
439:     it("handles invalid plant data gracefully", async () => {
440: 
441:       await expect(
442:         plantService.addPlant({
443:           varietyId: "non-existent-variety",
444:           varietyName: "Invalid Variety",
445:           plantedDate: new Date(),
446:           currentStage: "seedling",
447:           location: "Test",
448:           container: "Test",
449:           isActive: true,
450:         })
451:       ).resolves.toBeTruthy();
452: 
453:       const plants = await plantService.getActivePlants();
454:       const orphanedPlant = plants.find(
455:         (p) => p.varietyId === "non-existent-variety"
456:       );
457:       expect(orphanedPlant).toBeTruthy();
458: 
459: 
460:       const { CareSchedulingService } = await import(
461:         "@/services/careSchedulingService"
462:       );
463:       const tasks = await CareSchedulingService.getUpcomingTasks();
464: 
465: 
466:       expect(Array.isArray(tasks)).toBe(true);
467:       const orphanedTasks = tasks.filter(
468:         (t) => t.plantId === orphanedPlant!.id
469:       );
470:       expect(orphanedTasks).toHaveLength(0);
471:     });
472: 
473:     it("handles concurrent operations safely", async () => {
474:       const varieties = await varietyService.getAllVarieties();
475:       const testVariety = varieties[0];
476: 
477:       const plantId = await plantService.addPlant({
478:         varietyId: testVariety.id,
479:         varietyName: testVariety.name,
480:         plantedDate: new Date(),
481:         currentStage: "seedling",
482:         location: "Test",
483:         container: "Test",
484:         isActive: true,
485:       });
486: 
487: 
488:       const concurrentOperations = Array(5)
489:         .fill(null)
490:         .map((_, index) =>
491:           careService.addCareActivity({
492:             plantId,
493:             type: "water",
494:             date: new Date(),
495:             details: {
496:               type: "water",
497:               amount: { value: 10 + index, unit: "oz" },
498:               notes: `Concurrent operation ${index}`,
499:             },
500:           })
501:         );
502: 
503:       await Promise.all(concurrentOperations);
504: 
505: 
506:       const careHistory = await careService.getPlantCareHistory(plantId);
507:       expect(careHistory).toHaveLength(5);
508: 
509: 
510:       const notes = careHistory.map(
511:         (careRecord: CareRecord) => careRecord.details.notes
512:       );
513:       const uniqueNotes = new Set(notes);
514:       expect(uniqueNotes.size).toBe(5);
515:     });
516:   });
517: });

================
File: src/__tests__/integration/taskGroupingService.test.tsx
================
  1: import { TaskGroupingService } from "@/services/taskGroupingService";
  2: import { UpcomingTask, TaskGroup } from "@/types/scheduling";
  3: 
  4: describe("TaskGroupingService", () => {
  5:   const createMockTask = (
  6:     task: string,
  7:     priority: "low" | "medium" | "high" = "medium"
  8:   ): UpcomingTask => ({
  9:     id: `task-${Date.now()}-${Math.random()}`,
 10:     plantId: "test-plant-1",
 11:     name: "Test Plant",
 12:     task,
 13:     dueIn: "Due in 2 days",
 14:     plantStage: "vegetative",
 15:     dueDate: new Date(),
 16:     priority,
 17:     canBypass: true,
 18:   });
 19: 
 20:   describe("groupTasksByActivity", () => {
 21:     it("groups watering tasks correctly", () => {
 22:       const tasks = [
 23:         createMockTask("Check water level"),
 24:         createMockTask("Water plant"),
 25:         createMockTask("Check moisture"),
 26:       ];
 27: 
 28:       const groups = TaskGroupingService.groupTasksByActivity(tasks);
 29:       const wateringGroup = groups.find((g) => g.type === "watering");
 30: 
 31:       expect(wateringGroup).toBeDefined();
 32:       expect(wateringGroup!.tasks).toHaveLength(3);
 33:       expect(wateringGroup!.title).toBe("Watering");
 34:       expect(wateringGroup!.emoji).toBe("💧");
 35:     });
 36: 
 37:     it("groups fertilizing tasks correctly", () => {
 38:       const tasks = [
 39:         createMockTask("Fertilize plant"),
 40:         createMockTask("Feed with nutrients"),
 41:       ];
 42: 
 43:       const groups = TaskGroupingService.groupTasksByActivity(tasks);
 44:       const fertilizingGroup = groups.find((g) => g.type === "fertilizing");
 45: 
 46:       expect(fertilizingGroup!.tasks).toHaveLength(2);
 47:       expect(fertilizingGroup!.title).toBe("Fertilizing");
 48:       expect(fertilizingGroup!.emoji).toBe("🌱");
 49:     });
 50: 
 51:     it("groups observation tasks correctly", () => {
 52:       const tasks = [
 53:         createMockTask("Health check"),
 54:         createMockTask("Observe growth"),
 55:         createMockTask("Check for pests"),
 56:       ];
 57: 
 58:       const groups = TaskGroupingService.groupTasksByActivity(tasks);
 59:       const observationGroup = groups.find((g) => g.type === "observation");
 60: 
 61:       expect(observationGroup!.tasks).toHaveLength(3);
 62:       expect(observationGroup!.title).toBe("Health Checks");
 63:       expect(observationGroup!.emoji).toBe("👁");
 64:     });
 65: 
 66:     it("groups maintenance tasks correctly", () => {
 67:       const tasks = [
 68:         createMockTask("Prune leaves"),
 69:         createMockTask("Transplant"),
 70:         createMockTask("Clean pot"),
 71:       ];
 72: 
 73:       const groups = TaskGroupingService.groupTasksByActivity(tasks);
 74:       const maintenanceGroup = groups.find((g) => g.type === "maintenance");
 75: 
 76:       expect(maintenanceGroup!.tasks).toHaveLength(3);
 77:       expect(maintenanceGroup!.title).toBe("Maintenance");
 78:       expect(maintenanceGroup!.emoji).toBe("✂️");
 79:       expect(maintenanceGroup!.isExpanded).toBe(false);
 80:     });
 81: 
 82:     it("expands groups with high priority tasks", () => {
 83:       const tasks = [
 84:         createMockTask("Prune leaves", "high"),
 85:         createMockTask("Transplant", "low"),
 86:       ];
 87: 
 88:       const groups = TaskGroupingService.groupTasksByActivity(tasks);
 89:       const maintenanceGroup = groups.find((g) => g.type === "maintenance");
 90: 
 91:       expect(maintenanceGroup!.isExpanded).toBe(true);
 92:     });
 93: 
 94:     it("filters out empty groups", () => {
 95:       const tasks = [createMockTask("Check water level")];
 96: 
 97:       const groups = TaskGroupingService.groupTasksByActivity(tasks);
 98: 
 99:       expect(groups).toHaveLength(1);
100:       expect(groups[0].type).toBe("watering");
101:     });
102: 
103:     it("handles empty task list", () => {
104:       const groups = TaskGroupingService.groupTasksByActivity([]);
105:       expect(groups).toHaveLength(0);
106:     });
107: 
108:     it("handles case insensitive task matching", () => {
109:       const tasks = [
110:         createMockTask("WATER plant"),
111:         createMockTask("fertilize PLANT"),
112:         createMockTask("HEALTH check"),
113:       ];
114: 
115:       const groups = TaskGroupingService.groupTasksByActivity(tasks);
116: 
117:       expect(groups).toHaveLength(3);
118:       expect(groups.find((g) => g.type === "watering")!.tasks).toHaveLength(1);
119:       expect(groups.find((g) => g.type === "fertilizing")!.tasks).toHaveLength(
120:         1
121:       );
122:       expect(groups.find((g) => g.type === "observation")!.tasks).toHaveLength(
123:         1
124:       );
125:     });
126:   });
127: 
128:   describe("shouldExpandGroup", () => {
129:     it("expands group with high priority tasks", () => {
130:       const group: TaskGroup = {
131:         type: "watering",
132:         title: "Watering",
133:         emoji: "💧",
134:         tasks: [createMockTask("Water", "high")],
135:         isExpanded: false,
136:       };
137: 
138:       expect(TaskGroupingService.shouldExpandGroup(group)).toBe(true);
139:     });
140: 
141:     it("expands group with overdue tasks", () => {
142:       const overdueTask = createMockTask("Water");
143:       overdueTask.dueIn = "overdue by 2 days";
144: 
145:       const group: TaskGroup = {
146:         type: "watering",
147:         title: "Watering",
148:         emoji: "💧",
149:         tasks: [overdueTask],
150:         isExpanded: false,
151:       };
152: 
153:       expect(TaskGroupingService.shouldExpandGroup(group)).toBe(true);
154:     });
155: 
156:     it("does not expand group with only low priority tasks", () => {
157:       const group: TaskGroup = {
158:         type: "watering",
159:         title: "Watering",
160:         emoji: "💧",
161:         tasks: [createMockTask("Water", "low")],
162:         isExpanded: false,
163:       };
164: 
165:       expect(TaskGroupingService.shouldExpandGroup(group)).toBe(false);
166:     });
167: 
168:     it("does not expand empty group", () => {
169:       const group: TaskGroup = {
170:         type: "watering",
171:         title: "Watering",
172:         emoji: "💧",
173:         tasks: [],
174:         isExpanded: false,
175:       };
176: 
177:       expect(TaskGroupingService.shouldExpandGroup(group)).toBe(false);
178:     });
179:   });
180: });

================
File: src/__tests__/services/growthStageService.test.ts
================
  1: import { GrowthStageService } from "@/services/growthStageService";
  2: import { plantService, varietyService } from "@/types/database";
  3: import { initializeDatabase } from "@/db/seedData";
  4: import { subDays } from "date-fns";
  5: 
  6: describe("GrowthStageService", () => {
  7:   beforeEach(async () => {
  8:     const { db } = await import("@/types/database");
  9:     await db.plants.clear();
 10:     await db.varieties.clear();
 11:     await initializeDatabase();
 12:   });
 13: 
 14:   it("updates plant stages when they are out of sync", async () => {
 15:     const varieties = await varietyService.getAllVarieties();
 16:     const albion = varieties.find((v) => v.name === "Albion Strawberries");
 17: 
 18: 
 19:     const plantedDate = subDays(new Date(), 103);
 20:     const plantId = await plantService.addPlant({
 21:       varietyId: albion!.id,
 22:       varietyName: albion!.name,
 23:       plantedDate,
 24:       currentStage: "germination",
 25:       location: "Indoor",
 26:       container: "5 gallon",
 27:       isActive: true,
 28:     });
 29: 
 30: 
 31:     let plant = await plantService.getPlant(plantId);
 32:     expect(plant?.currentStage).toBe("germination");
 33: 
 34: 
 35:     await GrowthStageService.updatePlantStages();
 36: 
 37: 
 38:     plant = await plantService.getPlant(plantId);
 39:     expect(plant?.currentStage).toBe("ongoing-production");
 40:   });
 41: 
 42:   it("updates multiple plants with different stage corrections", async () => {
 43:     const varieties = await varietyService.getAllVarieties();
 44:     const albion = varieties.find((v) => v.name === "Albion Strawberries");
 45: 
 46: 
 47:     const plants = [
 48:       { daysAgo: 5, expectedStage: "germination" },
 49:       { daysAgo: 20, expectedStage: "seedling" },
 50:       { daysAgo: 103, expectedStage: "ongoing-production" },
 51:     ];
 52: 
 53:     const plantIds = [];
 54:     for (const plantData of plants) {
 55:       const plantId = await plantService.addPlant({
 56:         varietyId: albion!.id,
 57:         varietyName: albion!.name,
 58:         plantedDate: subDays(new Date(), plantData.daysAgo),
 59:         currentStage: "germination",
 60:         location: "Indoor",
 61:         container: "5 gallon",
 62:         isActive: true,
 63:       });
 64:       plantIds.push({ id: plantId, expected: plantData.expectedStage });
 65:     }
 66: 
 67: 
 68:     await GrowthStageService.updatePlantStages();
 69: 
 70: 
 71:     for (const { id, expected } of plantIds) {
 72:       const plant = await plantService.getPlant(id);
 73:       expect(plant?.currentStage).toBe(expected);
 74:     }
 75:   });
 76: 
 77:   it("handles non-everbearing plants correctly", async () => {
 78:     const varieties = await varietyService.getAllVarieties();
 79:     const carrots = varieties.find((v) => v.name === "Little Finger Carrots");
 80: 
 81: 
 82:     const plantedDate = subDays(new Date(), 70);
 83:     const plantId = await plantService.addPlant({
 84:       varietyId: carrots!.id,
 85:       varietyName: carrots!.name,
 86:       plantedDate,
 87:       currentStage: "germination",
 88:       location: "Indoor",
 89:       container: "4 inch pot",
 90:       isActive: true,
 91:     });
 92: 
 93: 
 94:     await GrowthStageService.updatePlantStages();
 95: 
 96: 
 97:     const plant = await plantService.getPlant(plantId);
 98:     expect(plant?.currentStage).toBe("harvest");
 99:   });
100: 
101:   it("handles plants past productive lifespan", async () => {
102:     const varieties = await varietyService.getAllVarieties();
103:     const albion = varieties.find((v) => v.name === "Albion Strawberries");
104: 
105: 
106:     const plantedDate = subDays(new Date(), 800);
107:     const plantId = await plantService.addPlant({
108:       varietyId: albion!.id,
109:       varietyName: albion!.name,
110:       plantedDate,
111:       currentStage: "ongoing-production",
112:       location: "Indoor",
113:       container: "5 gallon",
114:       isActive: true,
115:     });
116: 
117: 
118:     await GrowthStageService.updatePlantStages();
119: 
120: 
121:     const plant = await plantService.getPlant(plantId);
122:     expect(plant?.currentStage).toBe("harvest");
123:   });
124: });

================
File: src/__tests__/utils/plantDisplay.test.ts
================
 1: import { getPlantDisplayName } from "@/utils/plantDisplay";
 2: import { PlantRecord } from "@/types/database";
 3: 
 4: describe("getPlantDisplayName", () => {
 5:   const basePlant: PlantRecord = {
 6:     id: "test-id",
 7:     varietyId: "some-uuid-123",
 8:     varietyName: "Roma Tomato",
 9:     plantedDate: new Date(),
10:     currentStage: "vegetative",
11:     location: "Indoor",
12:     container: "5 gallon",
13:     isActive: true,
14:     notes: [],
15:     createdAt: new Date(),
16:     updatedAt: new Date(),
17:   };
18: 
19:   it("returns custom name when provided", () => {
20:     const plant = { ...basePlant, name: "My Special Tomato" };
21:     expect(getPlantDisplayName(plant)).toBe("My Special Tomato");
22:   });
23: 
24:   it("returns variety name when no custom name", () => {
25:     const plant = { ...basePlant, name: undefined };
26:     expect(getPlantDisplayName(plant)).toBe("Roma Tomato");
27:   });
28: 
29:   it("returns fallback when no custom name or variety name", () => {
30:     const plant = { ...basePlant, name: undefined, varietyName: "" };
31:     expect(getPlantDisplayName(plant)).toBe("Unknown Plant");
32:   });
33: 
34:   it("returns fallback when varietyName is empty", () => {
35:     const plant = { ...basePlant, name: undefined, varietyName: "" };
36:     expect(getPlantDisplayName(plant)).toBe("Unknown Plant");
37:   });
38: 
39:   it("returns fallback when varietyName is whitespace only", () => {
40:     const plant = { ...basePlant, name: undefined, varietyName: "   " };
41:     expect(getPlantDisplayName(plant)).toBe("Unknown Plant");
42:   });
43: });

================
File: src/__tests__/utils/plantFactory.test.ts
================
  1: import {
  2:   createMockPlant,
  3:   createMockCareRecord,
  4:   createMockVariety,
  5:   createWateringDetails,
  6:   createFertilizingDetails,
  7:   createPlantWithHistory,
  8:   createMultiplePlantsWithTasks,
  9:   createPlantAtStage,
 10:   createMockArugula,
 11: } from "./plantFactory";
 12: 
 13: describe("Plant Factory", () => {
 14:   describe("createMockPlant", () => {
 15:     it("creates a plant with default values", () => {
 16:       const plant = createMockPlant();
 17: 
 18:       expect(plant.id).toMatch(/^plant-/);
 19:       expect(plant.varietyName).toBe("Test Variety");
 20:       expect(plant.currentStage).toBe("vegetative");
 21:       expect(plant.isActive).toBe(true);
 22:       expect(plant.reminderPreferences).toBeDefined();
 23:       expect(plant.createdAt).toBeInstanceOf(Date);
 24:       expect(plant.updatedAt).toBeInstanceOf(Date);
 25:     });
 26: 
 27:     it("accepts overrides", () => {
 28:       const plant = createMockPlant({
 29:         name: "Custom Plant Name",
 30:         currentStage: "flowering",
 31:         isActive: false,
 32:       });
 33: 
 34:       expect(plant.name).toBe("Custom Plant Name");
 35:       expect(plant.currentStage).toBe("flowering");
 36:       expect(plant.isActive).toBe(false);
 37:     });
 38:   });
 39: 
 40:   describe("createMockCareRecord", () => {
 41:     it("creates a watering record by default", () => {
 42:       const plantId = "test-plant-123";
 43:       const careRecord = createMockCareRecord(plantId);
 44: 
 45:       expect(careRecord.plantId).toBe(plantId);
 46:       expect(careRecord.type).toBe("water");
 47:       expect(careRecord.details.type).toBe("water");
 48:       expect(careRecord.id).toMatch(/^care-/);
 49:     });
 50: 
 51:     it("creates different activity types", () => {
 52:       const plantId = "test-plant-123";
 53: 
 54:       const waterRecord = createMockCareRecord(plantId, "water");
 55:       const fertilizeRecord = createMockCareRecord(plantId, "fertilize");
 56:       const observeRecord = createMockCareRecord(plantId, "observe");
 57: 
 58:       expect(waterRecord.type).toBe("water");
 59:       expect(fertilizeRecord.type).toBe("fertilize");
 60:       expect(observeRecord.type).toBe("observe");
 61:     });
 62:   });
 63: 
 64:   describe("createMockVariety", () => {
 65:     it("creates a variety with growth timeline", () => {
 66:       const variety = createMockVariety();
 67: 
 68:       expect(variety.name).toBe("Test Variety");
 69:       expect(variety.category).toBe("leafy-greens");
 70:       expect(variety.growthTimeline.germination).toBe(7);
 71:       expect(variety.growthTimeline.maturation).toBe(45);
 72:       expect(variety.isCustom).toBe(false);
 73:     });
 74:   });
 75: 
 76:   describe("specialized plant factories", () => {
 77:     it("creates arugula with correct defaults", () => {
 78:       const arugula = createMockArugula();
 79: 
 80:       expect(arugula.varietyName).toBe("Arugula");
 81:       expect(arugula.name).toBe("My Arugula");
 82:       expect(arugula.container).toBe("4 inch pot");
 83:     });
 84:   });
 85: 
 86:   describe("utility factories", () => {
 87:     it("creates plant with care history", () => {
 88:       const { plant, careHistory } = createPlantWithHistory({}, 5);
 89: 
 90:       expect(plant).toBeDefined();
 91:       expect(careHistory).toHaveLength(5);
 92:       expect(careHistory.every((record) => record.plantId === plant.id)).toBe(
 93:         true
 94:       );
 95: 
 96: 
 97:       for (let i = 1; i < careHistory.length; i++) {
 98:         expect(careHistory[i - 1].date.getTime()).toBeGreaterThanOrEqual(
 99:           careHistory[i].date.getTime()
100:         );
101:       }
102:     });
103: 
104:     it("creates multiple plants with tasks", () => {
105:       const { plants, tasks } = createMultiplePlantsWithTasks(3);
106: 
107:       expect(plants).toHaveLength(3);
108:       expect(tasks.length).toBeGreaterThanOrEqual(6);
109: 
110: 
111:       const plantIds = plants.map((p) => p.id);
112:       expect(tasks.every((task) => plantIds.includes(task.plantId))).toBe(true);
113:     });
114: 
115:     it("creates plants at specific growth stages", () => {
116:       const germinationPlant = createPlantAtStage("germination");
117:       const vegetativePlant = createPlantAtStage("vegetative");
118: 
119:       expect(germinationPlant.currentStage).toBe("germination");
120:       expect(vegetativePlant.currentStage).toBe("vegetative");
121: 
122: 
123:       expect(vegetativePlant.plantedDate.getTime()).toBeLessThan(
124:         germinationPlant.plantedDate.getTime()
125:       );
126:     });
127:   });
128: 
129:   describe("care detail factories", () => {
130:     it("creates watering details with moisture readings", () => {
131:       const details = createWateringDetails();
132: 
133:       expect(details.type).toBe("water");
134:       expect(details.amount.value).toBe(16);
135:       expect(details.amount.unit).toBe("oz");
136:       expect(details.moistureReading?.before).toBe(3);
137:       expect(details.moistureReading?.after).toBe(7);
138:     });
139: 
140:     it("creates fertilizing details with product info", () => {
141:       const details = createFertilizingDetails();
142: 
143:       expect(details.type).toBe("fertilize");
144:       expect(details.product).toBe("General Purpose 10-10-10");
145:       expect(details.dilution).toBe("1:4");
146:       expect(details.amount).toBe("2 tbsp");
147:     });
148:   });
149: });

================
File: src/__tests__/utils/plantFactory.ts
================
  1: import {
  2:   PlantRecord,
  3:   CareRecord,
  4:   VarietyRecord,
  5:   WateringDetails,
  6:   FertilizingDetails,
  7:   ObservationDetails,
  8:   HarvestDetails,
  9:   TransplantDetails,
 10:   CareActivityDetails,
 11: } from "@/types/database";
 12: import { GrowthStage, CareActivityType } from "@/types/core";
 13: import { UpcomingTask, TaskGroup } from "@/types/scheduling";
 14: 
 15: 
 16: const generateId = (prefix: string = ""): string =>
 17:   `${prefix}${prefix ? "-" : ""}${Date.now()}-${Math.random()
 18:     .toString(36)
 19:     .substring(2, 9)}`;
 20: 
 21: // Core Plant Factory
 22: export const createMockPlant = (
 23:   overrides: Partial<PlantRecord> = {}
 24: ): PlantRecord => {
 25:   const now = new Date();
 26:   const defaultPlantedDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000); // 7 days ago
 27: 
 28:   return {
 29:     id: generateId("plant"),
 30:     varietyId: "default-variety-id",
 31:     varietyName: "Test Variety",
 32:     name: "Test Plant",
 33:     plantedDate: defaultPlantedDate,
 34:     currentStage: "vegetative",
 35:     location: "Indoor",
 36:     container: "5 gallon pot",
 37:     soilMix: "Standard potting mix",
 38:     isActive: true,
 39:     notes: ["Initial planting notes"],
 40:     reminderPreferences: {
 41:       watering: true,
 42:       fertilizing: true,
 43:       observation: true,
 44:       lighting: true,
 45:       pruning: true,
 46:     },
 47:     createdAt: now,
 48:     updatedAt: now,
 49:     ...overrides,
 50:   };
 51: };
 52: 
 53: 
 54: export const createMockVariety = (
 55:   overrides: Partial<VarietyRecord> = {}
 56: ): VarietyRecord => {
 57:   const now = new Date();
 58: 
 59:   return {
 60:     id: generateId("variety"),
 61:     name: "Test Variety",
 62:     category: "leafy-greens",
 63:     growthTimeline: {
 64:       germination: 7,
 65:       seedling: 14,
 66:       vegetative: 21,
 67:       maturation: 45,
 68:     },
 69:     protocols: {
 70:       watering: {
 71:         vegetative: {
 72:           trigger: { moistureLevel: 3 },
 73:           target: { moistureLevel: 7 },
 74:           volume: { amount: "16", frequency: "2-3 days" },
 75:         },
 76:       },
 77:       fertilization: {
 78:         vegetative: {
 79:           products: [
 80:             {
 81:               name: "General Purpose 10-10-10",
 82:               dilution: "1:4",
 83:               amount: "2 tbsp",
 84:               frequency: "bi-weekly",
 85:               method: "soil-drench",
 86:             },
 87:           ],
 88:           timing: "Apply every 2 weeks during vegetative growth",
 89:           notes: ["Apply after watering to prevent root burn"],
 90:         },
 91:       },
 92:     },
 93:     moistureProtocols: {
 94:       vegetative: {
 95:         trigger: { min: 2, max: 4 },
 96:         target: { min: 6, max: 8 },
 97:       },
 98:     },
 99:     isCustom: false,
100:     isEverbearing: false,
101:     createdAt: now,
102:     ...overrides,
103:   };
104: };
105: 
106: 
107: export const createWateringDetails = (
108:   overrides: Partial<WateringDetails> = {}
109: ): WateringDetails => ({
110:   type: "water",
111:   amount: { value: 16, unit: "oz" },
112:   moistureReading: {
113:     before: 3,
114:     after: 7,
115:     scale: "1-10",
116:   },
117:   method: "top-watering",
118:   runoffObserved: false,
119:   notes: "Regular watering",
120:   ...overrides,
121: });
122: 
123: export const createFertilizingDetails = (
124:   overrides: Partial<FertilizingDetails> = {}
125: ): FertilizingDetails => ({
126:   type: "fertilize",
127:   product: "General Purpose 10-10-10",
128:   dilution: "1:4",
129:   amount: "2 tbsp",
130:   method: "soil-drench",
131:   notes: "Bi-weekly fertilizing",
132:   ...overrides,
133: });
134: 
135: export const createObservationDetails = (
136:   overrides: Partial<ObservationDetails> = {}
137: ): ObservationDetails => ({
138:   type: "observe",
139:   healthAssessment: "good",
140:   observations: "Plant looks healthy with good growth",
141:   photos: [],
142:   notes: "Weekly health check",
143:   ...overrides,
144: });
145: 
146: export const createHarvestDetails = (
147:   overrides: Partial<HarvestDetails> = {}
148: ): HarvestDetails => ({
149:   type: "harvest",
150:   amount: "2 cups",
151:   quality: "excellent",
152:   method: "cut and come again",
153:   notes: "First harvest of the season",
154:   ...overrides,
155: });
156: 
157: export const createTransplantDetails = (
158:   overrides: Partial<TransplantDetails> = {}
159: ): TransplantDetails => ({
160:   type: "transplant",
161:   fromContainer: "4 inch pot",
162:   toContainer: "gallon pot",
163:   reason: "Plant outgrew container",
164:   notes: "Transplanted to larger container for better root growth",
165:   ...overrides,
166: });
167: 
168: 
169: export const createMockCareRecord = (
170:   plantId: string,
171:   activityType: CareActivityType = "water",
172:   overrides: Partial<CareRecord> = {}
173: ): CareRecord => {
174:   const now = new Date();
175: 
176:   let details: CareActivityDetails;
177: 
178:   switch (activityType) {
179:     case "water":
180:       details = createWateringDetails();
181:       break;
182:     case "fertilize":
183:       details = createFertilizingDetails();
184:       break;
185:     case "observe":
186:       details = createObservationDetails();
187:       break;
188:     case "harvest":
189:       details = createHarvestDetails();
190:       break;
191:     case "transplant":
192:       details = createTransplantDetails();
193:       break;
194:     default:
195:       details = createWateringDetails();
196:   }
197: 
198:   return {
199:     id: generateId("care"),
200:     plantId,
201:     type: activityType,
202:     date: now,
203:     details,
204:     createdAt: now,
205:     ...overrides,
206:   };
207: };
208: 
209: 
210: export const createMockTask = (
211:   overrides: Partial<UpcomingTask> = {}
212: ): UpcomingTask => ({
213:   id: generateId("task"),
214:   plantId: generateId("plant"),
215:   name: "Test Plant",
216:   task: "Check water level",
217:   dueIn: "Due in 2 days",
218:   plantStage: "vegetative",
219:   dueDate: new Date(),
220:   priority: "medium",
221:   canBypass: true,
222:   ...overrides,
223: });
224: 
225: 
226: export const createMockTaskGroup = (
227:   type: "watering" | "fertilizing" | "observation" | "maintenance" = "watering",
228:   overrides: Partial<TaskGroup> = {}
229: ): TaskGroup => {
230:   const configs = {
231:     watering: { title: "Watering", emoji: "💧" },
232:     fertilizing: { title: "Fertilizing", emoji: "🌱" },
233:     observation: { title: "Health Checks", emoji: "👁" },
234:     maintenance: { title: "Maintenance", emoji: "✂️" },
235:   };
236: 
237:   const config = configs[type];
238: 
239:   return {
240:     type,
241:     title: config.title,
242:     emoji: config.emoji,
243:     tasks: [createMockTask({ task: `${config.title} task` })],
244:     isExpanded: true,
245:     ...overrides,
246:   };
247: };
248: 
249: 
250: export const createMockArugula = (
251:   overrides: Partial<PlantRecord> = {}
252: ): PlantRecord =>
253:   createMockPlant({
254:     varietyName: "Arugula",
255:     name: "My Arugula",
256:     currentStage: "vegetative",
257:     container: "4 inch pot",
258:     ...overrides,
259:   });
260: 
261: export const createMockTomato = (
262:   overrides: Partial<PlantRecord> = {}
263: ): PlantRecord =>
264:   createMockPlant({
265:     varietyName: "Roma Tomato",
266:     name: "Roma Tomato Plant",
267:     currentStage: "flowering",
268:     container: "5 gallon pot",
269:     ...overrides,
270:   });
271: 
272: export const createMockBasil = (
273:   overrides: Partial<PlantRecord> = {}
274: ): PlantRecord =>
275:   createMockPlant({
276:     varietyName: "Genovese Basil",
277:     name: "Kitchen Basil",
278:     currentStage: "vegetative",
279:     container: "6 inch pot",
280:     ...overrides,
281:   });
282: 
283: 
284: export const createFastGrowingVariety = (
285:   overrides: Partial<VarietyRecord> = {}
286: ): VarietyRecord =>
287:   createMockVariety({
288:     name: "Fast Growing Lettuce",
289:     category: "leafy-greens",
290:     growthTimeline: {
291:       germination: 3,
292:       seedling: 7,
293:       vegetative: 14,
294:       maturation: 30,
295:     },
296:     ...overrides,
297:   });
298: 
299: export const createSlowGrowingVariety = (
300:   overrides: Partial<VarietyRecord> = {}
301: ): VarietyRecord =>
302:   createMockVariety({
303:     name: "Slow Growing Kale",
304:     category: "leafy-greens",
305:     growthTimeline: {
306:       germination: 10,
307:       seedling: 21,
308:       vegetative: 45,
309:       maturation: 90,
310:     },
311:     ...overrides,
312:   });
313: 
314: export const createEverbearingVariety = (
315:   overrides: Partial<VarietyRecord> = {}
316: ): VarietyRecord =>
317:   createMockVariety({
318:     name: "Everbearing Strawberry",
319:     category: "berries",
320:     isEverbearing: true,
321:     productiveLifespan: 365,
322:     growthTimeline: {
323:       germination: 14,
324:       seedling: 28,
325:       vegetative: 60,
326:       maturation: 120,
327:     },
328:     ...overrides,
329:   });
330: 
331: 
332: export const createPlantWithHistory = (
333:   plantOverrides: Partial<PlantRecord> = {},
334:   careHistoryCount: number = 3
335: ): { plant: PlantRecord; careHistory: CareRecord[] } => {
336:   const plant = createMockPlant(plantOverrides);
337:   const careHistory: CareRecord[] = [];
338: 
339:   const activities: CareActivityType[] = ["water", "fertilize", "observe"];
340:   const now = new Date();
341: 
342: 
343:   for (let i = 0; i < careHistoryCount; i++) {
344:     const activityType = activities[i % activities.length];
345:     const daysAgo = i;
346:     const date = new Date(now.getTime() - daysAgo * 24 * 60 * 60 * 1000);
347: 
348:     careHistory.push(createMockCareRecord(plant.id, activityType, { date }));
349:   }
350: 
351:   return { plant, careHistory };
352: };
353: 
354: export const createMultiplePlantsWithTasks = (
355:   count: number = 3
356: ): {
357:   plants: PlantRecord[];
358:   tasks: UpcomingTask[];
359: } => {
360:   const plants: PlantRecord[] = [];
361:   const tasks: UpcomingTask[] = [];
362: 
363:   for (let i = 0; i < count; i++) {
364:     const plant = createMockPlant({
365:       name: `Test Plant ${i + 1}`,
366:       varietyName: `Variety ${i + 1}`,
367:     });
368:     plants.push(plant);
369: 
370: 
371:     const taskCount = 2 + (i % 2);
372:     for (let j = 0; j < taskCount; j++) {
373:       tasks.push(
374:         createMockTask({
375:           plantId: plant.id,
376:           name: plant.name || plant.varietyName,
377:           task:
378:             j === 0
379:               ? "Check water level"
380:               : j === 1
381:               ? "Fertilize"
382:               : "Health check",
383:           priority: j === 0 ? "high" : "medium",
384:         })
385:       );
386:     }
387:   }
388: 
389:   return { plants, tasks };
390: };
391: 
392: 
393: export const createPlantAtStage = (
394:   stage: GrowthStage,
395:   varietyTimeline = {
396:     germination: 7,
397:     seedling: 14,
398:     vegetative: 21,
399:     maturation: 45,
400:   },
401:   overrides: Partial<PlantRecord> = {}
402: ): PlantRecord => {
403:   const now = new Date();
404:   let daysAgo: number;
405: 
406:   switch (stage) {
407:     case "germination":
408:       daysAgo = 3;
409:       break;
410:     case "seedling":
411:       daysAgo = varietyTimeline.germination + 3;
412:       break;
413:     case "vegetative":
414:       daysAgo = varietyTimeline.germination + varietyTimeline.seedling + 5;
415:       break;
416:     case "maturation":
417:       daysAgo =
418:         varietyTimeline.germination +
419:         varietyTimeline.seedling +
420:         varietyTimeline.vegetative +
421:         5;
422:       break;
423:     default:
424:       daysAgo = 7;
425:   }
426: 
427:   const plantedDate = new Date(now.getTime() - daysAgo * 24 * 60 * 60 * 1000);
428: 
429:   return createMockPlant({
430:     plantedDate,
431:     currentStage: stage,
432:     ...overrides,
433:   });
434: };

================
File: src/__tests__/utils/testHelpers.tsx
================
 1: import { render } from "@testing-library/react";
 2: import { BrowserRouter } from "react-router-dom";
 3: import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
 4: 
 5: export const renderWithProviders = (
 6:   ui: React.ReactElement,
 7:   options?: { initialEntries?: string[] }
 8: ) => {
 9:   const queryClient = new QueryClient({
10:     defaultOptions: {
11:       queries: { retry: false },
12:       mutations: { retry: false },
13:     },
14:   });
15: 
16:   const Wrapper = ({ children }: { children: React.ReactNode }) => (
17:     <QueryClientProvider client={queryClient}>
18:       <BrowserRouter>{children}</BrowserRouter>
19:     </QueryClientProvider>
20:   );
21: 
22:   return render(ui, { wrapper: Wrapper, ...options });
23: };
24: 
25: 
26: export const mockPlantData = [
27:   {
28:     id: "test-plant-1",
29:     varietyId: "test-variety-1",
30:     varietyName: "Test Variety",
31:     name: "Test Plant",
32:     plantedDate: new Date("2024-01-01"),
33:     currentStage: "vegetative" as const,
34:     location: "Indoor",
35:     container: "5 gallon pot",
36:     isActive: true,
37:     notes: [],
38:     createdAt: new Date(),
39:     updatedAt: new Date(),
40:   },
41: ];
42: 
43: 
44: export const mockTaskData = [
45:   {
46:     id: "task-1",
47:     plantId: "test-plant-1",
48:     name: "Test Plant",
49:     task: "Check water level",
50:     dueIn: "overdue by 1 day",
51:     activityType: "water" as const,
52:     dueDate: new Date(),
53:     priority: "high" as const,
54:     description: "Water the plant",
55:     canBypass: true,
56:   },
57: ];
58: 
59: 
60: describe("Test Helpers", () => {
61:   it("should export helper functions", () => {
62:     expect(renderWithProviders).toBeDefined();
63:     expect(mockPlantData).toBeDefined();
64:     expect(mockTaskData).toBeDefined();
65:   });
66: });

================
File: src/__tests__/utils/varietyGrowthStages.test.ts
================
  1: import {
  2:   calculateCurrentStage,
  3:   getStageProgress,
  4: } from "../../utils/growthStage";
  5: import { restoreDate } from "../../setupTests";
  6: 
  7: describe("Variety-Specific Growth Stage Calculations", () => {
  8:   beforeEach(() => {
  9:     restoreDate();
 10:   });
 11: 
 12:   describe("Fast-Growing Crops (21-45 days)", () => {
 13:     const arugulaTimeline = {
 14:       germination: 5,
 15:       seedling: 14,
 16:       vegetative: 14,
 17:       maturation: 37,
 18:     };
 19: 
 20:     it("calculates arugula stages correctly", () => {
 21:       const plantedDate = new Date("2024-01-01");
 22: 
 23: 
 24:       expect(
 25:         calculateCurrentStage(
 26:           plantedDate,
 27:           arugulaTimeline,
 28:           new Date("2024-01-03")
 29:         )
 30:       ).toBe("germination");
 31: 
 32: 
 33:       expect(
 34:         calculateCurrentStage(
 35:           plantedDate,
 36:           arugulaTimeline,
 37:           new Date("2024-01-10")
 38:         )
 39:       ).toBe("seedling");
 40: 
 41: 
 42:       expect(
 43:         calculateCurrentStage(
 44:           plantedDate,
 45:           arugulaTimeline,
 46:           new Date("2024-01-25")
 47:         )
 48:       ).toBe("vegetative");
 49: 
 50: 
 51:       expect(
 52:         calculateCurrentStage(
 53:           plantedDate,
 54:           arugulaTimeline,
 55:           new Date("2024-02-10")
 56:         )
 57:       ).toBe("harvest");
 58:     });
 59: 
 60:     const spinachTimeline = {
 61:       germination: 7,
 62:       seedling: 14,
 63:       vegetative: 9,
 64:       maturation: 30,
 65:     };
 66: 
 67:     it("calculates spinach stages correctly", () => {
 68:       const plantedDate = new Date("2024-01-01");
 69: 
 70: 
 71: 
 72:       expect(
 73:         calculateCurrentStage(
 74:           plantedDate,
 75:           spinachTimeline,
 76:           new Date("2024-01-31")
 77:         )
 78:       ).toBe("harvest");
 79: 
 80:       expect(
 81:         calculateCurrentStage(
 82:           plantedDate,
 83:           spinachTimeline,
 84:           new Date("2024-01-20")
 85:         )
 86:       ).toBe("seedling");
 87:     });
 88:   });
 89: 
 90:   describe("Medium Crops (45-70 days)", () => {
 91:     const lettuceTimeline = {
 92:       germination: 7,
 93:       seedling: 18,
 94:       vegetative: 21,
 95:       maturation: 55,
 96:     };
 97: 
 98:     it("calculates lettuce stages correctly", () => {
 99:       const plantedDate = new Date("2024-01-01");
100: 
101: 
102:       expect(
103:         calculateCurrentStage(
104:           plantedDate,
105:           lettuceTimeline,
106:           new Date("2024-02-20")
107:         )
108:       ).toBe("flowering");
109:       expect(
110:         calculateCurrentStage(
111:           plantedDate,
112:           lettuceTimeline,
113:           new Date("2024-02-25")
114:         )
115:       ).toBe("harvest");
116:     });
117: 
118:     const beetTimeline = {
119:       germination: 7,
120:       seedling: 14,
121:       vegetative: 21,
122:       maturation: 60,
123:     };
124: 
125:     it("calculates beet stages correctly", () => {
126:       const plantedDate = new Date("2024-01-01");
127: 
128: 
129:       expect(
130:         calculateCurrentStage(plantedDate, beetTimeline, new Date("2024-03-01"))
131:       ).toBe("harvest");
132:     });
133: 
134:     const carrotTimeline = {
135:       germination: 14,
136:       seedling: 14,
137:       vegetative: 14,
138:       maturation: 70,
139:     };
140: 
141:     it("calculates carrot stages correctly with strict photoperiod needs", () => {
142:       const plantedDate = new Date("2024-01-01");
143: 
144: 
145:       expect(
146:         calculateCurrentStage(
147:           plantedDate,
148:           carrotTimeline,
149:           new Date("2024-01-10")
150:         )
151:       ).toBe("germination");
152:       expect(
153:         calculateCurrentStage(
154:           plantedDate,
155:           carrotTimeline,
156:           new Date("2024-01-15")
157:         )
158:       ).toBe("seedling");
159: 
160: 
161:       expect(
162:         calculateCurrentStage(
163:           plantedDate,
164:           carrotTimeline,
165:           new Date("2024-03-11")
166:         )
167:       ).toBe("harvest");
168:     });
169:   });
170: 
171:   describe("Long Crops (90+ days)", () => {
172:     const sweetPotatoTimeline = {
173:       germination: 14,
174:       seedling: 21,
175:       vegetative: 42,
176:       maturation: 100,
177:     };
178: 
179:     it("calculates sweet potato stages correctly", () => {
180:       const plantedDate = new Date("2024-01-01");
181: 
182: 
183:       expect(
184:         calculateCurrentStage(
185:           plantedDate,
186:           sweetPotatoTimeline,
187:           new Date("2024-01-10")
188:         )
189:       ).toBe("germination");
190: 
191: 
192:       expect(
193:         calculateCurrentStage(
194:           plantedDate,
195:           sweetPotatoTimeline,
196:           new Date("2024-01-25")
197:         )
198:       ).toBe("seedling");
199: 
200: 
201:       expect(
202:         calculateCurrentStage(
203:           plantedDate,
204:           sweetPotatoTimeline,
205:           new Date("2024-02-20")
206:         )
207:       ).toBe("vegetative");
208: 
209: 
210:       expect(
211:         calculateCurrentStage(
212:           plantedDate,
213:           sweetPotatoTimeline,
214:           new Date("2024-04-15")
215:         )
216:       ).toBe("harvest");
217:     });
218: 
219:     const broccoliTimeline = {
220:       germination: 7,
221:       seedling: 17,
222:       vegetative: 30,
223:       maturation: 90,
224:     };
225: 
226:     it("calculates broccoli stages correctly", () => {
227:       const plantedDate = new Date("2024-01-01");
228: 
229: 
230:       expect(
231:         calculateCurrentStage(
232:           plantedDate,
233:           broccoliTimeline,
234:           new Date("2024-04-01")
235:         )
236:       ).toBe("harvest");
237:       expect(
238:         calculateCurrentStage(
239:           plantedDate,
240:           broccoliTimeline,
241:           new Date("2024-03-15")
242:         )
243:       ).toBe("flowering");
244:     });
245: 
246:     const onionTimeline = {
247:       germination: 14,
248:       seedling: 28,
249:       vegetative: 42,
250:       maturation: 120,
251:     };
252: 
253:     it("calculates onion bulbing stages correctly", () => {
254:       const plantedDate = new Date("2024-01-01");
255: 
256: 
257:       expect(
258:         calculateCurrentStage(
259:           plantedDate,
260:           onionTimeline,
261:           new Date("2024-03-01")
262:         )
263:       ).toBe("vegetative");
264: 
265: 
266:       expect(
267:         calculateCurrentStage(
268:           plantedDate,
269:           onionTimeline,
270:           new Date("2024-05-01")
271:         )
272:       ).toBe("harvest");
273:     });
274:   });
275: 
276:   describe("Continuous Production Crops", () => {
277:     const strawberryTimeline = {
278:       germination: 21,
279:       seedling: 21,
280:       vegetative: 14,
281:       maturation: 91,
282:     };
283: 
284:     it("calculates strawberry production stages correctly", () => {
285:       const plantedDate = new Date("2024-01-01");
286: 
287: 
288:       expect(
289:         calculateCurrentStage(
290:           plantedDate,
291:           strawberryTimeline,
292:           new Date("2024-04-16")
293:         )
294:       ).toBe("harvest");
295: 
296: 
297:       expect(
298:         calculateCurrentStage(
299:           plantedDate,
300:           strawberryTimeline,
301:           new Date("2024-01-15")
302:         )
303:       ).toBe("germination");
304: 
305: 
306:       expect(
307:         calculateCurrentStage(
308:           plantedDate,
309:           strawberryTimeline,
310:           new Date("2024-02-05")
311:         )
312:       ).toBe("seedling");
313: 
314: 
315:       expect(
316:         calculateCurrentStage(
317:           plantedDate,
318:           strawberryTimeline,
319:           new Date("2024-02-20")
320:         )
321:       ).toBe("vegetative");
322: 
323: 
324:       expect(
325:         calculateCurrentStage(
326:           plantedDate,
327:           strawberryTimeline,
328:           new Date("2024-03-15")
329:         )
330:       ).toBe("flowering");
331: 
332: 
333:       expect(
334:         calculateCurrentStage(
335:           plantedDate,
336:           strawberryTimeline,
337:           new Date("2024-04-01")
338:         )
339:       ).toBe("harvest");
340:     });
341:   });
342: 
343:   describe("Stage Progress Calculations", () => {
344:     it("calculates progress correctly within stages", () => {
345:       const plantedDate = new Date("2024-01-01");
346:       const lettuceTimeline = {
347:         germination: 7,
348:         seedling: 18,
349:         vegetative: 21,
350:         maturation: 55,
351:       };
352: 
353: 
354:       const midSeedlingProgress = getStageProgress(
355:         plantedDate,
356:         lettuceTimeline,
357:         new Date("2024-01-16")
358:       );
359:       expect(midSeedlingProgress).toBeCloseTo(44, 0);
360: 
361: 
362:       const earlyGerminationProgress = getStageProgress(
363:         plantedDate,
364:         lettuceTimeline,
365:         new Date("2024-01-04")
366:       );
367:       expect(earlyGerminationProgress).toBeCloseTo(43, 0);
368: 
369: 
370:       const earlyVegetativeProgress = getStageProgress(
371:         plantedDate,
372:         lettuceTimeline,
373:         new Date("2024-01-30")
374:       );
375:       expect(earlyVegetativeProgress).toBeCloseTo(19, 0);
376:     });
377: 
378:     it("returns 100% for completed crops", () => {
379:       const plantedDate = new Date("2024-01-01");
380:       const arugulaTimeline = {
381:         germination: 5,
382:         seedling: 14,
383:         vegetative: 14,
384:         maturation: 37,
385:       };
386: 
387:       const progress = getStageProgress(
388:         plantedDate,
389:         arugulaTimeline,
390:         new Date("2024-03-01")
391:       );
392:       expect(progress).toBe(100);
393:     });
394:   });
395: 
396:   describe("Edge Cases", () => {
397:     it("handles future planting dates gracefully", () => {
398:       const plantedDate = new Date("2024-12-31");
399:       const currentDate = new Date("2024-01-01");
400:       const arugulaTimeline = {
401:         germination: 5,
402:         seedling: 14,
403:         vegetative: 14,
404:         maturation: 37,
405:       };
406: 
407:       expect(
408:         calculateCurrentStage(plantedDate, arugulaTimeline, currentDate)
409:       ).toBe("germination");
410:     });
411: 
412:     it("handles same-day calculations", () => {
413:       const plantedDate = new Date("2024-01-01");
414:       const currentDate = new Date("2024-01-01");
415:       const spinachTimeline = {
416:         germination: 7,
417:         seedling: 14,
418:         vegetative: 14,
419:         maturation: 30,
420:       };
421: 
422:       expect(
423:         calculateCurrentStage(plantedDate, spinachTimeline, currentDate)
424:       ).toBe("germination");
425:     });
426:   });
427: });

================
File: src/assets/react.svg
================
1: <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: src/components/ui/LoadingSpinner.tsx
================
 1: import React from "react";
 2: import { cn } from "@/utils/cn";
 3: 
 4: interface LoadingSpinnerProps {
 5:   size?: "sm" | "md" | "lg";
 6:   className?: string;
 7: }
 8: 
 9: export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
10:   size = "md",
11:   className,
12: }) => {
13:   const sizeClasses = {
14:     sm: "w-4 h-4",
15:     md: "w-6 h-6",
16:     lg: "w-8 h-8",
17:   };
18: 
19:   return (
20:     <div className={cn("flex items-center justify-center", className)}>
21:       <div
22:         className={cn(
23:           "animate-spin rounded-full border-2 border-garden-200 border-t-garden-600",
24:           sizeClasses[size]
25:         )}
26:       />
27:     </div>
28:   );
29: };

================
File: src/components/ui/OfflineIndicator.tsx
================
 1: import React, { useState, useEffect } from "react";
 2: 
 3: export const OfflineIndicator: React.FC = () => {
 4:   const [isOnline, setIsOnline] = useState(navigator.onLine);
 5: 
 6:   useEffect(() => {
 7:     function handleOnline() {
 8:       setIsOnline(true);
 9:     }
10: 
11:     function handleOffline() {
12:       setIsOnline(false);
13:     }
14: 
15:     window.addEventListener("online", handleOnline);
16:     window.addEventListener("offline", handleOffline);
17: 
18:     return () => {
19:       window.removeEventListener("online", handleOnline);
20:       window.removeEventListener("offline", handleOffline);
21:     };
22:   }, []);
23: 
24:   if (isOnline) return null;
25: 
26:   return (
27:     <div className="fixed top-0 left-0 right-0 bg-red-600 text-white px-4 py-2 text-center text-sm font-medium z-50">
28:       📡 You're offline - Data will sync when connection returns
29:     </div>
30:   );
31: };

================
File: src/components/ui/StatusBadge.tsx
================
 1: import React from "react";
 2: import { cn } from "@/utils/cn";
 3: 
 4: interface StatusBadgeProps {
 5:   status: "healthy" | "attention" | "critical" | "new";
 6:   size?: "sm" | "md";
 7: }
 8: 
 9: export const StatusBadge: React.FC<StatusBadgeProps> = ({
10:   status,
11:   size = "md",
12: }) => {
13:   const baseClasses = "inline-flex items-center font-medium rounded-full";
14: 
15:   const sizeClasses = {
16:     sm: "px-2 py-0.5 text-xs",
17:     md: "px-2.5 py-1 text-sm",
18:   };
19: 
20:   const statusClasses = {
21:     healthy: "bg-green-100 text-green-800",
22:     attention: "bg-yellow-100 text-yellow-800",
23:     critical: "bg-red-100 text-red-800",
24:     new: "bg-blue-100 text-blue-800",
25:   };
26: 
27:   const statusIcons = {
28:     healthy: "✅",
29:     attention: "⚠️",
30:     critical: "🚨",
31:     new: "🌱",
32:   };
33: 
34:   return (
35:     <span className={cn(baseClasses, sizeClasses[size], statusClasses[status])}>
36:       <span className="mr-1">{statusIcons[status]}</span>
37:       {status}
38:     </span>
39:   );
40: };

================
File: src/db/schema.ts
================
 1: import Dexie, { Table } from "dexie";
 2: import {
 3:   PlantInstance,
 4:   PlantVariety,
 5:   CareActivity,
 6:   UserSettings,
 7: } from "../types";
 8: 
 9: export interface Database extends Dexie {
10:   plantVarieties: Table<PlantVariety>;
11:   plantInstances: Table<PlantInstance>;
12:   careActivities: Table<CareActivity>;
13:   userSettings: Table<UserSettings>;
14:   syncQueue: Table<SyncQueueItem>;
15: }
16: 
17: 
18: export type SyncQueueItem =
19:   | {
20:       id?: number;
21:       entity: "plantInstance";
22:       action: "create" | "update" | "delete";
23:       data: Partial<PlantInstance>;
24:       timestamp: Date;
25:       synced: boolean;
26:     }
27:   | {
28:       id?: number;
29:       entity: "careActivity";
30:       action: "create" | "update" | "delete";
31:       data: Partial<CareActivity>;
32:       timestamp: Date;
33:       synced: boolean;
34:     }
35:   | {
36:       id?: number;
37:       entity: "plantVariety";
38:       action: "create" | "update" | "delete";
39:       data: Partial<PlantVariety>;
40:       timestamp: Date;
41:       synced: boolean;
42:     }
43:   | {
44:       id?: number;
45:       entity: "userSettings";
46:       action: "create" | "update" | "delete";
47:       data: Partial<UserSettings>;
48:       timestamp: Date;
49:       synced: boolean;
50:     };
51: 
52: export const db = new Dexie("SmartGardenDB") as Database;
53: 
54: db.version(1).stores({
55:   plantVarieties: "++id, name, category",
56:   plantInstances: "++id, varietyId, plantedDate, currentStage, isActive",
57:   careActivities: "++id, plantId, type, date",
58:   userSettings: "++id",
59:   syncQueue: "++id, entity, synced, timestamp",
60: });
61: 
62: 
63: 
64: export const syncQueueHelpers = {
65: 
66:   async addToSyncQueue<T extends SyncQueueItem>(
67:     item: Omit<T, "id" | "timestamp" | "synced">
68:   ): Promise<number> {
69:     const syncItem: Omit<SyncQueueItem, "id"> = {
70:       ...item,
71:       timestamp: new Date(),
72:       synced: false,
73:     };
74:     return await db.syncQueue.add(syncItem as SyncQueueItem);
75:   },
76: 
77: 
78:   async getUnsyncedItems(
79:     entity?: SyncQueueItem["entity"]
80:   ): Promise<SyncQueueItem[]> {
81:     if (entity) {
82:       return await db.syncQueue
83:         .where("entity")
84:         .equals(entity)
85:         .and((item) => !item.synced)
86:         .toArray();
87:     }
88:     return await db.syncQueue.where("synced").equals(0).toArray();
89:   },
90: 
91: 
92:   async markAsSynced(ids: number[]): Promise<void> {
93:     await db.syncQueue.where("id").anyOf(ids).modify({ synced: true });
94:   },
95: };

================
File: src/hooks/useAppInitialization.ts
================
 1: import { useEffect } from "react";
 2: import { GrowthStageService } from "@/services/growthStageService";
 3: 
 4: export function useAppInitialization() {
 5:   useEffect(() => {
 6:     const initializeApp = async () => {
 7:       try {
 8: 
 9:         await GrowthStageService.updatePlantStages();
10:       } catch (error) {
11:         console.error("Error during app initialization:", error);
12:       }
13:     };
14: 
15:     initializeApp();
16:   }, []);
17: }

================
File: src/hooks/useDarkMode.ts
================
 1: import { useState, useEffect } from "react";
 2: 
 3: export const useDarkMode = () => {
 4:   const [isDarkMode, setIsDarkMode] = useState(() => {
 5: 
 6:     const saved = localStorage.getItem("darkMode");
 7:     if (saved !== null) {
 8:       return JSON.parse(saved);
 9:     }
10: 
11: 
12:     return window.matchMedia("(prefers-color-scheme: dark)").matches;
13:   });
14: 
15:   useEffect(() => {
16: 
17:     if (isDarkMode) {
18:       document.documentElement.classList.add("dark");
19:     } else {
20:       document.documentElement.classList.remove("dark");
21:     }
22: 
23: 
24:     localStorage.setItem("darkMode", JSON.stringify(isDarkMode));
25:   }, [isDarkMode]);
26: 
27: 
28:   useEffect(() => {
29:     const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
30:     const handleChange = (e: MediaQueryListEvent) => {
31: 
32:       const saved = localStorage.getItem("darkMode");
33:       if (saved === null) {
34:         setIsDarkMode(e.matches);
35:       }
36:     };
37: 
38:     mediaQuery.addEventListener("change", handleChange);
39:     return () => mediaQuery.removeEventListener("change", handleChange);
40:   }, []);
41: 
42:   return { isDarkMode, toggleDarkMode: () => setIsDarkMode(!isDarkMode) };
43: };

================
File: src/hooks/useFirstTimeUser.ts
================
 1: import { useState, useEffect } from "react";
 2: import { plantService } from "@/types/database";
 3: 
 4: export const useFirstTimeUser = () => {
 5:   const [isFirstTime, setIsFirstTime] = useState<boolean | null>(null);
 6:   const [isLoading, setIsLoading] = useState(true);
 7: 
 8:   useEffect(() => {
 9:     const checkFirstTimeUser = async () => {
10:       try {
11: 
12:         const plants = await plantService.getActivePlants();
13: 
14: 
15:         const hasCompletedOnboarding = localStorage.getItem(
16:           "smartgarden_onboarding_completed"
17:         );
18: 
19:         setIsFirstTime(plants.length === 0 && !hasCompletedOnboarding);
20:       } catch (error) {
21:         console.error("Error checking first time user:", error);
22:         setIsFirstTime(false);
23:       } finally {
24:         setIsLoading(false);
25:       }
26:     };
27: 
28:     checkFirstTimeUser();
29:   }, []);
30: 
31:   const markOnboardingComplete = () => {
32:     localStorage.setItem("smartgarden_onboarding_completed", "true");
33:     setIsFirstTime(false);
34:   };
35: 
36:   return {
37:     isFirstTime,
38:     isLoading,
39:     markOnboardingComplete,
40:   };
41: };

================
File: src/hooks/useNextPlantTask.ts
================
 1: import { useState, useEffect } from "react";
 2: import { CareSchedulingService } from "@/services/careSchedulingService";
 3: import { UpcomingTask } from "@/types/scheduling";
 4: 
 5: export const useNextPlantTask = (plantId: string) => {
 6:   const [nextTask, setNextTask] = useState<UpcomingTask | null>(null);
 7:   const [isLoading, setIsLoading] = useState(true);
 8: 
 9:   useEffect(() => {
10:     let mounted = true;
11: 
12:     const loadNextTask = async () => {
13:       try {
14:         setIsLoading(true);
15:         const task = await CareSchedulingService.getNextTaskForPlant(plantId);
16:         if (mounted) {
17:           setNextTask(task);
18:         }
19:       } catch (error) {
20:         console.error(`Failed to load next task for plant ${plantId}:`, error);
21:         if (mounted) {
22:           setNextTask(null);
23:         }
24:       } finally {
25:         if (mounted) {
26:           setIsLoading(false);
27:         }
28:       }
29:     };
30: 
31:     loadNextTask();
32: 
33:     return () => {
34:       mounted = false;
35:     };
36:   }, [plantId]);
37: 
38:   return { nextTask, isLoading };
39: };

================
File: src/pages/dashboard/TaskGroup.tsx
================
 1: import React, { useState } from "react";
 2: import { Card, CardContent, CardHeader } from "@/components/ui/Card";
 3: import {
 4:   QuickCompletionValues,
 5:   TaskGroup as TaskGroupType,
 6: } from "@/types/scheduling";
 7: import TaskItem from "./TaskItem";
 8: 
 9: interface TaskGroupProps {
10:   group: TaskGroupType;
11:   onQuickComplete?: (
12:     taskId: string,
13:     values: QuickCompletionValues
14:   ) => Promise<void>;
15:   onBypass?: (taskId: string, reason: string) => Promise<void>;
16:   onToggleExpanded?: (groupType: string) => void;
17: }
18: 
19: const TaskGroup: React.FC<TaskGroupProps> = ({
20:   group,
21:   onQuickComplete,
22:   onBypass,
23:   onToggleExpanded,
24: }) => {
25:   const [isExpanded, setIsExpanded] = useState(group.isExpanded);
26: 
27:   const handleToggle = () => {
28:     const newExpanded = !isExpanded;
29:     setIsExpanded(newExpanded);
30:     onToggleExpanded?.(group.type);
31:   };
32: 
33:   const urgentTaskCount = group.tasks.filter(
34:     (task) => task.priority === "high" || task.dueIn.includes("overdue")
35:   ).length;
36: 
37:   return (
38:     <Card className="w-full">
39:       <CardHeader className="cursor-pointer hover:bg-muted/50 transition-colors">
40:         <div
41:           className="flex items-center justify-between"
42:           onClick={handleToggle}
43:         >
44:           {}
45:           <div className="flex items-center gap-3">
46:             <span className="text-2xl">{group.emoji}</span>
47:             <div>
48:               <h3 className="text-lg font-semibold">{group.title}</h3>
49:               <p className="text-sm text-muted-foreground">
50:                 {group.tasks.length} task{group.tasks.length !== 1 ? "s" : ""}
51:                 {urgentTaskCount > 0 && (
52:                   <span className="ml-2 px-2 py-0.5 bg-red-100 text-red-700 rounded-full text-xs font-medium">
53:                     {urgentTaskCount} urgent
54:                   </span>
55:                 )}
56:               </p>
57:             </div>
58:           </div>
59: 
60:           <div className="flex items-center gap-2">
61:             <svg
62:               className={`w-5 h-5 transition-transform ${
63:                 isExpanded ? "rotate-180" : ""
64:               }`}
65:               fill="none"
66:               stroke="currentColor"
67:               viewBox="0 0 24 24"
68:             >
69:               <path
70:                 strokeLinecap="round"
71:                 strokeLinejoin="round"
72:                 strokeWidth={2}
73:                 d="M19 9l-7 7-7-7"
74:               />
75:             </svg>
76:           </div>
77:         </div>
78:       </CardHeader>
79: 
80:       {isExpanded && (
81:         <CardContent className="pt-0">
82:           <div className="space-y-3">
83:             {group.tasks.map((task) => (
84:               <TaskItem
85:                 key={task.id}
86:                 task={task}
87:                 onQuickComplete={onQuickComplete}
88:                 onBypass={onBypass}
89:               />
90:             ))}
91:           </div>
92:         </CardContent>
93:       )}
94:     </Card>
95:   );
96: };
97: 
98: export default TaskGroup;

================
File: src/services/sync/syncService.ts
================
  1: import { db, SyncQueueRecord } from "@/types/database";
  2: 
  3: interface SyncConfig {
  4:   apiBaseUrl: string;
  5:   timeout: number;
  6:   maxRetries: number;
  7: }
  8: 
  9: export class SyncService {
 10:   private static config: SyncConfig = {
 11:     apiBaseUrl: process.env.NEXT_PUBLIC_API_URL || "/api",
 12:     timeout: 10000,
 13:     maxRetries: 3,
 14:   };
 15: 
 16:   static async syncWhenOnline(): Promise<void> {
 17:     if (!navigator.onLine) {
 18:       console.log("Offline - skipping sync");
 19:       return;
 20:     }
 21: 
 22:     try {
 23:       const unsyncedItems = await db.syncQueue
 24:         .filter((item) => !item.synced)
 25:         .toArray();
 26: 
 27:       if (unsyncedItems.length === 0) {
 28:         console.log("No items to sync");
 29:         return;
 30:       }
 31: 
 32:       console.log(`Syncing ${unsyncedItems.length} items...`);
 33: 
 34:       for (const item of unsyncedItems) {
 35:         try {
 36:           await this.syncItem(item);
 37:           await db.syncQueue.update(item.id, { synced: true });
 38:           console.log(
 39:             `Synced ${item.table} ${item.operation} for ${item.recordId}`
 40:           );
 41:         } catch (error) {
 42:           console.warn(`Sync failed for item ${item.id}:`, error);
 43: 
 44: 
 45:           const retryCount = (item.retryCount || 0) + 1;
 46: 
 47:           if (retryCount >= this.config.maxRetries) {
 48:             console.error(`Max retries exceeded for item ${item.id}`);
 49: 
 50:             await db.syncQueue.update(item.id, {
 51:               retryCount,
 52: 
 53:             });
 54:           } else {
 55:             await db.syncQueue.update(item.id, { retryCount });
 56:           }
 57:         }
 58:       }
 59:     } catch (error) {
 60:       console.error("Sync process failed:", error);
 61:     }
 62:   }
 63: 
 64:   private static async syncItem(item: SyncQueueRecord): Promise<void> {
 65:     const { table, operation, recordId, data } = item;
 66: 
 67:     let endpoint = `${this.config.apiBaseUrl}/${table}`;
 68:     let method = "GET";
 69:     let body: string | undefined;
 70: 
 71: 
 72:     switch (operation) {
 73:       case "create":
 74:         method = "POST";
 75:         body = data;
 76:         break;
 77: 
 78:       case "update":
 79:         method = "PUT";
 80:         endpoint = `${endpoint}/${recordId}`;
 81:         body = data;
 82:         break;
 83: 
 84:       case "delete":
 85:         method = "DELETE";
 86:         endpoint = `${endpoint}/${recordId}`;
 87:         break;
 88: 
 89:       default:
 90:         throw new Error(`Unknown operation: ${operation}`);
 91:     }
 92: 
 93: 
 94:     const response = await fetch(endpoint, {
 95:       method,
 96:       headers: {
 97:         "Content-Type": "application/json",
 98: 
 99: 
100:       },
101:       body,
102:       signal: AbortSignal.timeout(this.config.timeout),
103:     });
104: 
105:     if (!response.ok) {
106:       const errorText = await response.text();
107:       throw new Error(
108:         `HTTP ${response.status}: ${errorText || response.statusText}`
109:       );
110:     }
111: 
112: 
113:     if (operation === "create" && response.ok) {
114:       const responseData = await response.json();
115: 
116:       console.log("Create response:", responseData);
117:     }
118:   }
119: 
120: 
121:   static async forcSync(): Promise<boolean> {
122:     try {
123:       await this.syncWhenOnline();
124:       return true;
125:     } catch (error) {
126:       console.error("Force sync failed:", error);
127:       return false;
128:     }
129:   }
130: 
131: 
132:   static async getSyncStatus(): Promise<{
133:     pendingCount: number;
134:     failedCount: number;
135:     lastSyncAttempt?: Date;
136:   }> {
137:     const allItems = await db.syncQueue.toArray();
138:     const pending = allItems.filter((item) => !item.synced);
139:     const failed = allItems.filter(
140:       (item) => (item.retryCount || 0) >= this.config.maxRetries
141:     );
142: 
143:     return {
144:       pendingCount: pending.length,
145:       failedCount: failed.length,
146:       lastSyncAttempt:
147:         pending.length > 0
148:           ? new Date(
149:               Math.max(...pending.map((item) => item.timestamp.getTime()))
150:             )
151:           : undefined,
152:     };
153:   }
154: 
155: 
156:   static async cleanupSyncQueue(): Promise<void> {
157:     const cutoffDate = new Date();
158:     cutoffDate.setDate(cutoffDate.getDate() - 7);
159: 
160:     await db.syncQueue
161:       .filter((item) => item.synced)
162:       .and((item) => item.timestamp < cutoffDate)
163:       .delete();
164:   }
165: 
166: 
167:   static async retryFailedItems(): Promise<void> {
168: 
169:     const failedItems = await db.syncQueue
170:       .filter((item) => (item.retryCount || 0) >= this.config.maxRetries)
171:       .toArray();
172: 
173:     for (const item of failedItems) {
174:       await db.syncQueue.update(item.id, { retryCount: 0 });
175:     }
176: 
177:     await this.syncWhenOnline();
178:   }
179: 
180: 
181:   static configure(config: Partial<SyncConfig>): void {
182:     this.config = { ...this.config, ...config };
183:   }
184: 
185: 
186:   static setupSyncListeners(): void {
187: 
188:     window.addEventListener("online", () => {
189:       console.log("Device back online - starting sync");
190:       this.syncWhenOnline();
191:     });
192: 
193: 
194:     setInterval(() => {
195:       if (navigator.onLine) {
196:         this.syncWhenOnline();
197:       }
198:     }, 5 * 60 * 1000);
199:   }
200: 
201: 
202:   static initialize(config?: Partial<SyncConfig>): void {
203:     if (config) {
204:       this.configure(config);
205:     }
206: 
207:     this.setupSyncListeners();
208: 
209: 
210:     if (navigator.onLine) {
211:       this.syncWhenOnline();
212:     }
213:   }
214: }
215: 
216: 
217: export const initializeSync = (config?: Partial<SyncConfig>) => {
218:   SyncService.initialize(config);
219: };

================
File: src/services/taskGroupingService.ts
================
 1: import { UpcomingTask, TaskGroup } from "@/types/scheduling";
 2: 
 3: export class TaskGroupingService {
 4:   static groupTasksByActivity(tasks: UpcomingTask[]): TaskGroup[] {
 5:     const groups: TaskGroup[] = [
 6:       {
 7:         type: "watering",
 8:         title: "Watering",
 9:         emoji: "💧",
10:         tasks: [],
11:         isExpanded: true,
12:       },
13:       {
14:         type: "fertilizing",
15:         title: "Fertilizing",
16:         emoji: "🌱",
17:         tasks: [],
18:         isExpanded: true,
19:       },
20:       {
21:         type: "observation",
22:         title: "Health Checks",
23:         emoji: "👁",
24:         tasks: [],
25:         isExpanded: true,
26:       },
27:       {
28:         type: "maintenance",
29:         title: "Maintenance",
30:         emoji: "✂️",
31:         tasks: [],
32:         isExpanded: false,
33:       },
34:     ];
35: 
36: 
37:     tasks.forEach((task) => {
38:       const taskName = task.task.toLowerCase();
39: 
40:       if (taskName.includes("water") || taskName.includes("moisture")) {
41:         groups[0].tasks.push(task);
42:       } else if (taskName.includes("fertiliz") || taskName.includes("feed")) {
43:         groups[1].tasks.push(task);
44:       } else if (
45:         taskName.includes("observe") ||
46:         taskName.includes("health") ||
47:         taskName.includes("check")
48:       ) {
49:         groups[2].tasks.push(task);
50:       } else {
51:         groups[3].tasks.push(task);
52:       }
53:     });
54: 
55: 
56:     groups.forEach((group) => {
57:       const hasHighPriority = group.tasks.some(
58:         (task) => task.priority === "high"
59:       );
60:       if (hasHighPriority) {
61:         group.isExpanded = true;
62:       }
63:     });
64: 
65: 
66:     return groups.filter((group) => group.tasks.length > 0);
67:   }
68: 
69:   static shouldExpandGroup(group: TaskGroup): boolean {
70: 
71:     return group.tasks.some(
72:       (task) => task.priority === "high" || task.dueIn.includes("overdue")
73:     );
74:   }
75: }

================
File: src/types/user.ts
================
 1: export interface UserSettings {
 2:   id: string;
 3: 
 4:   units: {
 5:     temperature: "fahrenheit" | "celsius";
 6:     volume: "ounces" | "liters";
 7:   };
 8: 
 9:   notifications: {
10:     careReminders: boolean;
11:     harvestAlerts: boolean;
12:   };
13: 
14:   location: {
15:     timezone: string;
16:     zipCode?: string;
17:   };
18: }

================
File: src/utils/cn.ts
================
1: import { type ClassValue, clsx } from "clsx";
2: import { twMerge } from "tailwind-merge";
3: 
4: export function cn(...inputs: ClassValue[]) {
5:   return twMerge(clsx(inputs));
6: }

================
File: src/utils/dateUtils.ts
================
 1: export function formatDate(date: Date): string {
 2:   return new Intl.DateTimeFormat("en-US", {
 3:     month: "short",
 4:     day: "numeric",
 5:     year: "numeric",
 6:   }).format(date);
 7: }
 8: 
 9: export function getDaysSincePlanting(plantedDate: Date): number {
10:   const now = new Date();
11:   const diffTime = Math.abs(now.getTime() - plantedDate.getTime());
12:   return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
13: }
14: 
15: export function formatDateTime(date: Date): string {
16:   return new Intl.DateTimeFormat("en-US", {
17:     month: "short",
18:     day: "numeric",
19:     hour: "numeric",
20:     minute: "2-digit",
21:   }).format(date);
22: }
23: 
24: export function formatTime(date: Date): string {
25:   return new Intl.DateTimeFormat("en-US", {
26:     hour: "numeric",
27:     minute: "2-digit",
28:   }).format(date);
29: }

================
File: src/utils/plantDisplay.ts
================
 1: import { PlantRecord } from "@/types/database";
 2: 
 3: 
 4: 
 5: 
 6: 
 7: export function getPlantDisplayName(plant: PlantRecord): string {
 8: 
 9:   if (plant.name?.trim()) {
10:     return plant.name.trim();
11:   }
12: 
13: 
14:   if (plant.varietyName?.trim()) {
15:     return plant.varietyName.trim();
16:   }
17: 
18:   return "Unknown Plant";
19: }

================
File: src/utils/waterConversion.ts
================
 1: import { WaterAmount } from "../types/database";
 2: export function convertToMl(amount: WaterAmount): number {
 3:   const conversions = {
 4:     ml: 1,
 5:     oz: 29.5735,
 6:     cups: 236.588,
 7:     liters: 1000,
 8:     gallons: 3785.41,
 9:   };
10:   return amount.value * conversions[amount.unit];
11: }
12: 
13: export function formatWaterAmount(amount: WaterAmount): string {
14:   return `${amount.value} ${amount.unit}`;
15: }

================
File: src/index.css
================
 1: :root {
 2:   font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
 3:   line-height: 1.5;
 4:   font-weight: 400;
 5: 
 6:   color-scheme: light dark;
 7:   color: rgba(255, 255, 255, 0.87);
 8:   background-color: #242424;
 9: 
10:   font-synthesis: none;
11:   text-rendering: optimizeLegibility;
12:   -webkit-font-smoothing: antialiased;
13:   -moz-osx-font-smoothing: grayscale;
14: }
15: 
16: a {
17:   font-weight: 500;
18:   color: #646cff;
19:   text-decoration: inherit;
20: }
21: a:hover {
22:   color: #535bf2;
23: }
24: 
25: body {
26:   margin: 0;
27:   display: flex;
28:   place-items: center;
29:   min-width: 320px;
30:   min-height: 100vh;
31: }
32: 
33: h1 {
34:   font-size: 3.2em;
35:   line-height: 1.1;
36: }
37: 
38: button {
39:   border-radius: 8px;
40:   border: 1px solid transparent;
41:   padding: 0.6em 1.2em;
42:   font-size: 1em;
43:   font-weight: 500;
44:   font-family: inherit;
45:   background-color: #1a1a1a;
46:   cursor: pointer;
47:   transition: border-color 0.25s;
48: }
49: button:hover {
50:   border-color: #646cff;
51: }
52: button:focus,
53: button:focus-visible {
54:   outline: 4px auto -webkit-focus-ring-color;
55: }
56: 
57: @media (prefers-color-scheme: light) {
58:   :root {
59:     color: #213547;
60:     background-color: #ffffff;
61:   }
62:   a:hover {
63:     color: #747bff;
64:   }
65:   button {
66:     background-color: #f9f9f9;
67:   }
68: }

================
File: src/jest.polyfills.ts
================
1: import { TextDecoder, TextEncoder } from "util";
2: 
3: Object.assign(global, { TextDecoder, TextEncoder });

================
File: src/main.tsx
================
 1: import React from "react";
 2: import ReactDOM from "react-dom/client";
 3: import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
 4: import { BrowserRouter } from "react-router-dom";
 5: import App from "./App.tsx";
 6: import "./styles/globals.css";
 7: 
 8: 
 9: const queryClient = new QueryClient({
10:   defaultOptions: {
11:     queries: {
12: 
13:       staleTime: 5 * 60 * 1000,
14: 
15:       gcTime: 24 * 60 * 60 * 1000,
16: 
17:       retry: (failureCount) => {
18: 
19:         if (!navigator.onLine) return false;
20:         return failureCount < 3;
21:       },
22:     },
23:   },
24: });
25: 
26: ReactDOM.createRoot(document.getElementById("root")!).render(
27:   <React.StrictMode>
28:     <QueryClientProvider client={queryClient}>
29:       <BrowserRouter>
30:         <App />
31:       </BrowserRouter>
32:     </QueryClientProvider>
33:   </React.StrictMode>
34: );

================
File: src/vite-env.d.ts
================
1: 

================
File: tests/e2e/pwa-functionality.spec.ts
================
 1: import { test, expect } from "@playwright/test";
 2: 
 3: test.describe("PWA Functionality", () => {
 4:   test.beforeEach(async ({ page }) => {
 5: 
 6:     await page.context().clearCookies();
 7:     await page.evaluate(() => {
 8:       localStorage.clear();
 9:       sessionStorage.clear();
10:     });
11:   });
12: 
13:   test("app loads and displays correctly", async ({ page }) => {
14:     await page.goto("/");
15: 
16:     await expect(page.getByText("🌱 SmartGarden")).toBeVisible();
17:     await expect(page.getByText("Active Plants")).toBeVisible();
18:     await expect(page.getByText("Tasks Due")).toBeVisible();
19:   });
20: 
21:   test("offline functionality works", async ({ page, context }) => {
22: 
23:     await page.goto("/");
24:     await expect(page.getByText("SmartGarden")).toBeVisible();
25: 
26: 
27:     await context.setOffline(true);
28: 
29: 
30:     await page.reload();
31: 
32: 
33:     await expect(page.getByText("SmartGarden")).toBeVisible();
34: 
35: 
36:     await expect(page.getByText(/offline/i)).toBeVisible();
37:   });
38: 
39:   test("plant registration flow", async ({ page }) => {
40:     await page.goto("/");
41: 
42: 
43:     await page.getByText("Add Your First Plant").click();
44: 
45: 
46:     await page.selectOption('[name="varietyId"]', { index: 1 });
47:     await page.fill('[name="name"]', "My Test Plant");
48:     await page.fill('[name="location"]', "Test Location");
49:     await page.fill('[name="container"]', "Test Container");
50: 
51: 
52:     await page.getByText("Register Plant").click();
53: 
54: 
55:     await expect(page.getByText("My Test Plant")).toBeVisible();
56:   });
57: 
58:   test("data persists across page reloads", async ({ page }) => {
59:     await page.goto("/add-plant");
60: 
61: 
62:     await page.selectOption('[name="varietyId"]', { index: 1 });
63:     await page.fill('[name="name"]', "Persistent Plant");
64:     await page.fill('[name="location"]', "Kitchen");
65:     await page.fill('[name="container"]', "4 inch pot");
66:     await page.getByText("Register Plant").click();
67: 
68: 
69:     await page.reload();
70: 
71: 
72:     await expect(page.getByText("Persistent Plant")).toBeVisible();
73:     await expect(page.getByText("1")).toBeVisible();
74:   });
75: 
76:   test("responsive design on mobile viewport", async ({ page }) => {
77: 
78:     await page.setViewportSize({ width: 375, height: 667 });
79:     await page.goto("/");
80: 
81: 
82:     const navItems = page.locator("nav a");
83:     await expect(navItems.first()).toBeVisible();
84: 
85: 
86:     const buttonSize = await page.getByText("Add Plant").boundingBox();
87:     expect(buttonSize?.height).toBeGreaterThanOrEqual(44);
88:   });
89: });

================
File: eslint.config.js
================
 1: import js from '@eslint/js'
 2: import globals from 'globals'
 3: import reactHooks from 'eslint-plugin-react-hooks'
 4: import reactRefresh from 'eslint-plugin-react-refresh'
 5: import tseslint from 'typescript-eslint'
 6: 
 7: export default tseslint.config(
 8:   { ignores: ['dist'] },
 9:   {
10:     extends: [js.configs.recommended, ...tseslint.configs.recommended],
11:     files: ['**/*.{ts,tsx}'],
12:     languageOptions: {
13:       ecmaVersion: 2020,
14:       globals: globals.browser,
15:     },
16:     plugins: {
17:       'react-hooks': reactHooks,
18:       'react-refresh': reactRefresh,
19:     },
20:     rules: {
21:       ...reactHooks.configs.recommended.rules,
22:       'react-refresh/only-export-components': [
23:         'warn',
24:         { allowConstantExport: true },
25:       ],
26:     },
27:   },
28: )

================
File: postcss.config.js
================
1: export default {
2:   plugins: {
3:     tailwindcss: {},
4:     autoprefixer: {},
5:   },
6: }

================
File: repomix.config.json
================
 1: {
 2:   "output": {
 3:     "style": "plain",
 4:     "filePath": "custom-output.txt",
 5:     "removeComments": true,
 6:     "showLineNumbers": true,
 7:     "topFilesLength": 10
 8:   },
 9:   "ignore": {
10:     "customPatterns": [
11:       "logs",
12:       "*.log",
13:       "npm-debug.log*",
14:       "yarn-debug.log*",
15:       "yarn-error.log*",
16:       "pnpm-debug.log*",
17:       "lerna-debug.log*",
18:       ".cache/",
19:       ".parcel-cache/",
20:       "node_modules",
21:       "dist",
22:       "dist-ssr",
23:       "*.local",
24:       ".vscode/*",
25:       "*.suo",
26:       "*.ntvs*",
27:       "*.njsproj",
28:       "*.sln",
29:       "*.sw?",
30:       "._*",
31:       ".Spotlight-V100",
32:       ".Trashes",
33:       "ehthumbs.db",
34:       "Thumbs.db",
35:       ".vscode/",
36:       ".idea/",
37:       ".env.local",
38:       ".env.development.local",
39:       ".env.test.local",
40:       ".env.production.local",
41:       "*.tmp",
42:       "*.temp"
43:     ]
44:   }
45: }

================
File: tsconfig.app.json
================
 1: {
 2:   "compilerOptions": {
 3:     "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
 4:     "target": "ES2020",
 5:     "useDefineForClassFields": true,
 6:     "lib": ["ES2020", "DOM", "DOM.Iterable"],
 7:     "module": "ESNext",
 8:     "skipLibCheck": true,
 9: 
10:     /* Bundler mode */
11:     "moduleResolution": "bundler",
12:     "allowImportingTsExtensions": true,
13:     "verbatimModuleSyntax": true,
14:     "moduleDetection": "force",
15:     "noEmit": true,
16:     "jsx": "react-jsx",
17: 
18:     /* Linting */
19:     "strict": true,
20:     "noUnusedLocals": true,
21:     "noUnusedParameters": true,
22:     "erasableSyntaxOnly": true,
23:     "noFallthroughCasesInSwitch": true,
24:     "noUncheckedSideEffectImports": true
25:   },
26:   "include": ["src"]
27: }

================
File: tsconfig.node.json
================
 1: {
 2:   "compilerOptions": {
 3:     "composite": true,
 4:     "skipLibCheck": true,
 5:     "module": "ESNext",
 6:     "moduleResolution": "bundler",
 7:     "allowSyntheticDefaultImports": true,
 8:     "strict": true,
 9:     "noEmit": true
10:   },
11:   "include": ["vite.config.ts"]
12: }

================
File: tsconfig.tsbuildinfo
================
1: {"root":["./src/app.tsx","./src/jest.polyfills.ts","./src/main.tsx","./src/setuptests.ts","./src/vite-env.d.ts","./src/__tests__/components/dashboard.test.tsx","./src/__tests__/components/plantregistrationform.test.tsx","./src/__tests__/components/soilmixtureselector.test.tsx","./src/__tests__/database/integration.test.ts","./src/__tests__/database/plantservice.test.ts","./src/__tests__/database/varietyservice.test.ts","./src/__tests__/integration/stagecalculationdisplay.test.tsx","./src/__tests__/services/growthstageservice.test.ts","./src/__tests__/utils/growthstage.test.ts","./src/__tests__/utils/varietygrowthstages.test.ts","./src/components/navigation.tsx","./src/components/layouts/emptystate.tsx","./src/components/layouts/welcome.tsx","./src/components/plant/customvarietyform.tsx","./src/components/plant/plantregistrationform.tsx","./src/components/plant/soilmixtureselector.tsx","./src/components/ui/button.tsx","./src/components/ui/card.tsx","./src/components/ui/loadingspinner.tsx","./src/components/ui/locationtoggle.tsx","./src/components/ui/offlineindicator.tsx","./src/components/ui/statusbadge.tsx","./src/components/ui/switch.tsx","./src/data/seedvarieties.ts","./src/db/schema.ts","./src/db/seeddata.ts","./src/hooks/useappinitialization.ts","./src/hooks/usedynamicstage.ts","./src/hooks/usefirsttimeuser.ts","./src/pages/analytics/index.tsx","./src/pages/care/carelogform.tsx","./src/pages/care/logcare.tsx","./src/pages/care/photocapture.tsx","./src/pages/care/index.tsx","./src/pages/dashboard/index.tsx","./src/pages/plants/addplant.tsx","./src/pages/plants/plants.tsx","./src/pages/settings/index.tsx","./src/services/careschedulingservice.ts","./src/services/growthstageservice.ts","./src/services/sync/syncservice.ts","./src/types/core.ts","./src/types/database.ts","./src/types/index.ts","./src/types/scheduling.ts","./src/types/user.ts","./src/utils/cn.ts","./src/utils/growthstage.ts","./vite.config.ts"],"version":"5.8.3"}

================
File: vite.config.ts
================
  1: import { defineConfig } from "vite";
  2: import react from "@vitejs/plugin-react";
  3: import { VitePWA } from "vite-plugin-pwa";
  4: import path from "path";
  5: 
  6: export default defineConfig({
  7:   plugins: [
  8:     react(),
  9:     VitePWA({
 10:       registerType: "autoUpdate",
 11:       workbox: {
 12: 
 13:         globPatterns: ["**/*.{js,css,html,ico,png,svg,jpg,jpeg}"],
 14:         runtimeCaching: [
 15:           {
 16: 
 17:             urlPattern: /^https:\/\/.*\.(png|jpg|jpeg|svg|webp)$/,
 18:             handler: "CacheFirst",
 19:             options: {
 20:               cacheName: "plant-images",
 21:               expiration: {
 22:                 maxEntries: 500,
 23:                 maxAgeSeconds: 60 * 60 * 24 * 30,
 24:               },
 25:             },
 26:           },
 27:         ],
 28:       },
 29:       manifest: {
 30:         name: "SmartGarden - Intelligent Plant Care",
 31:         short_name: "SmartGarden",
 32:         description:
 33:           "Your AI-powered gardening assistant for optimal plant care",
 34:         theme_color: "#22c55e",
 35:         background_color: "#ffffff",
 36:         display: "standalone",
 37:         orientation: "portrait",
 38:         scope: "/",
 39:         start_url: "/",
 40:         icons: [
 41:           {
 42:             src: "/icons/icon-72x72.png",
 43:             sizes: "72x72",
 44:             type: "image/png",
 45:             purpose: "maskable any",
 46:           },
 47:           {
 48:             src: "/icons/icon-96x96.png",
 49:             sizes: "96x96",
 50:             type: "image/png",
 51:             purpose: "maskable any",
 52:           },
 53:           {
 54:             src: "/icons/icon-128x128.png",
 55:             sizes: "128x128",
 56:             type: "image/png",
 57:             purpose: "maskable any",
 58:           },
 59:           {
 60:             src: "/icons/icon-144x144.png",
 61:             sizes: "144x144",
 62:             type: "image/png",
 63:             purpose: "maskable any",
 64:           },
 65:           {
 66:             src: "/icons/icon-152x152.png",
 67:             sizes: "152x152",
 68:             type: "image/png",
 69:             purpose: "maskable any",
 70:           },
 71:           {
 72:             src: "/icons/icon-192x192.png",
 73:             sizes: "192x192",
 74:             type: "image/png",
 75:             purpose: "maskable any",
 76:           },
 77:           {
 78:             src: "/icons/icon-384x384.png",
 79:             sizes: "384x384",
 80:             type: "image/png",
 81:             purpose: "maskable any",
 82:           },
 83:           {
 84:             src: "/icons/icon-512x512.png",
 85:             sizes: "512x512",
 86:             type: "image/png",
 87:             purpose: "maskable any",
 88:           },
 89:         ],
 90:       },
 91:     }),
 92:   ],
 93:   resolve: {
 94:     alias: {
 95: 
 96:       "@": path.resolve(__dirname, "./src"),
 97:       "@/components": path.resolve(__dirname, "./src/components"),
 98:       "@/pages": path.resolve(__dirname, "./src/pages"),
 99:       "@/hooks": path.resolve(__dirname, "./src/hooks"),
100:       "@/services": path.resolve(__dirname, "./src/services"),
101:       "@/types": path.resolve(__dirname, "./src/types"),
102:       "@/utils": path.resolve(__dirname, "./src/utils"),
103:     },
104:   },
105:   server: {
106: 
107:     host: true,
108:     port: 3000,
109:   },
110: });

================
File: src/__tests__/components/CareLogForm.test.tsx
================
  1: import { describe, it, expect, beforeEach } from "@jest/globals";
  2: import { render, screen, waitFor } from "@testing-library/react";
  3: import userEvent from "@testing-library/user-event";
  4: import { MemoryRouter } from "react-router-dom";
  5: import { CareLogForm } from "@/pages/care/CareLogForm";
  6: import { initializeDatabase } from "@/db/seedData";
  7: import { plantService } from "@/types/database";
  8: 
  9: 
 10: const renderWithRouter = (
 11:   component: React.ReactElement,
 12:   initialEntries: string[] = ["/log-care"]
 13: ) => {
 14:   return render(
 15:     <MemoryRouter initialEntries={initialEntries}>{component}</MemoryRouter>
 16:   );
 17: };
 18: 
 19: describe("CareLogForm Pre-Selection", () => {
 20:   beforeEach(async () => {
 21:     await initializeDatabase();
 22:     const { db } = await import("@/types/database");
 23:     await db.plants.clear();
 24:   });
 25: 
 26:   it("pre-selects plant when preselectedPlantId is provided", async () => {
 27:     const plantId = await plantService.addPlant({
 28:       varietyId: "test-variety",
 29:       varietyName: "Test Variety",
 30:       name: "Test Plant",
 31:       plantedDate: new Date(),
 32:       location: "Location 1",
 33:       container: "Container 1",
 34:       currentStage: "vegetative",
 35:       isActive: true,
 36:     });
 37: 
 38:     const mockOnSuccess = jest.fn();
 39: 
 40:     renderWithRouter(
 41:       <CareLogForm onSuccess={mockOnSuccess} preselectedPlantId={plantId} />
 42:     );
 43: 
 44:     await waitFor(() => {
 45:       const plantSelect = screen.getByLabelText(/Plant/i) as HTMLSelectElement;
 46:       expect(plantSelect.value).toBe(plantId);
 47:     });
 48:   });
 49: 
 50:   it("shows normal plant selection when no preselectedPlantId is provided", async () => {
 51:     await plantService.addPlant({
 52:       varietyId: "test-variety",
 53:       varietyName: "Test Variety",
 54:       name: "Test Plant",
 55:       plantedDate: new Date(),
 56:       location: "Location 1",
 57:       container: "Container 1",
 58:       currentStage: "vegetative",
 59:       isActive: true,
 60:     });
 61: 
 62:     const mockOnSuccess = jest.fn();
 63: 
 64:     renderWithRouter(<CareLogForm onSuccess={mockOnSuccess} />);
 65: 
 66: 
 67:     await waitFor(() => {
 68:       const plantSelect = screen.getByLabelText(/Plant/i) as HTMLSelectElement;
 69:       expect(plantSelect.value).toBe("");
 70:     });
 71: 
 72:     // Then check that the plant option appears
 73:     await waitFor(() => {
 74:       expect(screen.getByText("Test Plant - Location 1")).toBeInTheDocument();
 75:     });
 76:   });
 77: 
 78:   it("allows user to change pre-selected plant", async () => {
 79:     const plant1Id = await plantService.addPlant({
 80:       varietyId: "test-variety-1",
 81:       varietyName: "Plant One",
 82:       name: "Plant One",
 83:       plantedDate: new Date(),
 84:       location: "Location 1",
 85:       container: "Container 1",
 86:       currentStage: "vegetative",
 87:       isActive: true,
 88:     });
 89: 
 90:     const plant2Id = await plantService.addPlant({
 91:       varietyId: "test-variety-2",
 92:       varietyName: "Plant Two",
 93:       name: "Plant Two",
 94:       plantedDate: new Date(),
 95:       location: "Location 2",
 96:       container: "Container 2",
 97:       currentStage: "vegetative",
 98:       isActive: true,
 99:     });
100: 
101:     const mockOnSuccess = jest.fn();
102:     const user = userEvent.setup();
103: 
104:     renderWithRouter(
105:       <CareLogForm onSuccess={mockOnSuccess} preselectedPlantId={plant1Id} />
106:     );
107: 
108: 
109:     await waitFor(() => {
110:       expect(screen.getByText("Plant One - Location 1")).toBeInTheDocument();
111:       expect(screen.getByText("Plant Two - Location 2")).toBeInTheDocument();
112:     });
113: 
114:     await waitFor(() => {
115:       const plantSelect = screen.getByLabelText(/Plant/i) as HTMLSelectElement;
116:       expect(plantSelect.value).toBe(plant1Id);
117:     });
118: 
119:     const plantSelect = screen.getByLabelText(/Plant/i);
120:     await user.selectOptions(plantSelect, plant2Id);
121: 
122:     expect((plantSelect as HTMLSelectElement).value).toBe(plant2Id);
123:   });
124: 
125:   it("renders form with basic activity fields", async () => {
126:     const mockOnSuccess = jest.fn();
127: 
128:     renderWithRouter(<CareLogForm onSuccess={mockOnSuccess} />);
129: 
130:     await waitFor(() => {
131:       expect(screen.getByText("Log Care Activity")).toBeInTheDocument();
132:       expect(screen.getByLabelText(/Plant/i)).toBeInTheDocument();
133:       expect(screen.getByLabelText(/Activity Type/i)).toBeInTheDocument();
134:       expect(screen.getByLabelText(/Date/i)).toBeInTheDocument();
135:     });
136: 
137:     expect(screen.getByText("💧 Watering")).toBeInTheDocument();
138:     expect(screen.getByText("🌱 Fertilizing")).toBeInTheDocument();
139:     expect(screen.getByText("👁️ Observation")).toBeInTheDocument();
140:   });
141: 
142:   it("shows watering fields when water activity is selected", async () => {
143:     const mockOnSuccess = jest.fn();
144: 
145:     renderWithRouter(<CareLogForm onSuccess={mockOnSuccess} />);
146: 
147:     await waitFor(() => {
148:       expect(screen.getByText("Water Amount *")).toBeInTheDocument();
149:     });
150: 
151:     expect(screen.getByPlaceholderText("Amount")).toBeInTheDocument();
152: 
153:     expect(screen.getByText("oz")).toBeInTheDocument();
154:     expect(screen.getByText("ml")).toBeInTheDocument();
155:     expect(screen.getByText("cups")).toBeInTheDocument();
156:   });
157: 
158:   it("displays proper plant formatting in dropdown options", async () => {
159:     await plantService.addPlant({
160:       varietyId: "test-variety",
161:       varietyName: "Cherry Tomato",
162:       name: "My Cherry Plant",
163:       plantedDate: new Date(),
164:       location: "Window Sill",
165:       container: "5 gallon pot",
166:       currentStage: "flowering",
167:       isActive: true,
168:     });
169: 
170:     const mockOnSuccess = jest.fn();
171: 
172:     renderWithRouter(<CareLogForm onSuccess={mockOnSuccess} />);
173: 
174:     await waitFor(() => {
175:       const expectedText = "My Cherry Plant - Window Sill";
176:       expect(screen.getByText(expectedText)).toBeInTheDocument();
177:     });
178:   });
179: 
180:   it("handles plant without custom name correctly", async () => {
181:     await plantService.addPlant({
182:       varietyId: "test-variety",
183:       varietyName: "Roma Tomato",
184:       plantedDate: new Date(),
185:       location: "Greenhouse",
186:       container: "3 gallon pot",
187:       currentStage: "fruiting",
188:       isActive: true,
189:     });
190: 
191:     const mockOnSuccess = jest.fn();
192: 
193:     renderWithRouter(<CareLogForm onSuccess={mockOnSuccess} />);
194: 
195:     await waitFor(() => {
196:       const expectedText = "Roma Tomato - Greenhouse";
197:       expect(screen.getByText(expectedText)).toBeInTheDocument();
198:     });
199:   });
200: });

================
File: src/__tests__/components/PlantRegistrationForm.test.tsx
================
  1: import { render, screen, waitFor, cleanup } from "@testing-library/react";
  2: import userEvent from "@testing-library/user-event";
  3: import { PlantRegistrationForm } from "@/components/plant/PlantRegistrationForm";
  4: import { plantService, varietyService } from "@/types/database";
  5: import type { VarietyRecord } from "@/types/database";
  6: import toast from "react-hot-toast";
  7: 
  8: jest.mock("@/components/plant/SoilMixtureSelector", () => ({
  9:   __esModule: true,
 10:   default: ({
 11:     selectedMixture,
 12:     onMixtureChange,
 13:   }: {
 14:     selectedMixture?: string;
 15:     onMixtureChange: (mixture: string) => void;
 16:   }) => (
 17:     <div>
 18:       <label htmlFor="soilMix">Soil Mixture</label>
 19:       <textarea
 20:         data-testid="soil-mixture-selector"
 21:         id="soilMix"
 22:         value={selectedMixture || ""}
 23:         onChange={(e) => onMixtureChange(e.target.value)}
 24:         placeholder="e.g., 40% coco coir, 30% perlite, 25% vermiculite, 5% compost"
 25:       />
 26:     </div>
 27:   ),
 28: }));
 29: 
 30: jest.mock("@/components/plant/CustomVarietyForm", () => ({
 31:   CustomVarietyForm: ({
 32:     onSuccess,
 33:     onCancel,
 34:   }: {
 35:     onSuccess?: (varietyId: string) => void;
 36:     onCancel?: () => void;
 37:   }) => (
 38:     <div data-testid="custom-variety-form">
 39:       <button onClick={() => onSuccess?.("new-variety-id")}>
 40:         Save Variety
 41:       </button>
 42:       <button onClick={onCancel}>Cancel</button>
 43:     </div>
 44:   ),
 45: }));
 46: 
 47: jest.mock("@/types/database", () => ({
 48:   plantService: {
 49:     addPlant: jest.fn(),
 50:   },
 51:   varietyService: {
 52:     getAllVarieties: jest.fn(),
 53:   },
 54: }));
 55: 
 56: jest.mock("react-hot-toast", () => ({
 57:   __esModule: true,
 58:   default: {
 59:     success: jest.fn(),
 60:     error: jest.fn(),
 61:   },
 62: }));
 63: 
 64: const mockPlantService = plantService as jest.Mocked<typeof plantService>;
 65: const mockVarietyService = varietyService as jest.Mocked<typeof varietyService>;
 66: const mockToast = toast as jest.Mocked<typeof toast>;
 67: 
 68: const mockVarieties: VarietyRecord[] = [
 69:   {
 70:     id: "variety-1",
 71:     name: "Test Variety",
 72:     category: "herbs",
 73:     isCustom: false,
 74:     growthTimeline: {
 75:       germination: 7,
 76:       seedling: 14,
 77:       vegetative: 30,
 78:       maturation: 102,
 79:     },
 80:     protocols: {
 81:       watering: {
 82:         germination: {
 83:           trigger: { moistureLevel: "3-4" },
 84:           target: { moistureLevel: "6-7" },
 85:           volume: { amount: "16-24 oz", frequency: "every 2-3 days" },
 86:         },
 87:       },
 88:     },
 89:     createdAt: new Date(),
 90:   },
 91:   {
 92:     id: "tomato-1",
 93:     name: "Roma Tomato",
 94:     category: "fruiting-plants",
 95:     isCustom: false,
 96:     growthTimeline: {
 97:       germination: 7,
 98:       seedling: 14,
 99:       vegetative: 30,
100:       maturation: 85,
101:     },
102:     protocols: {
103:       lighting: {
104:         germination: {
105:           ppfd: { min: 100, max: 300, unit: "µmol/m²/s" },
106:           photoperiod: { hours: 16 },
107:           dli: { min: 5, max: 10, unit: "mol/m²/day" },
108:         },
109:       },
110:     },
111:     createdAt: new Date(),
112:   },
113:   {
114:     id: "basil-1",
115:     name: "Sweet Basil",
116:     category: "herbs",
117:     isCustom: false,
118:     growthTimeline: {
119:       germination: 5,
120:       seedling: 10,
121:       vegetative: 45,
122:       maturation: 75,
123:     },
124:     protocols: {
125:       environment: {
126:         temperature: { min: 65, max: 75, optimal: 70, unit: "F" },
127:         pH: { min: 6.0, max: 7.0, optimal: 6.5 },
128:       },
129:     },
130:     createdAt: new Date(),
131:   },
132:   {
133:     id: "custom-1",
134:     name: "My Custom Plant",
135:     category: "leafy-greens",
136:     isCustom: true,
137:     growthTimeline: {
138:       germination: 7,
139:       seedling: 14,
140:       vegetative: 30,
141:       maturation: 60,
142:     },
143:     protocols: {
144:       fertilization: {
145:         vegetative: {
146:           products: [
147:             {
148:               name: "General Hydroponics FloraNova Grow",
149:               dilution: "1 tsp/gal",
150:               amount: "16 oz",
151:               frequency: "weekly",
152:             },
153:           ],
154:         },
155:       },
156:     },
157:     createdAt: new Date(),
158:   },
159: ];
160: 
161: const mockOnSuccess = jest.fn();
162: const mockOnCancel = jest.fn();
163: 
164: 
165: const toggleLocationToOutdoor = async (
166:   user: ReturnType<typeof userEvent.setup>
167: ) => {
168: 
169:   const locationSwitch = screen.getByLabelText(/location/i);
170: 
171:   if (locationSwitch.getAttribute("aria-checked") === "false") {
172:     await user.click(locationSwitch);
173:   }
174: };
175: 
176: 
177: const fillRequiredFields = async (user: ReturnType<typeof userEvent.setup>) => {
178: 
179:   await waitFor(() => {
180:     expect(
181:       screen.getByRole("option", { name: /roma tomato/i })
182:     ).toBeInTheDocument();
183:   });
184: 
185: 
186:   const varietySelect = screen.getByLabelText(/plant variety/i);
187:   await user.selectOptions(varietySelect, "tomato-1");
188: 
189: 
190:   await toggleLocationToOutdoor(user);
191: 
192: 
193:   const growBagRadio = screen.getByDisplayValue("grow-bag");
194:   await user.click(growBagRadio);
195: 
196:   await waitFor(() => {
197:     expect(screen.getByText("1 Gallon")).toBeInTheDocument();
198:   });
199: 
200: 
201:   const oneGallonRadio = screen.getByDisplayValue("1-gallon");
202:   await user.click(oneGallonRadio);
203: 
204: 
205:   const soilMixTextarea = screen.getByTestId("soil-mixture-selector");
206:   await user.type(soilMixTextarea, "Test soil mix");
207: };
208: describe("PlantRegistrationForm", () => {
209:   let user: ReturnType<typeof userEvent.setup>;
210: 
211:   const renderForm = (props = {}) => {
212:     return render(
213:       <PlantRegistrationForm
214:         onSuccess={mockOnSuccess}
215:         onCancel={mockOnCancel}
216:         {...props}
217:       />
218:     );
219:   };
220: 
221:   beforeEach(() => {
222:     user = userEvent.setup();
223:     jest.clearAllMocks();
224:     mockVarietyService.getAllVarieties.mockResolvedValue(mockVarieties);
225:   });
226: 
227:   afterEach(() => {
228:     cleanup();
229: 
230:     document.body.innerHTML = "";
231:   });
232: 
233:   describe("Form Rendering", () => {
234:     it("renders all form fields correctly", async () => {
235:       renderForm();
236: 
237:       await waitFor(() => {
238:         expect(mockVarietyService.getAllVarieties).toHaveBeenCalled();
239:       });
240: 
241: 
242:       expect(screen.getByText("Register New Plant")).toBeInTheDocument();
243:       expect(screen.getByLabelText(/plant variety/i)).toBeInTheDocument();
244:       expect(screen.getByLabelText(/plant name/i)).toBeInTheDocument();
245:       expect(screen.getByLabelText(/planting date/i)).toBeInTheDocument();
246:       expect(screen.getByLabelText(/location/i)).toBeInTheDocument();
247:       expect(screen.getByText("Container Type *")).toBeInTheDocument();
248:       expect(screen.getByTestId("soil-mixture-selector")).toBeInTheDocument();
249:       expect(screen.getByLabelText(/notes/i)).toBeInTheDocument();
250: 
251: 
252:       expect(screen.getByText("Complete Required Fields")).toBeInTheDocument();
253:       expect(screen.getByText("Cancel")).toBeInTheDocument();
254:     });
255: 
256:     it("loads and displays varieties correctly", async () => {
257:       renderForm();
258: 
259:       await waitFor(() => {
260:         expect(mockVarietyService.getAllVarieties).toHaveBeenCalled();
261:       });
262: 
263: 
264:       expect(
265:         screen.getByText("Roma Tomato (fruiting-plants)")
266:       ).toBeInTheDocument();
267:       expect(screen.getByText("Sweet Basil (herbs)")).toBeInTheDocument();
268: 
269: 
270:       expect(
271:         screen.getByText("🌱 My Custom Plant (leafy-greens)")
272:       ).toBeInTheDocument();
273:     });
274: 
275:     it("shows custom variety form when button is clicked", async () => {
276:       renderForm();
277: 
278:       await waitFor(() => {
279:         expect(mockVarietyService.getAllVarieties).toHaveBeenCalled();
280:       });
281: 
282:       const customVarietyButton = screen.getByText("➕ Create Custom Variety");
283:       await user.click(customVarietyButton);
284: 
285:       expect(screen.getByTestId("custom-variety-form")).toBeInTheDocument();
286:     });
287:   });
288: 
289:   describe("Container Type Selection", () => {
290:     beforeEach(async () => {
291:       renderForm();
292:       await waitFor(() => {
293:         expect(mockVarietyService.getAllVarieties).toHaveBeenCalled();
294:       });
295:     });
296: 
297:     it("shows container size options when grow bag is selected", async () => {
298:       const growBagRadio = screen.getByDisplayValue("grow-bag");
299:       await user.click(growBagRadio);
300: 
301:       await waitFor(() => {
302:         expect(screen.getByText("1 Gallon")).toBeInTheDocument();
303:         expect(screen.getByText("3 Gallon")).toBeInTheDocument();
304:         expect(screen.getByText("5 Gallon")).toBeInTheDocument();
305:         expect(screen.getByText("Custom Size")).toBeInTheDocument();
306:       });
307:     });
308: 
309:     it("shows container size options when pot is selected", async () => {
310:       const potRadio = screen.getByDisplayValue("pot");
311:       await user.click(potRadio);
312: 
313:       await waitFor(() => {
314:         expect(screen.getByText("4 inch")).toBeInTheDocument();
315:         expect(screen.getByText("5 inch")).toBeInTheDocument();
316:         expect(screen.getByText("6 inch")).toBeInTheDocument();
317:       });
318:     });
319: 
320:     it("shows raised bed options when raised bed is selected", async () => {
321:       const raisedBedRadio = screen.getByDisplayValue("raised-bed");
322:       await user.click(raisedBedRadio);
323: 
324:       await waitFor(() => {
325:         expect(screen.getByText("Custom Dimensions")).toBeInTheDocument();
326:       });
327:     });
328:   });
329: 
330:   describe("Custom Grow Bag Configuration", () => {
331:     beforeEach(async () => {
332:       renderForm();
333:       await waitFor(() => {
334:         expect(mockVarietyService.getAllVarieties).toHaveBeenCalled();
335:       });
336: 
337: 
338:       const growBagRadio = screen.getByDisplayValue("grow-bag");
339:       await user.click(growBagRadio);
340: 
341:       await waitFor(() => {
342:         expect(screen.getByText("Custom Size")).toBeInTheDocument();
343:       });
344: 
345:       const customSizeRadio = screen.getByDisplayValue("custom");
346:       await user.click(customSizeRadio);
347:     });
348: 
349:     it("shows shape selection for custom grow bag", async () => {
350:       await waitFor(() => {
351:         expect(screen.getByText("Grow Bag Shape *")).toBeInTheDocument();
352:         expect(screen.getByDisplayValue("circular")).toBeInTheDocument();
353:         expect(screen.getByDisplayValue("rectangular")).toBeInTheDocument();
354:       });
355:     });
356: 
357:     it("shows circular dimensions when circular shape is selected", async () => {
358:       const circularRadio = screen.getByDisplayValue("circular");
359:       await user.click(circularRadio);
360: 
361:       await waitFor(() => {
362:         expect(
363:           screen.getByText("Circular Grow Bag Dimensions (inches) *")
364:         ).toBeInTheDocument();
365:         expect(screen.getByLabelText("Diameter")).toBeInTheDocument();
366:         expect(screen.getByLabelText("Height")).toBeInTheDocument();
367:       });
368: 
369:       const diameterInput = screen.getByLabelText("Diameter");
370:       const heightInput = screen.getByLabelText("Height");
371: 
372:       expect(diameterInput).toHaveAttribute("placeholder", "24");
373:       expect(heightInput).toHaveAttribute("placeholder", "18");
374:     });
375: 
376:     it("shows rectangular dimensions when rectangular shape is selected", async () => {
377:       const rectangularRadio = screen.getByDisplayValue("rectangular");
378:       await user.click(rectangularRadio);
379: 
380:       await waitFor(() => {
381:         expect(
382:           screen.getByText("Rectangular Grow Bag Dimensions (inches) *")
383:         ).toBeInTheDocument();
384:         expect(screen.getByLabelText("Width")).toBeInTheDocument();
385:         expect(screen.getByLabelText("Length")).toBeInTheDocument();
386:         expect(screen.getByLabelText("Height")).toBeInTheDocument();
387:       });
388:     });
389:   });
390: 
391:   describe("Custom Raised Bed Configuration", () => {
392:     beforeEach(async () => {
393:       renderForm();
394:       await waitFor(() => {
395:         expect(mockVarietyService.getAllVarieties).toHaveBeenCalled();
396:       });
397: 
398: 
399:       const raisedBedRadio = screen.getByDisplayValue("raised-bed");
400:       await user.click(raisedBedRadio);
401: 
402:       await waitFor(() => {
403:         expect(screen.getByText("Custom Dimensions")).toBeInTheDocument();
404:       });
405: 
406:       const customDimensionsRadio =
407:         screen.getByDisplayValue("custom-dimensions");
408:       await user.click(customDimensionsRadio);
409:     });
410: 
411:     it("shows raised bed dimension inputs", async () => {
412:       await waitFor(() => {
413:         expect(
414:           screen.getByText("Raised Bed Dimensions (inches) *")
415:         ).toBeInTheDocument();
416:         expect(screen.getByLabelText("Width")).toBeInTheDocument();
417:         expect(screen.getByLabelText("Length")).toBeInTheDocument();
418:         expect(screen.getByLabelText("Soil Depth")).toBeInTheDocument();
419:       });
420:     });
421:   });
422: 
423:   describe("Form Validation & Button States", () => {
424:     beforeEach(async () => {
425:       renderForm();
426:       await waitFor(() => {
427:         expect(mockVarietyService.getAllVarieties).toHaveBeenCalled();
428:       });
429:     });
430: 
431:     it("shows 'Complete Required Fields' when form is invalid", async () => {
432:       expect(screen.getByText("Complete Required Fields")).toBeInTheDocument();
433:       expect(screen.queryByText("Register Plant")).not.toBeInTheDocument();
434: 
435:       const submitButton = screen.getByRole("button", {
436:         name: /complete required fields/i,
437:       });
438:       expect(submitButton).toBeDisabled();
439:     });
440: 
441:     it("shows 'Register Plant' when form is valid", async () => {
442:       await fillRequiredFields(user);
443: 
444:       await waitFor(() => {
445:         expect(screen.getByText("Register Plant")).toBeInTheDocument();
446:       });
447: 
448:       expect(
449:         screen.queryByText("Complete Required Fields")
450:       ).not.toBeInTheDocument();
451: 
452:       const submitButton = screen.getByText("Register Plant");
453:       expect(submitButton).not.toBeDisabled();
454:     });
455: 
456: 
457:   });
458: 
459:   describe("Form Submission", () => {
460:     it("successfully submits form with standard container", async () => {
461:       mockPlantService.addPlant.mockResolvedValue("new-plant-id");
462: 
463:       renderForm();
464:       await waitFor(() => {
465:         expect(mockVarietyService.getAllVarieties).toHaveBeenCalled();
466:       });
467: 
468: 
469:       await fillRequiredFields(user);
470: 
471:       const nameInput = screen.getByLabelText(/plant name/i);
472:       await user.type(nameInput, "My Tomato Plant");
473: 
474: 
475:       await waitFor(() => {
476:         expect(screen.getByText("Register Plant")).toBeInTheDocument();
477:       });
478: 
479:       const submitButton = screen.getByText("Register Plant");
480:       await user.click(submitButton);
481: 
482:       await waitFor(() => {
483:         expect(mockPlantService.addPlant).toHaveBeenCalledWith({
484:           varietyId: "tomato-1",
485:           varietyName: "Roma Tomato",
486:           name: "My Tomato Plant",
487:           plantedDate: expect.any(Date),
488:           currentStage: "germination",
489:           location: "Outdoor",
490:           container: "Grow Bag - 1 Gallon",
491:           soilMix: "Test soil mix",
492:           isActive: true,
493:           notes: [],
494:           reminderPreferences: {
495:             watering: true,
496:             fertilizing: true,
497:             observation: true,
498:             lighting: true,
499:             pruning: true,
500:           },
501:         });
502:       });
503: 
504:       expect(mockOnSuccess).toHaveBeenCalled();
505:     });
506: 
507:     it("successfully submits form with custom grow bag", async () => {
508:       mockPlantService.addPlant.mockResolvedValue("new-plant-id");
509: 
510:       renderForm();
511:       await waitFor(() => {
512:         expect(mockVarietyService.getAllVarieties).toHaveBeenCalled();
513:       });
514: 
515: 
516:       await waitFor(() => {
517:         expect(
518:           screen.getByRole("option", { name: /roma tomato/i })
519:         ).toBeInTheDocument();
520:       });
521: 
522: 
523:       const varietySelect = screen.getByLabelText(/plant variety/i);
524:       await user.selectOptions(varietySelect, "tomato-1");
525: 
526: 
527:       await toggleLocationToOutdoor(user);
528: 
529: 
530:       const growBagRadio = screen.getByDisplayValue("grow-bag");
531:       await user.click(growBagRadio);
532: 
533:       await waitFor(() => {
534:         expect(screen.getByText("Custom Size")).toBeInTheDocument();
535:       });
536: 
537:       const customSizeRadio = screen.getByDisplayValue("custom");
538:       await user.click(customSizeRadio);
539: 
540: 
541:       await waitFor(() => {
542:         expect(screen.getByDisplayValue("rectangular")).toBeInTheDocument();
543:       });
544: 
545:       const rectangularRadio = screen.getByDisplayValue("rectangular");
546:       await user.click(rectangularRadio);
547: 
548: 
549:       await waitFor(() => {
550:         expect(screen.getByLabelText("Width")).toBeInTheDocument();
551:       });
552: 
553:       const widthInput = screen.getByLabelText("Width");
554:       await user.type(widthInput, "24");
555: 
556:       const lengthInput = screen.getByLabelText("Length");
557:       await user.type(lengthInput, "48");
558: 
559:       const heightInput = screen.getByLabelText("Height");
560:       await user.type(heightInput, "18");
561: 
562: 
563:       const soilMixTextarea = screen.getByTestId("soil-mixture-selector");
564:       await user.type(soilMixTextarea, "Test soil mix");
565: 
566:       await waitFor(() => {
567:         expect(screen.getByText("Register Plant")).toBeInTheDocument();
568:       });
569: 
570:       const submitButton = screen.getByText("Register Plant");
571:       await user.click(submitButton);
572: 
573:       await waitFor(() => {
574:         expect(mockPlantService.addPlant).toHaveBeenCalledWith({
575:           varietyId: "tomato-1",
576:           varietyName: "Roma Tomato",
577:           name: undefined,
578:           plantedDate: expect.any(Date),
579:           currentStage: "germination",
580:           location: "Outdoor",
581:           container: 'Grow Bag - 24"W x 48"L x 18"H (Rectangular)',
582:           soilMix: "Test soil mix",
583:           isActive: true,
584:           notes: [],
585:           reminderPreferences: {
586:             watering: true,
587:             fertilizing: true,
588:             observation: true,
589:             lighting: true,
590:             pruning: true,
591:           },
592:         });
593:       });
594: 
595:       expect(mockOnSuccess).toHaveBeenCalled();
596:     });
597: 
598:     it("successfully submits form with custom raised bed", async () => {
599:       mockPlantService.addPlant.mockResolvedValue("new-plant-id");
600: 
601:       renderForm();
602:       await waitFor(() => {
603:         expect(mockVarietyService.getAllVarieties).toHaveBeenCalled();
604:       });
605: 
606: 
607:       await waitFor(() => {
608:         expect(
609:           screen.getByRole("option", { name: /roma tomato/i })
610:         ).toBeInTheDocument();
611:       });
612: 
613:       const varietySelect = screen.getByLabelText(/plant variety/i);
614:       await user.selectOptions(varietySelect, "tomato-1");
615: 
616:       await toggleLocationToOutdoor(user);
617: 
618:       const raisedBedRadio = screen.getByDisplayValue("raised-bed");
619:       await user.click(raisedBedRadio);
620: 
621:       await waitFor(() => {
622:         expect(screen.getByText("Custom Dimensions")).toBeInTheDocument();
623:       });
624: 
625:       const customDimensionsRadio =
626:         screen.getByDisplayValue("custom-dimensions");
627:       await user.click(customDimensionsRadio);
628: 
629:       await waitFor(() => {
630:         expect(screen.getByLabelText("Width")).toBeInTheDocument();
631:       });
632: 
633:       const widthInput = screen.getByLabelText("Width");
634:       await user.type(widthInput, "48");
635: 
636:       const lengthInput = screen.getByLabelText("Length");
637:       await user.type(lengthInput, "96");
638: 
639:       const depthInput = screen.getByLabelText("Soil Depth");
640:       await user.type(depthInput, "12");
641: 
642: 
643:       const soilMixTextarea = screen.getByTestId("soil-mixture-selector");
644:       await user.type(soilMixTextarea, "Test soil mix");
645: 
646:       await waitFor(() => {
647:         expect(screen.getByText("Register Plant")).toBeInTheDocument();
648:       });
649: 
650:       const submitButton = screen.getByText("Register Plant");
651:       await user.click(submitButton);
652: 
653:       await waitFor(() => {
654:         expect(mockPlantService.addPlant).toHaveBeenCalledWith({
655:           varietyId: "tomato-1",
656:           varietyName: "Roma Tomato",
657:           name: undefined,
658:           plantedDate: expect.any(Date),
659:           currentStage: "germination",
660:           location: "Outdoor",
661:           container: 'Raised Bed - 48"W x 96"L x 12"D',
662:           soilMix: "Test soil mix",
663:           isActive: true,
664:           notes: [],
665:           reminderPreferences: {
666:             watering: true,
667:             fertilizing: true,
668:             observation: true,
669:             lighting: true,
670:             pruning: true,
671:           },
672:         });
673:       });
674: 
675:       expect(mockOnSuccess).toHaveBeenCalled();
676:     });
677: 
678:     it("submits form with valid data", async () => {
679:       mockPlantService.addPlant.mockResolvedValue("new-plant-id");
680: 
681:       renderForm();
682:       await waitFor(() => {
683:         expect(mockVarietyService.getAllVarieties).toHaveBeenCalled();
684:       });
685: 
686:       await fillRequiredFields(user);
687: 
688:       const dateInput = screen.getByLabelText(/planting date/i);
689:       await user.clear(dateInput);
690:       await user.type(dateInput, "2024-01-15");
691: 
692:       await waitFor(() => {
693:         expect(screen.getByText("Register Plant")).toBeInTheDocument();
694:       });
695: 
696:       const submitButton = screen.getByText("Register Plant");
697:       await user.click(submitButton);
698: 
699:       await waitFor(() => {
700:         expect(mockPlantService.addPlant).toHaveBeenCalledWith(
701:           expect.objectContaining({
702:             varietyId: "tomato-1",
703:             location: "Outdoor",
704:             plantedDate: expect.any(Date),
705:             soilMix: "Test soil mix",
706:             reminderPreferences: {
707:               watering: true,
708:               fertilizing: true,
709:               observation: true,
710:               lighting: true,
711:               pruning: true,
712:             },
713:           })
714:         );
715:       });
716:     });
717: 
718:     it("handles submission errors gracefully", async () => {
719:       const consoleError = jest.spyOn(console, "error").mockImplementation();
720:       mockPlantService.addPlant.mockRejectedValue(new Error("Database error"));
721: 
722:       renderForm();
723:       await waitFor(() => {
724:         expect(mockVarietyService.getAllVarieties).toHaveBeenCalled();
725:       });
726: 
727: 
728:       await fillRequiredFields(user);
729: 
730:       await waitFor(() => {
731:         expect(screen.getByText("Register Plant")).toBeInTheDocument();
732:       });
733: 
734:       const submitButton = screen.getByText("Register Plant");
735:       await user.click(submitButton);
736: 
737:       await waitFor(() => {
738:         expect(
739:           screen.getByText(/failed to register plant/i)
740:         ).toBeInTheDocument();
741:       });
742: 
743:       expect(mockOnSuccess).not.toHaveBeenCalled();
744:       consoleError.mockRestore();
745:     });
746: 
747:     it("shows loading state during submission", async () => {
748:       mockPlantService.addPlant.mockImplementation(
749:         () =>
750:           new Promise((resolve) =>
751:             setTimeout(() => resolve("new-plant-id"), 100)
752:           )
753:       );
754: 
755:       renderForm();
756:       await waitFor(() => {
757:         expect(mockVarietyService.getAllVarieties).toHaveBeenCalled();
758:       });
759: 
760: 
761:       await fillRequiredFields(user);
762: 
763:       await waitFor(() => {
764:         expect(screen.getByText("Register Plant")).toBeInTheDocument();
765:       });
766: 
767:       const submitButton = screen.getByText("Register Plant");
768:       await user.click(submitButton);
769: 
770: 
771:       expect(screen.getByText("Registering...")).toBeInTheDocument();
772: 
773:       await waitFor(() => {
774:         expect(mockOnSuccess).toHaveBeenCalled();
775:       });
776:     });
777:   });
778: 
779:   describe("Custom Variety Integration", () => {
780:     it("refreshes varieties after creating custom variety", async () => {
781:       renderForm();
782: 
783:       await waitFor(() => {
784:         expect(mockVarietyService.getAllVarieties).toHaveBeenCalled();
785:       });
786: 
787: 
788:       mockVarietyService.getAllVarieties.mockClear();
789: 
790:       const customVarietyButton = screen.getByText("➕ Create Custom Variety");
791:       await user.click(customVarietyButton);
792: 
793:       const saveButton = screen.getByText("Save Variety");
794:       await user.click(saveButton);
795: 
796: 
797:       await waitFor(() => {
798:         expect(mockVarietyService.getAllVarieties).toHaveBeenCalled();
799:       });
800:     });
801:   });
802: 
803:   describe("Initial State", () => {
804:     it("has empty form initially", async () => {
805:       renderForm();
806: 
807:       await waitFor(() => {
808:         expect(mockVarietyService.getAllVarieties).toHaveBeenCalled();
809:       });
810: 
811:       const varietySelect = screen.getByLabelText(
812:         /plant variety/i
813:       ) as HTMLSelectElement;
814:       expect(varietySelect.value).toBe("");
815:     });
816:   });
817: 
818:   describe("Cancel Functionality", () => {
819:     it("calls onCancel when cancel button is clicked", async () => {
820:       renderForm();
821: 
822:       await waitFor(() => {
823:         expect(mockVarietyService.getAllVarieties).toHaveBeenCalled();
824:       });
825: 
826:       const cancelButton = screen.getByText("Cancel");
827:       await user.click(cancelButton);
828: 
829:       expect(mockOnCancel).toHaveBeenCalled();
830:     });
831: 
832:     it("does not render cancel button when onCancel is not provided", () => {
833:       render(<PlantRegistrationForm />);
834: 
835:       expect(screen.queryByText("Cancel")).not.toBeInTheDocument();
836:     });
837:   });
838: 
839:   describe("Accessibility", () => {
840:     it("has proper form labels and structure", async () => {
841:       renderForm();
842: 
843:       await waitFor(() => {
844:         expect(mockVarietyService.getAllVarieties).toHaveBeenCalled();
845:       });
846: 
847: 
848:       expect(screen.getByLabelText(/plant variety/i)).toBeInTheDocument();
849:       expect(screen.getByLabelText(/plant name/i)).toBeInTheDocument();
850:       expect(screen.getByLabelText(/planting date/i)).toBeInTheDocument();
851: 
852: 
853:       expect(screen.getByLabelText(/location/i)).toBeInTheDocument();
854:       expect(screen.getByText("Location *")).toBeInTheDocument();
855: 
856:       expect(screen.getByLabelText(/soil mix/i)).toBeInTheDocument();
857:       expect(screen.getByLabelText(/notes/i)).toBeInTheDocument();
858: 
859: 
860:       expect(screen.getByText("Plant Variety *")).toBeInTheDocument();
861:       expect(screen.getByText("Planting Date *")).toBeInTheDocument();
862:       expect(screen.getByText("Location *")).toBeInTheDocument();
863:     });
864: 
865:     it("shows appropriate button text and states based on form validity", async () => {
866:       renderForm();
867: 
868:       await waitFor(() => {
869:         expect(mockVarietyService.getAllVarieties).toHaveBeenCalled();
870:       });
871: 
872: 
873:       expect(screen.getByText("Complete Required Fields")).toBeInTheDocument();
874:       expect(screen.queryByText("Register Plant")).not.toBeInTheDocument();
875: 
876:       const invalidSubmitButton = screen.getByRole("button", {
877:         name: /complete required fields/i,
878:       });
879:       expect(invalidSubmitButton).toBeDisabled();
880: 
881: 
882:       await fillRequiredFields(user);
883: 
884: 
885:       await waitFor(() => {
886:         expect(screen.getByText("Register Plant")).toBeInTheDocument();
887:       });
888: 
889:       expect(
890:         screen.queryByText("Complete Required Fields")
891:       ).not.toBeInTheDocument();
892: 
893:       const validSubmitButton = screen.getByText("Register Plant");
894:       expect(validSubmitButton).not.toBeDisabled();
895:     });
896:   });
897: 
898:   describe("Success Notifications", () => {
899:     it("should show success notification when custom variety is created", async () => {
900: 
901: 
902:       expect(typeof mockToast.success).toBe("function");
903:     });
904:   });
905: });

================
File: src/__tests__/database/integration.test.ts
================
  1: import {
  2:   plantService,
  3:   varietyService,
  4:   careService,
  5: } from "../../types/database";
  6: import { initializeDatabase } from "../../db/seedData";
  7: 
  8: describe("Database Integration", () => {
  9:   beforeEach(async () => {
 10: 
 11:     const { db } = await import("../../types/database");
 12:     await db.plants.clear();
 13:     await db.varieties.clear();
 14:     await db.careActivities.clear();
 15:     await db.syncQueue.clear();
 16:   });
 17: 
 18:   describe("Database initialization", () => {
 19:     it("seeds varieties correctly", async () => {
 20:       await initializeDatabase();
 21: 
 22:       const varieties = await varietyService.getAllVarieties();
 23:       expect(varieties.length).toBeGreaterThan(0);
 24:       expect(varieties.some((v) => v.name === "Little Finger Carrots")).toBe(
 25:         true
 26:       );
 27:       expect(varieties.some((v) => v.name === "Astro Arugula")).toBe(true);
 28:     });
 29: 
 30:     it("does not duplicate varieties on re-initialization", async () => {
 31:       await initializeDatabase();
 32:       const firstCount = (await varietyService.getAllVarieties()).length;
 33: 
 34:       await initializeDatabase();
 35:       const secondCount = (await varietyService.getAllVarieties()).length;
 36: 
 37:       expect(firstCount).toBe(secondCount);
 38:     });
 39:   });
 40: 
 41:   describe("Plant lifecycle", () => {
 42:     beforeEach(async () => {
 43:       await initializeDatabase();
 44:     });
 45: 
 46:     it("creates plant with care activities", async () => {
 47:       const varieties = await varietyService.getAllVarieties();
 48:       const arugula = varieties.find((v) => v.name.includes("Arugula"));
 49: 
 50:       expect(arugula).toBeDefined();
 51: 
 52:       const plantId = await plantService.addPlant({
 53:         varietyId: arugula!.id,
 54:         varietyName: arugula!.name,
 55:         name: "Test Arugula",
 56:         plantedDate: new Date("2024-01-01"),
 57:         currentStage: "seedling",
 58:         location: "Test Location",
 59:         container: "Test Container",
 60:         isActive: true,
 61:       });
 62: 
 63: 
 64:       const careId = await careService.addCareActivity({
 65:         plantId,
 66:         type: "water",
 67:         date: new Date("2024-01-02"),
 68:         details: {
 69:           type: "water",
 70:           amount: "200ml",
 71:           moistureReading: {
 72: 
 73:             before: 3,
 74:             after: 7,
 75:             scale: "1-10" as const,
 76:           },
 77:         },
 78:       });
 79: 
 80: 
 81:       const plant = await plantService.getPlant(plantId);
 82:       const careHistory = await careService.getPlantCareHistory(plantId);
 83: 
 84:       expect(plant).toBeDefined();
 85:       expect(plant?.name).toBe("Test Arugula");
 86:       expect(careHistory).toHaveLength(1);
 87:       expect(careHistory[0].id).toBe(careId);
 88:     });
 89: 
 90:     it("handles storage quota exceeded gracefully", async () => {
 91: 
 92:       const originalAdd = plantService.addPlant;
 93:       plantService.addPlant = jest
 94:         .fn()
 95:         .mockRejectedValue(new Error("QuotaExceededError"));
 96: 
 97:       await expect(
 98:         plantService.addPlant({
 99:           varietyId: "test",
100:           varietyName: "Test Variety",
101:           plantedDate: new Date(),
102:           currentStage: "seedling",
103:           location: "test",
104:           container: "test",
105:           isActive: true,
106:         })
107:       ).rejects.toThrow("QuotaExceededError");
108: 
109: 
110:       plantService.addPlant = originalAdd;
111:     });
112:   });
113: 
114:   describe("Sync queue behavior", () => {
115:     it("queues operations correctly", async () => {
116:       const plantId = await plantService.addPlant({
117:         varietyId: "test-variety",
118:         varietyName: "Test Variety Name",
119:         plantedDate: new Date(),
120:         currentStage: "germination",
121:         location: "test",
122:         container: "test",
123:         isActive: true,
124:       });
125: 
126: 
127:       const { db } = await import("../../types/database");
128:       const queueItems = await db.syncQueue.toArray();
129: 
130:       expect(queueItems.length).toBeGreaterThan(0);
131:       expect(
132:         queueItems.some(
133:           (item) =>
134:             item.table === "plants" &&
135:             item.operation === "create" &&
136:             item.recordId === plantId
137:         )
138:       ).toBe(true);
139:     });
140: 
141:     it("queues care activity operations", async () => {
142: 
143:       const plantId = await plantService.addPlant({
144:         varietyId: "test-variety",
145:         varietyName: "Test Variety Name",
146:         plantedDate: new Date(),
147:         currentStage: "germination",
148:         location: "test",
149:         container: "test",
150:         isActive: true,
151:       });
152: 
153: 
154:       const careId = await careService.addCareActivity({
155:         plantId,
156:         type: "harvest",
157:         date: new Date(),
158:         details: {
159:           type: "harvest",
160:           amount: "200g",
161:           quality: "good",
162:         },
163:       });
164: 
165: 
166:       const { db } = await import("../../types/database");
167:       const queueItems = await db.syncQueue.toArray();
168: 
169:       expect(queueItems.length).toBe(2);
170:       expect(
171:         queueItems.some(
172:           (item) =>
173:             item.table === "careActivities" &&
174:             item.operation === "create" &&
175:             item.recordId === careId
176:         )
177:       ).toBe(true);
178:     });
179:   });
180: });

================
File: src/__tests__/database/varietyService.test.ts
================
  1: import { varietyService } from "../../types/database";
  2: import { initializeDatabase } from "../../db/seedData";
  3: import { seedVarieties } from "../../data/seedVarieties";
  4: 
  5: describe("varietyService", () => {
  6:   beforeEach(async () => {
  7: 
  8:     const db = await import("../../types/database").then((m) => m.db);
  9:     await db.varieties.clear();
 10:   });
 11: 
 12:   describe("seedVarieties data integrity", () => {
 13:     it("should have valid growth timelines for all varieties", () => {
 14:       seedVarieties.forEach((variety) => {
 15:         expect(variety.growthTimeline.germination).toBeGreaterThanOrEqual(0);
 16:         expect(variety.growthTimeline.seedling).toBeGreaterThan(0);
 17:         expect(variety.growthTimeline.vegetative).toBeGreaterThan(0);
 18:         expect(variety.growthTimeline.maturation).toBeGreaterThan(0);
 19: 
 20: 
 21: 
 22:         expect(variety.growthTimeline.maturation).toBeLessThan(2000);
 23: 
 24: 
 25:         expect(variety.growthTimeline.germination).toBeLessThanOrEqual(
 26:           variety.growthTimeline.seedling
 27:         );
 28:       });
 29:     });
 30: 
 31:     it("should have valid categories for all varieties", () => {
 32:       const validCategories = [
 33:         "root-vegetables",
 34:         "leafy-greens",
 35:         "herbs",
 36:         "berries",
 37:         "fruiting-plants",
 38:       ];
 39: 
 40:       seedVarieties.forEach((variety) => {
 41:         expect(validCategories).toContain(variety.category);
 42:       });
 43:     });
 44: 
 45:     it("should have productive lifespan for everbearing varieties", () => {
 46:       const everbearingVarieties = seedVarieties.filter((v) => v.isEverbearing);
 47: 
 48:       everbearingVarieties.forEach((variety) => {
 49:         expect(variety.productiveLifespan).toBeDefined();
 50:         expect(variety.productiveLifespan).toBeGreaterThan(0);
 51:       });
 52:     });
 53:   });
 54: 
 55:   describe("comprehensive variety coverage", () => {
 56:     beforeEach(async () => {
 57:       await initializeDatabase();
 58:     });
 59: 
 60:     it("should include all expected varieties from the comprehensive plan", async () => {
 61:       const varieties = await varietyService.getAllVarieties();
 62:       const varietyNames = varieties.map((v) => v.name);
 63: 
 64: 
 65:       expect(varietyNames).toContain("Little Finger Carrots");
 66:       expect(varietyNames).toContain("Detroit Dark Red Beets");
 67:       expect(varietyNames).toContain("Beauregard Sweet Potatoes");
 68: 
 69: 
 70:       expect(varietyNames).toContain("Astro Arugula");
 71:       expect(varietyNames).toContain("Baby's Leaf Spinach");
 72: 
 73: 
 74:       expect(varietyNames).toContain("Greek Oregano");
 75:       expect(varietyNames).toContain("English Thyme");
 76:       expect(varietyNames).toContain("Rosemary");
 77:       expect(varietyNames).toContain("Italian Flat Leaf Parsley");
 78:       expect(varietyNames).toContain("Greek Dwarf Basil");
 79: 
 80: 
 81:       expect(varietyNames).toContain("Albion Strawberries");
 82:       expect(varietyNames).toContain("Caroline Raspberries");
 83: 
 84: 
 85:       expect(varietyNames).toContain("Boston Pickling Cucumber");
 86:       expect(varietyNames).toContain("Sugar Snap Peas");
 87:     });
 88: 
 89:     it("should include lettuce varieties", async () => {
 90:       const varieties = await varietyService.getAllVarieties();
 91:       const varietyNames = varieties.map((v) => v.name);
 92: 
 93: 
 94:       const lettuceVarieties = varietyNames.filter(
 95:         (name) =>
 96:           name.toLowerCase().includes("lettuce") ||
 97:           name.toLowerCase().includes("may queen") ||
 98:           name.toLowerCase().includes("butter")
 99:       );
100: 
101: 
102: 
103: 
104:       expect(lettuceVarieties.length).toBeGreaterThan(0);
105:     });
106: 
107:     it("should have comprehensive protocols for complex varieties", async () => {
108:       const varieties = await varietyService.getAllVarieties();
109: 
110: 
111:       const strawberries = varieties.find(
112:         (v) => v.name === "Albion Strawberries"
113:       );
114:       expect(strawberries?.protocols?.lighting).toBeDefined();
115:       expect(strawberries?.protocols?.watering).toBeDefined();
116:       expect(strawberries?.protocols?.fertilization).toBeDefined();
117:       expect(strawberries?.protocols?.environment).toBeDefined();
118:       expect(strawberries?.protocols?.soilMixture).toBeDefined();
119:       expect(strawberries?.protocols?.specialRequirements).toBeDefined();
120: 
121: 
122:       const cucumber = varieties.find(
123:         (v) => v.name === "Boston Pickling Cucumber"
124:       );
125:       expect(cucumber?.protocols?.lighting?.seedling?.ppfd).toBeDefined();
126:       expect(cucumber?.protocols?.lighting?.flowering?.notes).toBeDefined();
127:       expect(cucumber?.protocols?.watering?.seedling?.trigger).toBeDefined();
128:     });
129: 
130:     it("should correctly categorize varieties", async () => {
131:       const varieties = await varietyService.getAllVarieties();
132: 
133:       const rootVegetables = varieties.filter(
134:         (v) => v.category === "root-vegetables"
135:       );
136:       const leafyGreens = varieties.filter(
137:         (v) => v.category === "leafy-greens"
138:       );
139:       const herbs = varieties.filter((v) => v.category === "herbs");
140:       const berries = varieties.filter((v) => v.category === "berries");
141:       const fruitingPlants = varieties.filter(
142:         (v) => v.category === "fruiting-plants"
143:       );
144: 
145:       expect(rootVegetables.length).toBeGreaterThan(0);
146:       expect(leafyGreens.length).toBeGreaterThan(0);
147:       expect(herbs.length).toBeGreaterThan(0);
148:       expect(berries.length).toBeGreaterThan(0);
149:       expect(fruitingPlants.length).toBeGreaterThan(0);
150: 
151: 
152:       expect(
153:         rootVegetables.some((v) => v.name === "Little Finger Carrots")
154:       ).toBe(true);
155:       expect(leafyGreens.some((v) => v.name === "Astro Arugula")).toBe(true);
156:       expect(herbs.some((v) => v.name === "English Thyme")).toBe(true);
157:       expect(berries.some((v) => v.name === "Albion Strawberries")).toBe(true);
158:       expect(
159:         fruitingPlants.some((v) => v.name === "Boston Pickling Cucumber")
160:       ).toBe(true);
161:     });
162: 
163:     it("should list all available varieties for debugging", async () => {
164:       const varieties = await varietyService.getAllVarieties();
165: 
166: 
167: 
168: 
169: 
170:       expect(varieties.length).toBeGreaterThan(0);
171:     });
172:   });
173: 
174:   describe("protocol structure validation", () => {
175:     beforeEach(async () => {
176:       await initializeDatabase();
177:     });
178: 
179:     it("should have valid lighting protocols where present", async () => {
180:       const varieties = await varietyService.getAllVarieties();
181: 
182:       varieties.forEach((variety) => {
183:         if (variety.protocols?.lighting) {
184:           Object.entries(variety.protocols.lighting).forEach(([, protocol]) => {
185:             expect(protocol.ppfd?.min).toBeGreaterThan(0);
186:             expect(protocol.ppfd?.max).toBeGreaterThanOrEqual(
187:               protocol.ppfd.min
188:             );
189:             expect(protocol.ppfd?.unit).toBe("µmol/m²/s");
190:             expect(protocol.photoperiod?.hours).toBeGreaterThan(0);
191:             expect(protocol.photoperiod?.hours).toBeLessThanOrEqual(24);
192:             expect(protocol.dli?.min).toBeGreaterThan(0);
193:             expect(protocol.dli?.max).toBeGreaterThanOrEqual(protocol.dli.min);
194:             expect(protocol.dli?.unit).toBe("mol/m²/day");
195: 
196: 
197: 
198: 
199:           });
200:         }
201:       });
202:     });
203: 
204:     it("should have valid watering protocols where present", async () => {
205:       const varieties = await varietyService.getAllVarieties();
206: 
207:       varieties.forEach((variety) => {
208:         if (variety.protocols?.watering) {
209:           Object.entries(variety.protocols.watering).forEach(([, protocol]) => {
210:             expect(protocol.trigger?.moistureLevel).toBeDefined();
211:             expect(protocol.target?.moistureLevel).toBeDefined();
212:             expect(protocol.volume?.amount).toBeDefined();
213:             expect(protocol.volume?.frequency).toBeDefined();
214: 
215: 
216: 
217: 
218:           });
219:         }
220:       });
221:     });
222: 
223:     it("should have valid soil mixture percentages where present", async () => {
224:       const varieties = await varietyService.getAllVarieties();
225: 
226:       varieties.forEach((variety) => {
227:         if (variety.protocols?.soilMixture?.components) {
228:           const percentages = Object.values(
229:             variety.protocols.soilMixture.components
230:           );
231:           const total = percentages.reduce((sum, pct) => sum + pct, 0);
232: 
233: 
234:           expect(total).toBeCloseTo(100, 1);
235: 
236:           percentages.forEach((pct) => {
237:             expect(pct).toBeGreaterThan(0);
238:             expect(pct).toBeLessThanOrEqual(100);
239:           });
240:         }
241:       });
242:     });
243: 
244:     it("should have valid pH ranges where present", async () => {
245:       const varieties = await varietyService.getAllVarieties();
246: 
247:       varieties.forEach((variety) => {
248:         if (variety.protocols?.environment?.pH) {
249:           const { min, max, optimal } = variety.protocols.environment.pH;
250:           expect(min).toBeGreaterThan(0);
251:           expect(min).toBeLessThan(14);
252:           expect(max).toBeGreaterThan(min);
253:           expect(max).toBeLessThan(14);
254: 
255:           if (optimal) {
256:             expect(optimal).toBeGreaterThanOrEqual(min);
257:             expect(optimal).toBeLessThanOrEqual(max);
258:           }
259:         }
260:       });
261:     });
262:   });
263: 
264:   describe("perennial herb maturation times", () => {
265:     it("should handle long maturation times for perennial herbs", () => {
266: 
267:       const rosemary = seedVarieties.find((v) => v.name === "Rosemary");
268:       expect(rosemary?.growthTimeline.maturation).toBe(730);
269: 
270: 
271:       const thyme = seedVarieties.find((v) => v.name === "English Thyme");
272:       expect(thyme?.growthTimeline.maturation).toBe(365);
273: 
274: 
275:       const oregano = seedVarieties.find((v) => v.name === "Greek Oregano");
276:       expect(oregano?.growthTimeline.maturation).toBeLessThan(120);
277:     });
278:   });
279: 
280:   describe("duplicate detection", () => {
281:     it("should not have duplicate varieties after initialization", async () => {
282:       await initializeDatabase();
283: 
284:       const varieties = await varietyService.getAllVarieties();
285:       const varietyNames = varieties.map((v) => v.name);
286:       const uniqueNames = new Set(varietyNames);
287: 
288:       if (varietyNames.length !== uniqueNames.size) {
289:         console.error("Duplicate varieties found:");
290:         const duplicates = varietyNames.filter(
291:           (name, index) => varietyNames.indexOf(name) !== index
292:         );
293:         console.error("Duplicates:", [...new Set(duplicates)]);
294:         console.error("All varieties:", varietyNames);
295:       }
296: 
297:       expect(varietyNames.length).toBe(uniqueNames.size);
298:     });
299: 
300:     it("should not create duplicates when initialization is called multiple times", async () => {
301:       await initializeDatabase();
302:       await initializeDatabase();
303:       await initializeDatabase();
304: 
305:       const varieties = await varietyService.getAllVarieties();
306:       const varietyNames = varieties.map((v) => v.name);
307:       const uniqueNames = new Set(varietyNames);
308: 
309:       if (varietyNames.length !== uniqueNames.size) {
310:         console.error(
311:           "Duplicate varieties found after multiple initializations:"
312:         );
313:         const duplicates = varietyNames.filter(
314:           (name, index) => varietyNames.indexOf(name) !== index
315:         );
316:         console.error("Duplicates:", [...new Set(duplicates)]);
317:       }
318: 
319:       expect(varietyNames.length).toBe(uniqueNames.size);
320:     });
321: 
322:     it("should handle existing database state correctly", async () => {
323: 
324:       await varietyService.addVariety({
325:         name: "Test Variety",
326:         category: "herbs",
327:         growthTimeline: {
328:           germination: 7,
329:           seedling: 14,
330:           vegetative: 21,
331:           maturation: 60,
332:         },
333:       });
334: 
335:       const beforeCount = (await varietyService.getAllVarieties()).length;
336: 
337: 
338:       await initializeDatabase();
339: 
340:       const afterCount = (await varietyService.getAllVarieties()).length;
341:       const varieties = await varietyService.getAllVarieties();
342: 
343: 
344:       expect(afterCount).toBe(beforeCount + seedVarieties.length);
345:       expect(varieties.some((v) => v.name === "Test Variety")).toBe(true);
346:     });
347:   });
348: 
349:   describe("everbearing varieties", () => {
350:     beforeEach(async () => {
351:       await initializeDatabase();
352:     });
353: 
354:     it("should correctly identify everbearing varieties", async () => {
355:       const varieties = await varietyService.getAllVarieties();
356: 
357:       const everbearingVarieties = varieties.filter(
358:         (v) => seedVarieties.find((sv) => sv.name === v.name)?.isEverbearing
359:       );
360: 
361: 
362:       const everbearingNames = everbearingVarieties.map((v) => v.name);
363:       expect(everbearingNames).toContain("Albion Strawberries");
364:       expect(everbearingNames).toContain("Caroline Raspberries");
365:       expect(everbearingNames).toContain("Astro Arugula");
366:     });
367: 
368:     it("should have succession protocols for appropriate varieties", async () => {
369:       const varieties = await varietyService.getAllVarieties();
370: 
371:       const arugula = varieties.find((v) => v.name === "Astro Arugula");
372:       const carrotProtocols = seedVarieties.find(
373:         (v) => v.name === "Little Finger Carrots"
374:       )?.protocols;
375: 
376: 
377:       expect(arugula).toBeDefined();
378: 
379: 
380:       expect(carrotProtocols?.succession).toBeDefined();
381:       expect(carrotProtocols?.succession?.interval).toBeGreaterThan(0);
382:     });
383:   });
384: 
385:   describe("comprehensive protocol features", () => {
386:     beforeEach(async () => {
387:       await initializeDatabase();
388:     });
389: 
390:     it("should have stage-specific fertilization protocols", async () => {
391:       const varieties = await varietyService.getAllVarieties();
392:       const strawberries = varieties.find(
393:         (v) => v.name === "Albion Strawberries"
394:       );
395: 
396:       if (strawberries?.protocols?.fertilization) {
397:         Object.entries(strawberries.protocols.fertilization).forEach(
398:           ([, protocol]) => {
399:             if (protocol.products && protocol.products.length > 0) {
400:               protocol.products.forEach((product) => {
401:                 expect(product.name).toBeDefined();
402:                 expect(product.dilution).toBeDefined();
403:                 expect(product.frequency).toBeDefined();
404:               });
405:             }
406:           }
407:         );
408:       }
409:     });
410: 
411:     it("should have container requirements for varieties", async () => {
412:       const varieties = await varietyService.getAllVarieties();
413:       const cucumber = varieties.find(
414:         (v) => v.name === "Boston Pickling Cucumber"
415:       );
416: 
417:       expect(cucumber?.protocols?.container?.depth).toBeDefined();
418:       expect(cucumber?.protocols?.specialRequirements).toBeDefined();
419:       expect(cucumber?.protocols?.specialRequirements?.length).toBeGreaterThan(
420:         0
421:       );
422:     });
423: 
424:     it("should have environmental constraints for sensitive varieties", async () => {
425:       const varieties = await varietyService.getAllVarieties();
426:       const carrots = varieties.find((v) => v.name === "Little Finger Carrots");
427: 
428:       if (carrots?.protocols?.environment?.constraints) {
429:         carrots.protocols.environment.constraints.forEach((constraint) => {
430:           expect(constraint.description).toBeDefined();
431:           expect(constraint.parameter).toBeDefined();
432:           expect(constraint.consequence).toBeDefined();
433:         });
434:       }
435:     });
436:   });
437: });

================
File: src/__tests__/integration/smartDefaultsIntegration.test.tsx
================
  1: import { render, screen, waitFor } from "@testing-library/react";
  2: import userEvent from "@testing-library/user-event";
  3: import { MemoryRouter } from "react-router-dom";
  4: import { CareLogForm } from "@/pages/care/CareLogForm";
  5: import { initializeDatabase } from "@/db/seedData";
  6: import { plantService, varietyService } from "@/types/database";
  7: 
  8: 
  9: jest.mock("@/types/database", () => {
 10:   const originalModule = jest.requireActual("@/types/database");
 11:   return {
 12:     ...originalModule,
 13:     plantService: {
 14:       ...originalModule.plantService,
 15:       getActivePlants: jest.fn(),
 16:     },
 17:   };
 18: });
 19: 
 20: const renderWithRouter = (
 21:   component: React.ReactElement,
 22:   initialEntries: string[] = ["/log-care"]
 23: ) => {
 24:   return render(
 25:     <MemoryRouter initialEntries={initialEntries}>{component}</MemoryRouter>
 26:   );
 27: };
 28: 
 29: describe("Smart Defaults Integration", () => {
 30:   beforeEach(async () => {
 31:     await initializeDatabase();
 32:     const { db } = await import("@/types/database");
 33:     await db.plants.clear();
 34: 
 35: 
 36:     jest.clearAllMocks();
 37:   });
 38: 
 39:   it("should show smart watering suggestions when plant is selected", async () => {
 40:     const varieties = await varietyService.getAllVarieties();
 41: 
 42: 
 43:     const testVariety = varieties.find(
 44:       (v) =>
 45:         v.category === "fruiting-plants" &&
 46:         (v.name.toLowerCase().includes("cucumber") ||
 47:           v.name.toLowerCase().includes("peas"))
 48:     );
 49: 
 50:     console.log(
 51:       "Available varieties:",
 52:       varieties.map((v) => ({ name: v.name, category: v.category }))
 53:     );
 54:     expect(testVariety).toBeDefined();
 55: 
 56: 
 57:     const plantId = await plantService.addPlant({
 58:       varietyId: testVariety!.id,
 59:       varietyName: testVariety!.name,
 60:       name: "Test Plant",
 61:       plantedDate: new Date(),
 62:       currentStage: "vegetative",
 63:       location: "Indoor",
 64:       container: "5 gallon pot",
 65:       isActive: true,
 66:     });
 67: 
 68: 
 69:     const createdPlant = await plantService.getPlant(plantId);
 70:     expect(createdPlant).toBeDefined();
 71: 
 72: 
 73:     const mockGetActivePlants =
 74:       plantService.getActivePlants as jest.MockedFunction<
 75:         typeof plantService.getActivePlants
 76:       >;
 77:     mockGetActivePlants.mockResolvedValue([createdPlant!]);
 78: 
 79:     const mockOnSuccess = jest.fn();
 80:     const user = userEvent.setup();
 81: 
 82:     renderWithRouter(<CareLogForm onSuccess={mockOnSuccess} />);
 83: 
 84:     await waitFor(() => {
 85:       expect(screen.getByLabelText(/Plant/i)).toBeInTheDocument();
 86:     });
 87: 
 88: 
 89:     await waitFor(() => {
 90:       const plantSelect = screen.getByLabelText(/Plant/i) as HTMLSelectElement;
 91:       const options = Array.from(plantSelect.options).map(
 92:         (option) => option.value
 93:       );
 94:       expect(options).toContain(plantId);
 95:     });
 96: 
 97:     const plantSelect = screen.getByLabelText(/Plant/i);
 98:     await user.selectOptions(plantSelect, plantId);
 99: 
100: 
101:     await waitFor(() => {
102:       const smartSuggestions = screen.queryByText(/Smart Suggestion/i);
103:       if (smartSuggestions) {
104:         expect(smartSuggestions).toBeInTheDocument();
105:       } else {
106: 
107:         expect(screen.getByPlaceholderText("Amount")).toBeInTheDocument();
108:       }
109:     });
110:   });
111: 
112:   it("should auto-fill water amount when using smart suggestions", async () => {
113:     const varieties = await varietyService.getAllVarieties();
114: 
115: 
116:     const testVariety = varieties.find(
117:       (v) =>
118:         v.category === "fruiting-plants" &&
119:         (v.name.toLowerCase().includes("cucumber") ||
120:           v.name.toLowerCase().includes("peas"))
121:     );
122:     expect(testVariety).toBeDefined();
123: 
124:     const plantId = await plantService.addPlant({
125:       varietyId: testVariety!.id,
126:       varietyName: testVariety!.name,
127:       name: "Test Plant",
128:       plantedDate: new Date(),
129:       currentStage: "vegetative",
130:       location: "Indoor",
131:       container: "5 gallon pot",
132:       isActive: true,
133:     });
134: 
135:     const createdPlant = await plantService.getPlant(plantId);
136:     expect(createdPlant).toBeDefined();
137: 
138: 
139:     const mockGetActivePlants =
140:       plantService.getActivePlants as jest.MockedFunction<
141:         typeof plantService.getActivePlants
142:       >;
143:     mockGetActivePlants.mockResolvedValue([createdPlant!]);
144: 
145:     const mockOnSuccess = jest.fn();
146:     const user = userEvent.setup();
147: 
148:     renderWithRouter(<CareLogForm onSuccess={mockOnSuccess} />);
149: 
150:     await waitFor(() => {
151:       expect(screen.getByLabelText(/Plant/i)).toBeInTheDocument();
152:     });
153: 
154: 
155:     await waitFor(() => {
156:       const plantSelect = screen.getByLabelText(/Plant/i) as HTMLSelectElement;
157:       const options = Array.from(plantSelect.options).map(
158:         (option) => option.value
159:       );
160:       expect(options).toContain(plantId);
161:     });
162: 
163:     const plantSelect = screen.getByLabelText(/Plant/i);
164:     await user.selectOptions(plantSelect, plantId);
165: 
166: 
167:     await waitFor(() => {
168:       const waterAmountInput = screen.getByPlaceholderText(
169:         "Amount"
170:       ) as HTMLInputElement;
171:       expect(waterAmountInput).toBeInTheDocument();
172:     });
173:   });
174: 
175:   it("should show quick completion buttons", async () => {
176:     const varieties = await varietyService.getAllVarieties();
177: 
178: 
179:     const testVariety = varieties.find(
180:       (v) =>
181:         v.category === "fruiting-plants" &&
182:         (v.name.toLowerCase().includes("cucumber") ||
183:           v.name.toLowerCase().includes("peas"))
184:     );
185:     expect(testVariety).toBeDefined();
186: 
187:     const plantId = await plantService.addPlant({
188:       varietyId: testVariety!.id,
189:       varietyName: testVariety!.name,
190:       name: "Test Plant",
191:       plantedDate: new Date(),
192:       currentStage: "vegetative",
193:       location: "Indoor",
194:       container: "5 gallon pot",
195:       isActive: true,
196:     });
197: 
198:     const createdPlant = await plantService.getPlant(plantId);
199:     expect(createdPlant).toBeDefined();
200: 
201: 
202:     const mockGetActivePlants =
203:       plantService.getActivePlants as jest.MockedFunction<
204:         typeof plantService.getActivePlants
205:       >;
206:     mockGetActivePlants.mockResolvedValue([createdPlant!]);
207: 
208:     const user = userEvent.setup();
209: 
210:     renderWithRouter(<CareLogForm onSuccess={jest.fn()} />);
211: 
212:     await waitFor(() => {
213:       expect(screen.getByLabelText(/Plant/i)).toBeInTheDocument();
214:     });
215: 
216: 
217:     await waitFor(() => {
218:       const plantSelect = screen.getByLabelText(/Plant/i) as HTMLSelectElement;
219:       const options = Array.from(plantSelect.options).map(
220:         (option) => option.value
221:       );
222:       expect(options).toContain(plantId);
223:     });
224: 
225:     const plantSelect = screen.getByLabelText(/Plant/i);
226:     await user.selectOptions(plantSelect, plantId);
227: 
228: 
229:     await waitFor(() => {
230:       expect(screen.getByPlaceholderText("Amount")).toBeInTheDocument();
231:     });
232:   });
233: 
234:   it("should show fertilizer suggestions when fertilizer activity is selected", async () => {
235:     const varieties = await varietyService.getAllVarieties();
236: 
237: 
238:     const testVariety = varieties.find(
239:       (v) =>
240:         v.category === "fruiting-plants" &&
241:         (v.name.toLowerCase().includes("cucumber") ||
242:           v.name.toLowerCase().includes("peas"))
243:     );
244:     expect(testVariety).toBeDefined();
245: 
246:     const plantId = await plantService.addPlant({
247:       varietyId: testVariety!.id,
248:       varietyName: testVariety!.name,
249:       name: "Test Plant",
250:       plantedDate: new Date(),
251:       currentStage: "vegetative",
252:       location: "Indoor",
253:       container: "5 gallon pot",
254:       isActive: true,
255:     });
256: 
257:     const createdPlant = await plantService.getPlant(plantId);
258:     expect(createdPlant).toBeDefined();
259: 
260: 
261:     const mockGetActivePlants =
262:       plantService.getActivePlants as jest.MockedFunction<
263:         typeof plantService.getActivePlants
264:       >;
265:     mockGetActivePlants.mockResolvedValue([createdPlant!]);
266: 
267:     const user = userEvent.setup();
268: 
269:     renderWithRouter(<CareLogForm onSuccess={jest.fn()} />);
270: 
271:     await waitFor(() => {
272:       expect(screen.getByLabelText(/Plant/i)).toBeInTheDocument();
273:     });
274: 
275: 
276:     await waitFor(() => {
277:       const plantSelect = screen.getByLabelText(/Plant/i) as HTMLSelectElement;
278:       const options = Array.from(plantSelect.options).map(
279:         (option) => option.value
280:       );
281:       expect(options).toContain(plantId);
282:     });
283: 
284:     const plantSelect = screen.getByLabelText(/Plant/i);
285:     await user.selectOptions(plantSelect, plantId);
286: 
287: 
288:     const activitySelect = screen.getByLabelText(/Activity Type/i);
289:     await user.selectOptions(activitySelect, "fertilize");
290: 
291: 
292:     await waitFor(() => {
293:       expect(screen.getByLabelText(/Fertilizer Product/i)).toBeInTheDocument();
294:       expect(screen.getByLabelText(/Dilution Ratio/i)).toBeInTheDocument();
295:       expect(screen.getByLabelText(/Application Amount/i)).toBeInTheDocument();
296:     });
297:   });
298: });

================
File: src/__tests__/services/smartDefaultsService.test.ts
================
  1: import { SmartDefaultsService } from "@/services/smartDefaultsService";
  2: import { varietyService, plantService, careService } from "@/types/database";
  3: import { initializeDatabase } from "@/db/seedData";
  4: import { subDays } from "date-fns";
  5: 
  6: describe("SmartDefaultsService", () => {
  7:   beforeEach(async () => {
  8:     await initializeDatabase();
  9: 
 10:     const { db } = await import("@/types/database");
 11:     await db.plants.clear();
 12:     await db.careActivities.clear();
 13:   });
 14: 
 15:   describe("contextual defaults based on growth stage", () => {
 16:     it("provides different watering amounts for different growth stages", async () => {
 17:       const varieties = await varietyService.getAllVarieties();
 18:       const strawberry = varieties.find(
 19:         (v) =>
 20:           v.name.toLowerCase().includes("strawberry") ||
 21:           v.name.toLowerCase().includes("albion")
 22:       );
 23: 
 24:       if (!strawberry) {
 25: 
 26:         return;
 27:       }
 28: 
 29: 
 30:       const stages = ["seedling", "vegetative", "maturation"] as const;
 31:       const testResults: Array<{
 32:         stage: string;
 33:         amount: number;
 34:         confidence: string;
 35:       }> = [];
 36: 
 37:       for (const stage of stages) {
 38:         const plantId = await plantService.addPlant({
 39:           varietyId: strawberry.id,
 40:           varietyName: strawberry.name,
 41:           name: `Test Plant ${stage}`,
 42:           plantedDate: subDays(new Date(), 30),
 43:           currentStage: stage,
 44:           location: "Indoor",
 45:           container: "5 gallon pot",
 46:           isActive: true,
 47:         });
 48: 
 49:         const plant = await plantService.getPlant(plantId);
 50:         if (!plant) continue;
 51: 
 52:         const defaults = await SmartDefaultsService.getDefaultsForPlant(plant);
 53: 
 54:         if (defaults?.watering) {
 55:           testResults.push({
 56:             stage,
 57:             amount: defaults.watering.suggestedAmount,
 58:             confidence: defaults.watering.confidence,
 59:           });
 60:         }
 61:       }
 62: 
 63: 
 64:       expect(testResults.length).toBeGreaterThan(1);
 65: 
 66: 
 67:       for (const result of testResults) {
 68:         expect(result.amount).toBeGreaterThan(0);
 69:         expect(["high", "medium", "low"]).toContain(result.confidence);
 70:       }
 71:     });
 72: 
 73:     it("adjusts fertilizer recommendations based on plant maturity", async () => {
 74:       const varieties = await varietyService.getAllVarieties();
 75:       const varietyWithFertilizer = varieties.find(
 76:         (v) =>
 77:           v.protocols?.fertilization &&
 78:           Object.keys(v.protocols.fertilization).length > 0
 79:       );
 80: 
 81:       if (!varietyWithFertilizer) {
 82:         return;
 83:       }
 84: 
 85: 
 86:       const youngPlantId = await plantService.addPlant({
 87:         varietyId: varietyWithFertilizer.id,
 88:         varietyName: varietyWithFertilizer.name,
 89:         name: "Young Plant",
 90:         plantedDate: subDays(new Date(), 14),
 91:         currentStage: "seedling",
 92:         location: "Indoor",
 93:         container: "4 inch pot",
 94:         isActive: true,
 95:       });
 96: 
 97:       const maturePlantId = await plantService.addPlant({
 98:         varietyId: varietyWithFertilizer.id,
 99:         varietyName: varietyWithFertilizer.name,
100:         name: "Mature Plant",
101:         plantedDate: subDays(new Date(), 90),
102:         currentStage: "maturation",
103:         location: "Indoor",
104:         container: "5 gallon pot",
105:         isActive: true,
106:       });
107: 
108:       const [youngPlant, maturePlant] = await Promise.all([
109:         plantService.getPlant(youngPlantId),
110:         plantService.getPlant(maturePlantId),
111:       ]);
112: 
113:       if (!youngPlant || !maturePlant) {
114:         throw new Error("Plants not found");
115:       }
116: 
117:       const [youngDefaults, matureDefaults] = await Promise.all([
118:         SmartDefaultsService.getDefaultsForPlant(youngPlant),
119:         SmartDefaultsService.getDefaultsForPlant(maturePlant),
120:       ]);
121: 
122: 
123:       expect(youngDefaults).toBeTruthy();
124:       expect(matureDefaults).toBeTruthy();
125: 
126:       if (youngDefaults?.fertilizer && matureDefaults?.fertilizer) {
127:         expect(youngDefaults.fertilizer.products).toBeDefined();
128:         expect(matureDefaults.fertilizer.products).toBeDefined();
129: 
130: 
131:         expect(youngDefaults.fertilizer.reasoning).toMatch(
132:           /category|protocol|fertilization/i
133:         );
134:         expect(matureDefaults.fertilizer.reasoning).toMatch(
135:           /category|protocol|fertilization/i
136:         );
137: 
138: 
139:         expect(youngDefaults.fertilizer.products[0].name).toBeDefined();
140:         expect(matureDefaults.fertilizer.products[0].name).toBeDefined();
141:       }
142:     });
143: 
144:     it("provides stage-appropriate quick completion options", async () => {
145:       const varieties = await varietyService.getAllVarieties();
146:       const testVariety = varieties.find(
147:         (v) =>
148:           v.protocols?.watering && Object.keys(v.protocols.watering).length > 0
149:       );
150: 
151:       if (!testVariety) {
152:         return;
153:       }
154: 
155: 
156:       const plantId = await plantService.addPlant({
157:         varietyId: testVariety.id,
158:         varietyName: testVariety.name,
159:         name: "Vegetative Plant",
160:         plantedDate: subDays(new Date(), 30),
161:         currentStage: "vegetative",
162:         location: "Indoor",
163:         container: "5 gallon pot",
164:         isActive: true,
165:       });
166: 
167:       const plant = await plantService.getPlant(plantId);
168:       if (!plant) throw new Error("Plant not found");
169: 
170:       const wateringOptions =
171:         await SmartDefaultsService.getQuickCompletionOptions(plant, "water");
172: 
173:       expect(wateringOptions).toBeTruthy();
174:       if (wateringOptions) {
175:         expect(wateringOptions.length).toBeGreaterThan(0);
176: 
177: 
178:         expect(
179:           wateringOptions.some(
180:             (opt) =>
181:               opt.label.includes("Quick:") &&
182:               opt.values.waterValue &&
183:               opt.values.waterValue > 0
184:           )
185:         ).toBe(true);
186: 
187: 
188:         wateringOptions.forEach((option) => {
189:           expect(option.label).toBeDefined();
190:           expect(option.values).toBeDefined();
191:         });
192:       }
193:     });
194:   });
195: 
196:   describe("learning from plant history", () => {
197:     it("adjusts watering defaults based on previous care patterns", async () => {
198:       const varieties = await varietyService.getAllVarieties();
199:       const testVariety = varieties.find(
200:         (v) =>
201:           v.protocols?.watering && Object.keys(v.protocols.watering).length > 0
202:       );
203: 
204:       if (!testVariety) {
205:         return;
206:       }
207: 
208: 
209:       const plantId = await plantService.addPlant({
210:         varietyId: testVariety.id,
211:         varietyName: testVariety.name,
212:         name: "Plant with History",
213:         plantedDate: subDays(new Date(), 60),
214:         currentStage: "vegetative",
215:         location: "Indoor",
216:         container: "5 gallon pot",
217:         isActive: true,
218:       });
219: 
220: 
221:       const wateringDates = [
222:         subDays(new Date(), 14),
223:         subDays(new Date(), 11),
224:         subDays(new Date(), 8),
225:         subDays(new Date(), 5),
226:         subDays(new Date(), 2),
227:       ];
228: 
229:       for (const date of wateringDates) {
230:         await careService.addCareActivity({
231:           plantId,
232:           type: "water",
233:           date,
234:           details: {
235:             type: "water",
236:             amount: {
237:               value: 25,
238:               unit: "oz",
239:             },
240:             moistureReading: {
241:               before: 3,
242:               after: 7,
243:               scale: "1-10",
244:             },
245:             notes: "Regular watering",
246:           },
247:         });
248:       }
249: 
250:       const plant = await plantService.getPlant(plantId);
251:       if (!plant) throw new Error("Plant not found");
252: 
253:       const defaults = await SmartDefaultsService.getDefaultsForPlant(plant);
254: 
255:       expect(defaults).toBeTruthy();
256:       expect(defaults?.watering).toBeTruthy();
257: 
258:       if (defaults?.watering) {
259: 
260: 
261: 
262:         expect(defaults.watering.suggestedAmount).toBeGreaterThan(0);
263:         expect(defaults.watering.confidence).toBeDefined();
264:         expect(defaults.watering.source).toBeDefined();
265:       }
266:     });
267: 
268:     it("considers recent care frequency when suggesting next actions", async () => {
269:       const varieties = await varietyService.getAllVarieties();
270:       const testVariety = varieties[0];
271: 
272:       const plantId = await plantService.addPlant({
273:         varietyId: testVariety.id,
274:         varietyName: testVariety.name,
275:         name: "Recently Cared Plant",
276:         plantedDate: subDays(new Date(), 30),
277:         currentStage: "vegetative",
278:         location: "Indoor",
279:         container: "5 gallon pot",
280:         isActive: true,
281:       });
282: 
283: 
284:       await careService.addCareActivity({
285:         plantId,
286:         type: "water",
287:         date: subDays(new Date(), 1),
288:         details: {
289:           type: "water",
290:           amount: {
291:             value: 20,
292:             unit: "oz",
293:           },
294:           moistureReading: {
295:             before: 3,
296:             after: 7,
297:             scale: "1-10",
298:           },
299:           notes: "Recent watering",
300:         },
301:       });
302: 
303:       const plant = await plantService.getPlant(plantId);
304:       if (!plant) throw new Error("Plant not found");
305: 
306:       const quickOptions = await SmartDefaultsService.getQuickCompletionOptions(
307:         plant,
308:         "water"
309:       );
310: 
311: 
312: 
313:       expect(quickOptions).toBeTruthy();
314:       if (quickOptions && quickOptions.length > 0) {
315: 
316: 
317:         quickOptions.forEach((option) => {
318:           expect(option.label).toBeDefined();
319:           expect(option.values.waterValue).toBeGreaterThan(0);
320:         });
321:       }
322:     });
323: 
324:     it("provides category-based defaults for different plant types", async () => {
325:       const varieties = await varietyService.getAllVarieties();
326: 
327: 
328:       const leafyGreen = varieties.find((v) => v.category === "leafy-greens");
329:       const fruitingPlant = varieties.find(
330:         (v) => v.category === "fruiting-plants"
331:       );
332: 
333:       if (!leafyGreen || !fruitingPlant) {
334:         return;
335:       }
336: 
337: 
338:       const leafyPlantId = await plantService.addPlant({
339:         varietyId: leafyGreen.id,
340:         varietyName: leafyGreen.name,
341:         name: "Leafy Plant",
342:         plantedDate: subDays(new Date(), 30),
343:         currentStage: "vegetative",
344:         location: "Indoor",
345:         container: "4 inch pot",
346:         isActive: true,
347:       });
348: 
349:       const fruitingPlantId = await plantService.addPlant({
350:         varietyId: fruitingPlant.id,
351:         varietyName: fruitingPlant.name,
352:         name: "Fruiting Plant",
353:         plantedDate: subDays(new Date(), 30),
354:         currentStage: "vegetative",
355:         location: "Indoor",
356:         container: "5 gallon pot",
357:         isActive: true,
358:       });
359: 
360:       const [leafyPlant, fruitPlant] = await Promise.all([
361:         plantService.getPlant(leafyPlantId),
362:         plantService.getPlant(fruitingPlantId),
363:       ]);
364: 
365:       if (!leafyPlant || !fruitPlant) {
366:         throw new Error("Plants not found");
367:       }
368: 
369:       const [leafyDefaults, fruitDefaults] = await Promise.all([
370:         SmartDefaultsService.getDefaultsForPlant(leafyPlant),
371:         SmartDefaultsService.getDefaultsForPlant(fruitPlant),
372:       ]);
373: 
374: 
375:       expect(leafyDefaults).toBeTruthy();
376:       expect(fruitDefaults).toBeTruthy();
377: 
378:       if (leafyDefaults?.watering && fruitDefaults?.watering) {
379: 
380:         expect(fruitDefaults.watering.suggestedAmount).toBeGreaterThanOrEqual(
381:           leafyDefaults.watering.suggestedAmount
382:         );
383: 
384: 
385:         expect(leafyDefaults.watering.reasoning).toMatch(
386:           /leafy-greens|category/i
387:         );
388:         expect(fruitDefaults.watering.reasoning).toMatch(
389:           /fruiting-plants|category/i
390:         );
391:       }
392:     });
393: 
394:     it("maintains confidence levels based on data quality", async () => {
395:       const varieties = await varietyService.getAllVarieties();
396:       const varietyWithProtocol = varieties.find(
397:         (v) =>
398:           v.protocols?.watering && Object.keys(v.protocols.watering).length > 0
399:       );
400: 
401:       if (!varietyWithProtocol) {
402:         return;
403:       }
404: 
405: 
406:       const protocolPlantId = await plantService.addPlant({
407:         varietyId: varietyWithProtocol.id,
408:         varietyName: varietyWithProtocol.name,
409:         name: "Well-Documented Plant",
410:         plantedDate: subDays(new Date(), 30),
411:         currentStage: "vegetative",
412:         location: "Indoor",
413:         container: "5 gallon pot",
414:         isActive: true,
415:       });
416: 
417: 
418:       const simpleVariety = varieties.find((v) => !v.protocols?.watering);
419:       if (!simpleVariety) {
420:         return;
421:       }
422: 
423:       const simplePlantId = await plantService.addPlant({
424:         varietyId: simpleVariety.id,
425:         varietyName: simpleVariety.name,
426:         name: "Simple Plant",
427:         plantedDate: subDays(new Date(), 30),
428:         currentStage: "vegetative",
429:         location: "Indoor",
430:         container: "5 gallon pot",
431:         isActive: true,
432:       });
433: 
434:       const [protocolPlant, simplePlant] = await Promise.all([
435:         plantService.getPlant(protocolPlantId),
436:         plantService.getPlant(simplePlantId),
437:       ]);
438: 
439:       if (!protocolPlant || !simplePlant) {
440:         throw new Error("Plants not found");
441:       }
442: 
443:       const [protocolDefaults, simpleDefaults] = await Promise.all([
444:         SmartDefaultsService.getDefaultsForPlant(protocolPlant),
445:         SmartDefaultsService.getDefaultsForPlant(simplePlant),
446:       ]);
447: 
448:       if (protocolDefaults?.watering && simpleDefaults?.watering) {
449: 
450:         const confidenceOrder = { high: 3, medium: 2, low: 1 };
451: 
452:         expect(
453:           confidenceOrder[protocolDefaults.watering.confidence]
454:         ).toBeGreaterThanOrEqual(
455:           confidenceOrder[simpleDefaults.watering.confidence]
456:         );
457: 
458: 
459:         expect(protocolDefaults.watering.source).toBe("protocol");
460:         expect(simpleDefaults.watering.source).toMatch(/category|universal/);
461:       }
462:     });
463:   });
464: 
465:   describe("error handling and edge cases", () => {
466:     it("handles plants with invalid variety data gracefully", async () => {
467: 
468:       const plantId = await plantService.addPlant({
469:         varietyId: "non-existent-variety",
470:         varietyName: "Invalid Variety",
471:         name: "Test Plant",
472:         plantedDate: new Date(),
473:         currentStage: "vegetative",
474:         location: "Indoor",
475:         container: "5 gallon pot",
476:         isActive: true,
477:       });
478: 
479:       const plant = await plantService.getPlant(plantId);
480:       if (!plant) throw new Error("Plant not found");
481: 
482:       const defaults = await SmartDefaultsService.getDefaultsForPlant(plant);
483: 
484: 
485:       expect(defaults).toBeNull();
486:     });
487: 
488:     it("provides universal defaults when no specific protocol exists", async () => {
489:       const varieties = await varietyService.getAllVarieties();
490:       const minimalVariety = varieties.find(
491:         (v) => !v.protocols?.watering && !v.protocols?.fertilization
492:       );
493: 
494:       if (!minimalVariety) {
495:         return;
496:       }
497: 
498:       const plantId = await plantService.addPlant({
499:         varietyId: minimalVariety.id,
500:         varietyName: minimalVariety.name,
501:         name: "Minimal Protocol Plant",
502:         plantedDate: new Date(),
503:         currentStage: "vegetative",
504:         location: "Indoor",
505:         container: "5 gallon pot",
506:         isActive: true,
507:       });
508: 
509:       const plant = await plantService.getPlant(plantId);
510:       if (!plant) throw new Error("Plant not found");
511: 
512:       const defaults = await SmartDefaultsService.getDefaultsForPlant(plant);
513: 
514:       expect(defaults).toBeTruthy();
515:       if (defaults?.watering) {
516:         expect(defaults.watering.source).toMatch(/category|universal/);
517:         expect(defaults.watering.confidence).toBe("low");
518:         expect(defaults.watering.reasoning).toMatch(
519:           /category|general|default|universal/i
520:         );
521:       }
522:     });
523: 
524:     it("handles corrupted care log data without crashing", async () => {
525:       const varieties = await varietyService.getAllVarieties();
526:       const testVariety = varieties[0];
527: 
528:       const plantId = await plantService.addPlant({
529:         varietyId: testVariety.id,
530:         varietyName: testVariety.name,
531:         name: "Plant with Bad Data",
532:         plantedDate: subDays(new Date(), 30),
533:         currentStage: "vegetative",
534:         location: "Indoor",
535:         container: "5 gallon pot",
536:         isActive: true,
537:       });
538: 
539:       const plant = await plantService.getPlant(plantId);
540:       if (!plant) throw new Error("Plant not found");
541: 
542: 
543:       const defaults = await SmartDefaultsService.getDefaultsForPlant(plant);
544: 
545: 
546:       expect(defaults).toBeTruthy();
547:       expect(defaults?.currentStage).toBeDefined();
548:       expect(defaults?.daysSincePlanting).toBeGreaterThanOrEqual(0);
549:     });
550:   });
551: });

================
File: src/components/layouts/EmptyState.tsx
================
 1: import React from "react";
 2: import { Card, CardContent } from "@/components/ui/Card";
 3: import { Button } from "@/components/ui/Button";
 4: import { Link } from "react-router-dom";
 5: 
 6: interface EmptyStateProps {
 7:   title: string;
 8:   description: string;
 9:   icon: string;
10:   actionLabel: string;
11:   actionTo: string;
12:   showWelcome?: boolean;
13: }
14: 
15: const EmptyState: React.FC<EmptyStateProps> = ({
16:   title,
17:   description,
18:   icon,
19:   actionLabel,
20:   actionTo,
21:   showWelcome = false,
22: }) => {
23:   return (
24:     <div className="flex items-center justify-center min-h-96">
25:       <Card className="w-full max-w-md mx-4 shadow-sm border border-border">
26:         <CardContent className="text-center py-12 px-6 space-y-6">
27:           {showWelcome && (
28:             <div className="mb-8">
29:               <h1 className="text-3xl font-bold text-foreground mb-2">
30:                 🌱 Welcome to SmartGarden
31:               </h1>
32:               <p className="text-muted-foreground">
33:                 Your digital gardening companion
34:               </p>
35:             </div>
36:           )}
37: 
38:           <div className="text-6xl mb-4" role="img" aria-label={title}>
39:             {icon}
40:           </div>
41: 
42:           <div className="space-y-3">
43:             <h2 className="text-xl font-semibold text-foreground">{title}</h2>
44:             <p className="text-muted-foreground leading-relaxed">
45:               {description}
46:             </p>
47:           </div>
48: 
49:           <div className="pt-4">
50:             <Link to={actionTo} className="block">
51:               <Button size="lg" className="w-full">
52:                 {actionLabel}
53:               </Button>
54:             </Link>
55:           </div>
56: 
57:           {showWelcome && (
58:             <div className="pt-6 border-t border-gray-100">
59:               <p className="text-sm text-muted-foreground">
60:                 Need help getting started?{" "}
61:                 <button
62:                   className="text-green-700 underline hover:text-green-800"
63:                   onClick={() => {
64:                     console.log("Show tutorial");
65:                   }}
66:                 >
67:                   View quick tutorial
68:                 </button>
69:               </p>
70:             </div>
71:           )}
72:         </CardContent>
73:       </Card>
74:     </div>
75:   );
76: };
77: 
78: export default EmptyState;

================
File: src/components/plant/CareActivityItem.tsx
================
  1: import React, { useState } from "react";
  2: import {
  3:   CareRecord,
  4:   WateringDetails,
  5:   FertilizingDetails,
  6:   ObservationDetails,
  7:   HarvestDetails,
  8:   TransplantDetails,
  9: } from "@/types/database";
 10: import { formatDateTime } from "@/utils/dateUtils";
 11: 
 12: interface CareActivityItemProps {
 13:   activity: CareRecord;
 14: }
 15: 
 16: const CareActivityItem: React.FC<CareActivityItemProps> = ({ activity }) => {
 17:   const [isExpanded, setIsExpanded] = useState(false);
 18: 
 19:   const getActivityIcon = (type: string): string => {
 20:     switch (type) {
 21:       case "water":
 22:         return "💧";
 23:       case "fertilize":
 24:         return "🌱";
 25:       case "observe":
 26:         return "👁️";
 27:       case "harvest":
 28:         return "🌾";
 29:       case "transplant":
 30:         return "🏺";
 31:       default:
 32:         return "📋";
 33:     }
 34:   };
 35: 
 36:   const getActivityTitle = (activity: CareRecord): string => {
 37:     switch (activity.type) {
 38:       case "water":
 39:         const waterDetails = activity.details as WateringDetails;
 40:         return `Watering (${waterDetails.amount.value} ${waterDetails.amount.unit})`;
 41:       case "fertilize":
 42:         const fertilizeDetails = activity.details as FertilizingDetails;
 43:         return `Fertilized with ${fertilizeDetails.product}`;
 44:       case "observe":
 45:         const observeDetails = activity.details as ObservationDetails;
 46:         return `Health Check (${observeDetails.healthAssessment})`;
 47:       case "harvest":
 48:         const harvestDetails = activity.details as HarvestDetails;
 49:         return `Harvested ${harvestDetails.amount}`;
 50:       case "transplant":
 51:         const transplantDetails = activity.details as TransplantDetails;
 52:         return `Transplanted to ${transplantDetails.toContainer}`;
 53:       default:
 54:         return "Care Activity";
 55:     }
 56:   };
 57: 
 58:   const renderActivityDetails = (activity: CareRecord) => {
 59:     switch (activity.type) {
 60:       case "water":
 61:         const waterDetails = activity.details as WateringDetails;
 62:         return (
 63:           <div className="space-y-2">
 64:             <div className="grid grid-cols-2 gap-4 text-sm">
 65:               <div>
 66:                 <span className="font-medium text-muted-foreground">
 67:                   Amount:
 68:                 </span>
 69:                 <div>
 70:                   {waterDetails.amount.value} {waterDetails.amount.unit}
 71:                 </div>
 72:               </div>
 73:               {waterDetails.method && (
 74:                 <div>
 75:                   <span className="font-medium text-muted-foreground">
 76:                     Method:
 77:                   </span>
 78:                   <div>{waterDetails.method.replace("-", " ")}</div>
 79:                 </div>
 80:               )}
 81:             </div>
 82:             {waterDetails.moistureReading && (
 83:               <div>
 84:                 <span className="font-medium text-muted-foreground">
 85:                   Moisture Reading:
 86:                 </span>
 87:                 <div className="text-sm">
 88:                   Before: {waterDetails.moistureReading.before}/10 → After:{" "}
 89:                   {waterDetails.moistureReading.after}/10
 90:                 </div>
 91:               </div>
 92:             )}
 93:             {waterDetails.runoffObserved !== undefined && (
 94:               <div>
 95:                 <span className="font-medium text-muted-foreground">
 96:                   Runoff:
 97:                 </span>
 98:                 <div className="text-sm">
 99:                   {waterDetails.runoffObserved ? "Yes" : "No"}
100:                 </div>
101:               </div>
102:             )}
103:           </div>
104:         );
105: 
106:       case "fertilize":
107:         const fertilizeDetails = activity.details as FertilizingDetails;
108:         return (
109:           <div className="space-y-2">
110:             <div className="grid grid-cols-2 gap-4 text-sm">
111:               <div>
112:                 <span className="font-medium text-muted-foreground">
113:                   Product:
114:                 </span>
115:                 <div>{fertilizeDetails.product}</div>
116:               </div>
117:               <div>
118:                 <span className="font-medium text-muted-foreground">
119:                   Dilution:
120:                 </span>
121:                 <div>{fertilizeDetails.dilution}</div>
122:               </div>
123:               <div>
124:                 <span className="font-medium text-muted-foreground">
125:                   Amount:
126:                 </span>
127:                 <div>{fertilizeDetails.amount}</div>
128:               </div>
129:             </div>
130:           </div>
131:         );
132: 
133:       case "observe":
134:         const observeDetails = activity.details as ObservationDetails;
135:         return (
136:           <div className="space-y-2">
137:             <div>
138:               <span className="font-medium text-muted-foreground">
139:                 Health Assessment:
140:               </span>
141:               <div className="text-sm capitalize">
142:                 {observeDetails.healthAssessment}
143:               </div>
144:             </div>
145:             <div>
146:               <span className="font-medium text-muted-foreground">
147:                 Observations:
148:               </span>
149:               <div className="text-sm">{observeDetails.observations}</div>
150:             </div>
151:             {observeDetails.photos && observeDetails.photos.length > 0 && (
152:               <div>
153:                 <span className="font-medium text-muted-foreground">
154:                   Photos:
155:                 </span>
156:                 <div className="text-sm">
157:                   {observeDetails.photos.length} photo(s) attached
158:                 </div>
159:               </div>
160:             )}
161:           </div>
162:         );
163: 
164:       case "harvest":
165:         const harvestDetails = activity.details as HarvestDetails;
166:         return (
167:           <div className="space-y-2">
168:             <div className="grid grid-cols-2 gap-4 text-sm">
169:               <div>
170:                 <span className="font-medium text-muted-foreground">
171:                   Amount:
172:                 </span>
173:                 <div>{harvestDetails.amount}</div>
174:               </div>
175:               <div>
176:                 <span className="font-medium text-muted-foreground">
177:                   Quality:
178:                 </span>
179:                 <div className="capitalize">{harvestDetails.quality}</div>
180:               </div>
181:             </div>
182:             {harvestDetails.method && (
183:               <div>
184:                 <span className="font-medium text-muted-foreground">
185:                   Method:
186:                 </span>
187:                 <div className="text-sm">{harvestDetails.method}</div>
188:               </div>
189:             )}
190:           </div>
191:         );
192: 
193:       case "transplant":
194:         const transplantDetails = activity.details as TransplantDetails;
195:         return (
196:           <div className="space-y-2">
197:             <div className="grid grid-cols-2 gap-4 text-sm">
198:               <div>
199:                 <span className="font-medium text-muted-foreground">From:</span>
200:                 <div>{transplantDetails.fromContainer}</div>
201:               </div>
202:               <div>
203:                 <span className="font-medium text-muted-foreground">To:</span>
204:                 <div>{transplantDetails.toContainer}</div>
205:               </div>
206:             </div>
207:             <div>
208:               <span className="font-medium text-muted-foreground">Reason:</span>
209:               <div className="text-sm">{transplantDetails.reason}</div>
210:             </div>
211:           </div>
212:         );
213: 
214:       default:
215:         return null;
216:     }
217:   };
218: 
219:   return (
220:     <div className="border border-border rounded-lg">
221:       <div
222:         className="p-4 cursor-pointer hover:bg-background transition-colors"
223:         onClick={() => setIsExpanded(!isExpanded)}
224:       >
225:         <div className="flex items-start gap-3">
226:           <div className="text-xl">{getActivityIcon(activity.type)}</div>
227:           <div className="flex-1 min-w-0">
228:             <div className="flex items-start justify-between">
229:               <div>
230:                 <h4 className="font-medium text-foreground text-sm">
231:                   {getActivityTitle(activity)}
232:                 </h4>
233:                 <p className="text-xs text-muted-foreground mt-1">
234:                   {formatDateTime(activity.date)}
235:                 </p>
236:               </div>
237:               <svg
238:                 className={`w-4 h-4 text-muted-foreground transition-transform ${
239:                   isExpanded ? "rotate-180" : ""
240:                 }`}
241:                 fill="none"
242:                 stroke="currentColor"
243:                 viewBox="0 0 24 24"
244:               >
245:                 <path
246:                   strokeLinecap="round"
247:                   strokeLinejoin="round"
248:                   strokeWidth={2}
249:                   d="M19 9l-7 7-7-7"
250:                 />
251:               </svg>
252:             </div>
253:           </div>
254:         </div>
255:       </div>
256: 
257:       {isExpanded && (
258:         <div className="px-4 pb-4 border-t border-gray-100 bg-background">
259:           <div className="pt-3">
260:             {renderActivityDetails(activity)}
261: 
262:             {activity.details.notes && (
263:               <div className="mt-3 pt-3 border-t border-border">
264:                 <span className="font-medium text-muted-foreground">
265:                   Notes:
266:                 </span>
267:                 <div className="text-sm text-foreground mt-1">
268:                   {activity.details.notes}
269:                 </div>
270:               </div>
271:             )}
272:           </div>
273:         </div>
274:       )}
275:     </div>
276:   );
277: };
278: 
279: export default CareActivityItem;

================
File: src/components/plant/PlantStageDisplay.tsx
================
 1: import { PlantRecord } from "@/types/database";
 2: import { useDynamicStage } from "@/hooks/useDynamicStage";
 3: 
 4: interface PlantStageDisplayProps {
 5:   plant: PlantRecord;
 6:   showEmoji?: boolean;
 7:   className?: string;
 8: }
 9: 
10: const PlantStageDisplay = ({
11:   plant,
12:   showEmoji = false,
13:   className = "text-sm font-medium text-muted-foreground capitalize",
14: }: PlantStageDisplayProps) => {
15:   const calculatedStage = useDynamicStage(plant);
16: 
17:   return (
18:     <div className={className}>
19:       {showEmoji && <span className="mr-1">🌱</span>}
20:       Stage: {calculatedStage}
21:     </div>
22:   );
23: };
24: 
25: export default PlantStageDisplay;

================
File: src/components/plant/ReminderPreferencesSection.tsx
================
 1: import { Switch } from "@/components/ui/Switch";
 2: import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/Card";
 3: 
 4: 
 5: interface ReminderPreferences {
 6:   watering: boolean;
 7:   fertilizing: boolean;
 8:   observation: boolean;
 9:   lighting: boolean;
10:   pruning: boolean;
11: }
12: 
13: interface ReminderPreferencesProps {
14:   preferences: ReminderPreferences;
15:   onChange: (preferences: ReminderPreferences) => void;
16: }
17: 
18: const ReminderPreferencesSection = ({
19:   preferences,
20:   onChange,
21: }: ReminderPreferencesProps) => {
22:   const handleToggle = (key: keyof ReminderPreferences) => {
23:     onChange({
24:       ...preferences,
25:       [key]: !preferences[key],
26:     });
27:   };
28: 
29:   const reminderTypes = [
30:     {
31:       key: "watering" as const,
32:       label: "Watering",
33:       icon: "💧",
34:       description: "Get notified when watering is due",
35:     },
36:     {
37:       key: "fertilizing" as const,
38:       label: "Fertilizing",
39:       icon: "🌱",
40:       description: "Reminders for feeding schedule",
41:     },
42:     {
43:       key: "observation" as const,
44:       label: "Health Checks",
45:       icon: "👁️",
46:       description: "Regular observation reminders",
47:     },
48:     {
49:       key: "lighting" as const,
50:       label: "Lighting",
51:       icon: "💡",
52:       description: "Light schedule adjustments",
53:     },
54:     {
55:       key: "pruning" as const,
56:       label: "Maintenance",
57:       icon: "✂️",
58:       description: "Pruning and maintenance tasks",
59:     },
60:   ];
61: 
62:   return (
63:     <Card className="border-emerald-200 bg-emerald-50/30">
64:       <CardHeader className="pb-3">
65:         <CardTitle className="text-lg flex items-center gap-2">
66:           <span>🔔</span>
67:           Reminder Preferences
68:         </CardTitle>
69:         <p className="text-sm text-muted-foreground">
70:           Choose which types of care reminders you'd like to receive for this
71:           plant
72:         </p>
73:       </CardHeader>
74:       <CardContent className="space-y-3">
75:         {reminderTypes.map(({ key, label, icon, description }) => (
76:           <div
77:             key={key}
78:             className="flex items-center justify-between p-3 rounded-lg border border-emerald-100 bg-card/50 hover:bg-card/80 transition-colors"
79:           >
80:             <div className="flex-1">
81:               <div className="flex items-center gap-2 mb-1">
82:                 <span className="text-lg">{icon}</span>
83:                 <span className="font-medium text-foreground">{label}</span>
84:               </div>
85:               <p className="text-sm text-muted-foreground">{description}</p>
86:             </div>
87:             <Switch
88:               checked={preferences[key]}
89:               onCheckedChange={() => handleToggle(key)}
90:               className="ml-4"
91:             />
92:           </div>
93:         ))}
94:       </CardContent>
95:     </Card>
96:   );
97: };
98: 
99: export default ReminderPreferencesSection;

================
File: src/components/ui/Button.tsx
================
  1: import React from "react";
  2: import { cn } from "@/utils/cn";
  3: 
  4: interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  5:   variant?: "primary" | "secondary" | "outline" | "ghost" | "destructive";
  6:   size?: "sm" | "md" | "lg" | "xl";
  7:   children: React.ReactNode;
  8:   loading?: boolean;
  9:   leftIcon?: React.ReactNode;
 10:   rightIcon?: React.ReactNode;
 11: }
 12: 
 13: export const Button: React.FC<ButtonProps> = ({
 14:   variant = "primary",
 15:   size = "md",
 16:   className,
 17:   children,
 18:   loading = false,
 19:   leftIcon,
 20:   rightIcon,
 21:   disabled,
 22:   ...props
 23: }) => {
 24:   const baseClasses = [
 25:     "inline-flex items-center justify-center",
 26:     "font-bold tracking-wide",
 27:     "rounded-2xl",
 28:     "transition-all duration-200 ease-out",
 29:     "focus:outline-none focus:ring-4 focus:ring-offset-0",
 30:     "active:scale-95",
 31:     "disabled:opacity-50 disabled:cursor-not-allowed disabled:active:scale-100",
 32:     "select-none",
 33:     "relative overflow-hidden",
 34:   ].join(" ");
 35: 
 36:   const variantClasses = {
 37:     primary: [
 38:       "bg-gradient-to-r from-emerald-500 to-green-600",
 39:       "text-white",
 40:       "hover:from-emerald-600 hover:to-green-700",
 41:       "active:from-emerald-700 active:to-green-800",
 42:       "focus:ring-emerald-400/50",
 43:       "shadow-lg shadow-emerald-500/25",
 44:       "hover:shadow-xl hover:shadow-emerald-500/30",
 45:       "border-0",
 46:     ].join(" "),
 47: 
 48:     secondary: [
 49:       "bg-gradient-to-r from-amber-400 to-orange-500",
 50:       "text-white",
 51:       "hover:from-amber-500 hover:to-orange-600",
 52:       "focus:ring-amber-400/50",
 53:       "shadow-lg shadow-amber-400/25",
 54:       "border-0",
 55:     ].join(" "),
 56: 
 57:     outline: [
 58:       "bg-card text-primary",
 59:       "hover:bg-muted hover:text-primary",
 60:       "active:bg-muted",
 61:       "focus:ring-ring/50",
 62:       "border-2 border-border",
 63:       "hover:border-ring",
 64:       "shadow-sm hover:shadow-md",
 65:     ].join(" "),
 66: 
 67:     ghost: [
 68:       "bg-transparent text-muted-foreground",
 69:       "hover:bg-muted hover:text-foreground",
 70:       "active:bg-muted",
 71:       "focus:ring-ring/50",
 72:       "border-0",
 73:       "shadow-none",
 74:     ].join(" "),
 75: 
 76:     destructive: [
 77:       "bg-gradient-to-r from-red-500 to-pink-600",
 78:       "text-white",
 79:       "hover:from-red-600 hover:to-pink-700",
 80:       "focus:ring-red-400/50",
 81:       "shadow-lg shadow-red-500/25",
 82:       "border-0",
 83:     ].join(" "),
 84:   };
 85: 
 86:   const sizeClasses = {
 87:     sm: "px-5 py-2.5 text-sm min-h-10 gap-2",
 88:     md: "px-7 py-3.5 text-base min-h-12 gap-2.5",
 89:     lg: "px-9 py-4.5 text-lg min-h-14 gap-3",
 90:     xl: "px-11 py-6 text-xl min-h-16 gap-3",
 91:   };
 92: 
 93:   const LoadingSpinner = () => (
 94:     <div className="w-5 h-5 border-3 border-white/30 border-t-white rounded-full animate-spin" />
 95:   );
 96: 
 97:   return (
 98:     <button
 99:       className={cn(
100:         baseClasses,
101:         variantClasses[variant],
102:         sizeClasses[size],
103:         className
104:       )}
105:       disabled={disabled || loading}
106:       {...props}
107:     >
108:       {loading ? (
109:         <>
110:           <LoadingSpinner />
111:           <span className="ml-2">Loading...</span>
112:         </>
113:       ) : (
114:         <>
115:           {leftIcon && <span className="flex-shrink-0">{leftIcon}</span>}
116:           <span>{children}</span>
117:           {rightIcon && <span className="flex-shrink-0">{rightIcon}</span>}
118:         </>
119:       )}
120:     </button>
121:   );
122: };

================
File: src/components/ui/Card.tsx
================
 1: import React from "react";
 2: import { cn } from "@/utils/cn";
 3: 
 4: interface CardProps {
 5:   children: React.ReactNode;
 6:   className?: string;
 7: }
 8: 
 9: interface CardContentProps extends React.HTMLAttributes<HTMLDivElement> {
10:   children: React.ReactNode;
11:   className?: string;
12: }
13: export function Card({ children, className }: CardProps) {
14:   return (
15:     <div
16:       className={cn(
17:         "rounded-lg border bg-card text-card-foreground shadow-sm",
18:         className
19:       )}
20:     >
21:       {children}
22:     </div>
23:   );
24: }
25: 
26: export function CardHeader({ children, className }: CardProps) {
27:   return (
28:     <div className={cn("px-6 py-4 border-b border-border", className)}>
29:       {children}
30:     </div>
31:   );
32: }
33: 
34: export function CardContent({
35:   children,
36:   className,
37:   ...props
38: }: CardContentProps) {
39:   return (
40:     <div
41:       className={cn(
42:         "p-6 pt-0 text-card-foreground",
43: 
44:         className
45:       )}
46:       {...props}
47:     >
48:       {children}
49:     </div>
50:   );
51: }
52: 
53: export function CardTitle({ children, className }: CardProps) {
54:   return (
55:     <h3
56:       className={cn(
57:         "text-2xl font-semibold leading-none tracking-tight text-card-foreground",
58: 
59:         className
60:       )}
61:     >
62:       {children}
63:     </h3>
64:   );
65: }

================
File: src/components/ui/DarkModeToggle.tsx
================
 1: import React from "react";
 2: import { useDarkMode } from "@/hooks/useDarkMode";
 3: import { cn } from "@/utils/cn";
 4: 
 5: interface DarkModeToggleProps {
 6:   size?: "sm" | "md" | "lg";
 7:   className?: string;
 8:   showLabels?: boolean;
 9: }
10: 
11: export const DarkModeToggle: React.FC<DarkModeToggleProps> = ({
12:   size = "md",
13:   className,
14:   showLabels = false,
15: }) => {
16:   const { isDarkMode, toggleDarkMode } = useDarkMode();
17: 
18:   const sizeClasses = {
19:     sm: {
20:       button: "w-12 h-6",
21:       circle: "w-4 h-4",
22:       translate: "translate-x-6",
23:       icon: "text-xs",
24:     },
25:     md: {
26:       button: "w-14 h-7",
27:       circle: "w-5 h-5",
28:       translate: "translate-x-7",
29:       icon: "text-sm",
30:     },
31:     lg: {
32:       button: "w-16 h-8",
33:       circle: "w-6 h-6",
34:       translate: "translate-x-8",
35:       icon: "text-base",
36:     },
37:   };
38: 
39:   const sizes = sizeClasses[size];
40: 
41:   return (
42:     <div className={cn("flex items-center gap-2", className)}>
43:       {showLabels && (
44:         <span
45:           className={cn(
46:             "relative inline-flex flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:ring-offset-2",
47:             sizes.button,
48:             isDarkMode
49:               ? "bg-emerald-600 hover:bg-emerald-700"
50:               : "bg-gray-300 hover:bg-gray-400 dark:bg-gray-600 dark:hover:bg-background0"
51:           )}
52:         >
53:           ☀️
54:         </span>
55:       )}
56: 
57:       <button
58:         type="button"
59:         onClick={toggleDarkMode}
60:         className={cn(
61:           "relative inline-flex flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:ring-offset-2",
62:           sizes.button,
63:           isDarkMode
64:             ? "bg-emerald-600 hover:bg-emerald-700"
65:             : "bg-gray-300 hover:bg-gray-400 dark:bg-gray-600 dark:hover:bg-background0"
66:         )}
67:         aria-label={`Switch to ${isDarkMode ? "light" : "dark"} mode`}
68:       >
69:         <span
70:           className={cn(
71:             "pointer-events-none inline-block rounded-full bg-card shadow transform ring-0 transition duration-200 ease-in-out flex items-center justify-center",
72:             sizes.circle,
73:             isDarkMode ? sizes.translate : "translate-x-0"
74:           )}
75:         >
76:           <span className={cn(sizes.icon)}>{isDarkMode ? "🌙" : "☀️"}</span>
77:         </span>
78:       </button>
79: 
80:       {showLabels && (
81:         <span
82:           className={cn(
83:             "text-sm font-medium transition-colors",
84:             isDarkMode
85:               ? "text-emerald-700 dark:text-emerald-500"
86:               : "text-muted-foreground dark:text-muted-foreground"
87:           )}
88:         >
89:           🌙
90:         </span>
91:       )}
92:     </div>
93:   );
94: };

================
File: src/components/ui/LocationToggle.tsx
================
 1: import React from "react";
 2: import { cn } from "@/utils/cn";
 3: 
 4: interface LocationToggleProps {
 5:   isOutdoor: boolean;
 6:   onChange: (isOutdoor: boolean) => void;
 7:   disabled?: boolean;
 8:   className?: string;
 9: }
10: 
11: export const LocationToggle: React.FC<LocationToggleProps> = ({
12:   isOutdoor,
13:   onChange,
14:   disabled = false,
15:   className,
16: }) => {
17:   return (
18:     <div
19:       className={cn("relative inline-flex rounded-lg p-1 bg-muted", className)}
20:     >
21:       <button
22:         type="button"
23:         disabled={disabled}
24:         onClick={() => onChange(false)}
25:         className={cn(
26:           "relative flex items-center gap-2 px-4 py-2 text-sm font-medium rounded-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:ring-offset-2",
27:           !isOutdoor
28:             ? "bg-card text-emerald-700 shadow-sm"
29:             : "text-muted-foreground hover:text-foreground",
30:           disabled && "opacity-50 cursor-not-allowed"
31:         )}
32:       >
33:         <span className="text-lg">🏠</span>
34:         <span>Indoor</span>
35:       </button>
36: 
37:       <button
38:         type="button"
39:         disabled={disabled}
40:         onClick={() => onChange(true)}
41:         className={cn(
42:           "relative flex items-center gap-2 px-4 py-2 text-sm font-medium rounded-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:ring-offset-2",
43:           isOutdoor
44:             ? "bg-card text-emerald-700 shadow-sm"
45:             : "text-muted-foreground hover:text-foreground",
46:           disabled && "opacity-50 cursor-not-allowed"
47:         )}
48:       >
49:         <span className="text-lg">🌞</span>
50:         <span>Outdoor</span>
51:       </button>
52:     </div>
53:   );
54: };

================
File: src/components/ui/Switch.tsx
================
  1: import React from "react";
  2: import { cn } from "@/utils/cn";
  3: 
  4: interface SwitchProps {
  5:   checked: boolean;
  6:   onCheckedChange: (checked: boolean) => void;
  7:   disabled?: boolean;
  8:   leftLabel?: string;
  9:   rightLabel?: string;
 10:   leftIcon?: React.ReactNode;
 11:   rightIcon?: React.ReactNode;
 12:   size?: "sm" | "md" | "lg";
 13:   className?: string;
 14:   id?: string;
 15:   "aria-label"?: string;
 16:   "aria-labelledby"?: string;
 17: }
 18: 
 19: export const Switch: React.FC<SwitchProps> = ({
 20:   checked,
 21:   onCheckedChange,
 22:   disabled = false,
 23:   leftLabel,
 24:   rightLabel,
 25:   leftIcon,
 26:   rightIcon,
 27:   size = "md",
 28:   className,
 29:   id,
 30:   "aria-label": ariaLabel,
 31:   "aria-labelledby": ariaLabelledBy,
 32: }) => {
 33:   const sizeClasses = {
 34:     sm: {
 35:       track: "w-10 h-5",
 36:       thumb: "w-4 h-4",
 37:       translate: "translate-x-5",
 38:       text: "text-sm",
 39:       gap: "gap-2",
 40:     },
 41:     md: {
 42:       track: "w-12 h-6",
 43:       thumb: "w-5 h-5",
 44:       translate: "translate-x-6",
 45:       text: "text-base",
 46:       gap: "gap-3",
 47:     },
 48:     lg: {
 49:       track: "w-14 h-7",
 50:       thumb: "w-6 h-6",
 51:       translate: "translate-x-7",
 52:       text: "text-lg",
 53:       gap: "gap-4",
 54:     },
 55:   };
 56: 
 57:   const sizes = sizeClasses[size];
 58: 
 59:   return (
 60:     <div className={cn("flex items-center", sizes.gap, className)}>
 61:       {}
 62:       {(leftLabel || leftIcon) && (
 63:         <div
 64:           className={cn(
 65:             "flex items-center gap-2 transition-colors duration-200",
 66:             sizes.text,
 67:             !checked
 68:               ? "text-emerald-700 font-semibold"
 69:               : "text-muted-foreground",
 70:             disabled && "opacity-50"
 71:           )}
 72:         >
 73:           {leftIcon && <span className="flex-shrink-0">{leftIcon}</span>}
 74:           {leftLabel && <span>{leftLabel}</span>}
 75:         </div>
 76:       )}
 77: 
 78:       {}
 79:       <button
 80:         type="button"
 81:         role="switch"
 82:         aria-checked={checked}
 83:         aria-label={ariaLabel}
 84:         aria-labelledby={ariaLabelledBy}
 85:         id={id}
 86:         disabled={disabled}
 87:         onClick={() => onCheckedChange(!checked)}
 88:         className={cn(
 89:           "relative inline-flex flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:ring-offset-2",
 90:           sizes.track,
 91:           checked
 92:             ? "bg-emerald-600 hover:bg-emerald-700"
 93:             : "bg-gray-300 hover:bg-gray-400",
 94:           disabled && "cursor-not-allowed opacity-50 hover:bg-gray-300"
 95:         )}
 96:       >
 97:         <span
 98:           className={cn(
 99:             "pointer-events-none inline-block rounded-full bg-card shadow transform ring-0 transition duration-200 ease-in-out",
100:             sizes.thumb,
101:             checked ? sizes.translate : "translate-x-0"
102:           )}
103:         />
104:       </button>
105: 
106:       {}
107:       {(rightLabel || rightIcon) && (
108:         <div
109:           className={cn(
110:             "flex items-center gap-2 transition-colors duration-200",
111:             sizes.text,
112:             checked
113:               ? "text-emerald-700 font-semibold"
114:               : "text-muted-foreground",
115:             disabled && "opacity-50"
116:           )}
117:         >
118:           {rightIcon && <span className="flex-shrink-0">{rightIcon}</span>}
119:           {rightLabel && <span>{rightLabel}</span>}
120:         </div>
121:       )}
122:     </div>
123:   );
124: };

================
File: src/data/seedVarieties.ts
================
   1: import { PlantCategory } from "@/types";
   2: 
   3: interface StageSpecificWateringProtocol {
   4:   [stageName: string]: {
   5:     trigger: {
   6:       moistureLevel: string | number;
   7:       description?: string;
   8:     };
   9:     target: {
  10:       moistureLevel: string | number;
  11:       description?: string;
  12:     };
  13:     volume: {
  14:       amount: string;
  15:       frequency: string;
  16:       perPlant?: boolean;
  17:     };
  18:     notes?: string[];
  19:   };
  20: }
  21: 
  22: interface StageSpecificLightingProtocol {
  23:   [stageName: string]: {
  24:     ppfd: {
  25:       min: number;
  26:       max: number;
  27:       optimal?: number;
  28:       unit: "µmol/m²/s";
  29:     };
  30:     photoperiod: {
  31:       hours: number;
  32:       maxHours?: number;
  33:       minHours?: number;
  34:       constraint?: string;
  35:     };
  36:     dli: {
  37:       min: number;
  38:       max: number;
  39:       unit: "mol/m²/day";
  40:     };
  41:     notes?: string[];
  42:   };
  43: }
  44: 
  45: interface StageSpecificFertilizationProtocol {
  46:   [stageName: string]: {
  47:     products?: {
  48:       name: string;
  49:       dilution: string;
  50:       amount: string;
  51:       frequency: string;
  52:       method?: "soil-drench" | "foliar-spray" | "top-dress" | "mix-in-soil";
  53:     }[];
  54:     timing?: string;
  55:     specialInstructions?: string[];
  56:     notes?: string[];
  57:   };
  58: }
  59: 
  60: 
  61: interface EnvironmentalProtocol {
  62:   temperature?: {
  63:     min?: number;
  64:     max?: number;
  65:     optimal?: number;
  66:     unit: "F" | "C";
  67:     criticalMax?: number;
  68:     criticalMin?: number;
  69:     stage?: string;
  70:   };
  71:   humidity?: {
  72:     min?: number;
  73:     max?: number;
  74:     optimal?: number;
  75:     criticalForStage?: string;
  76:   };
  77:   pH: {
  78:     min: number;
  79:     max: number;
  80:     optimal: number;
  81:   };
  82:   specialConditions?: string[];
  83:   constraints?: {
  84:     description: string;
  85:     parameter: "temperature" | "humidity" | "light" | "other";
  86:     threshold: number;
  87:     consequence: string;
  88:   }[];
  89: }
  90: 
  91: interface SoilMixture {
  92:   components: {
  93:     [component: string]: number;
  94:   };
  95:   amendments?: {
  96:     [amendment: string]: string;
  97:   };
  98: }
  99: 
 100: interface ContainerRequirements {
 101:   minSize?: string;
 102:   depth: string;
 103:   drainage?: string;
 104:   staging?: {
 105:     seedling?: string;
 106:     intermediate?: string;
 107:     final: string;
 108:   };
 109: }
 110: 
 111: interface SuccessionProtocol {
 112:   interval: number;
 113:   method: "continuous" | "zoned" | "single";
 114:   harvestMethod: "cut-and-come-again" | "single-harvest" | "selective";
 115:   productiveWeeks?: number;
 116:   notes?: string[];
 117: }
 118: 
 119: interface ComprehensivePlantProtocols {
 120:   lighting?: StageSpecificLightingProtocol;
 121:   watering?: StageSpecificWateringProtocol;
 122:   fertilization?: StageSpecificFertilizationProtocol;
 123:   environment?: EnvironmentalProtocol;
 124:   soilMixture?: SoilMixture;
 125:   container?: ContainerRequirements;
 126:   succession?: SuccessionProtocol;
 127:   specialRequirements?: string[];
 128: }
 129: 
 130: export interface SeedVariety {
 131:   name: string;
 132:   category: PlantCategory;
 133:   growthTimeline: {
 134:     germination: number;
 135:     seedling: number;
 136:     vegetative: number;
 137:     maturation: number;
 138:   };
 139:   protocols?: ComprehensivePlantProtocols;
 140:   isEverbearing?: boolean;
 141:   productiveLifespan?: number;
 142: }
 143: 
 144: 
 145: 
 146: 
 147: 
 148: 
 149: 
 150: 
 151: export const seedVarieties: SeedVariety[] = [
 152:   {
 153:     name: "Boston Pickling Cucumber",
 154:     category: "fruiting-plants",
 155:     isEverbearing: false,
 156:     productiveLifespan: 70,
 157:     growthTimeline: {
 158:       germination: 7,
 159:       seedling: 14,
 160:       vegetative: 21,
 161:       maturation: 50,
 162:     },
 163:     protocols: {
 164:       lighting: {
 165:         seedling: {
 166:           ppfd: { min: 200, max: 400, unit: "µmol/m²/s" },
 167:           photoperiod: { hours: 12, maxHours: 16 },
 168:           dli: { min: 8.6, max: 23.0, unit: "mol/m²/day" },
 169:           notes: [
 170:             "Start feeding 2-3 weeks post-germination with balanced liquid fertilizer",
 171:             "Half strength during establishment to avoid nutrient burn",
 172:           ],
 173:         },
 174:         vegetativeGrowth: {
 175:           ppfd: { min: 400, max: 600, unit: "µmol/m²/s" },
 176:           photoperiod: { hours: 14, maxHours: 16 },
 177:           dli: { min: 20.2, max: 34.6, unit: "mol/m²/day" },
 178:           notes: [
 179:             "Vigorous vine growth requires high light intensity",
 180:             "Higher nitrogen during this phase supports leaf and vine development",
 181:           ],
 182:         },
 183:         flowering: {
 184:           ppfd: { min: 500, max: 700, unit: "µmol/m²/s" },
 185:           photoperiod: { hours: 14, maxHours: 16 },
 186:           dli: { min: 28.8, max: 40.3, unit: "mol/m²/day" },
 187:           notes: [
 188:             "Critical phase - flower production determines fruit yield",
 189:             "Hand pollination required daily during flowering period",
 190:           ],
 191:         },
 192:         fruitingHarvesting: {
 193:           ppfd: { min: 500, max: 700, unit: "µmol/m²/s" },
 194:           photoperiod: { hours: 14, maxHours: 16 },
 195:           dli: { min: 28.8, max: 40.3, unit: "mol/m²/day" },
 196:           notes: [
 197:             "Harvest 8-10 days after fruit set",
 198:             "Regular picking encourages continued production",
 199:           ],
 200:         },
 201:       },
 202:       watering: {
 203:         seedling: {
 204:           trigger: { moistureLevel: "consistent moisture" },
 205:           target: { moistureLevel: "adequate but not waterlogged" },
 206:           volume: {
 207:             amount: "as needed for establishment",
 208:             frequency: "daily monitoring",
 209:           },
 210:           notes: ["Heavy feeders require consistent moisture from start"],
 211:         },
 212:         vegetativeGrowth: {
 213:           trigger: { moistureLevel: "when top inch dry" },
 214:           target: { moistureLevel: "thoroughly moist" },
 215:           volume: { amount: "heavy watering", frequency: "as soil indicates" },
 216:           notes: [
 217:             "Consistent moisture critical - never allow drought stress",
 218:             "Container growing requires more frequent attention than ground cultivation",
 219:           ],
 220:         },
 221:         flowering: {
 222:           trigger: { moistureLevel: "when top inch dry" },
 223:           target: { moistureLevel: "thoroughly moist" },
 224:           volume: {
 225:             amount: "heavy watering",
 226:             frequency: "consistent schedule",
 227:           },
 228:           notes: [
 229:             "Water stress during flowering dramatically reduces fruit set",
 230:             "Morning watering preferred to allow leaves to dry before evening",
 231:           ],
 232:         },
 233:         fruitingHarvesting: {
 234:           trigger: { moistureLevel: "when top inch dry" },
 235:           target: { moistureLevel: "thoroughly moist" },
 236:           volume: {
 237:             amount: "heavy watering",
 238:             frequency: "daily during peak production",
 239:           },
 240:           notes: [
 241:             "Fruit development requires enormous water uptake",
 242:             "Inconsistent watering causes bitter or malformed fruit",
 243:           ],
 244:         },
 245:       },
 246:       fertilization: {
 247:         seedling: {
 248:           products: [
 249:             {
 250:               name: "Balanced liquid fertilizer",
 251:               dilution: "half strength",
 252:               amount: "light application",
 253:               frequency: "start 2-3 weeks post-germination",
 254:             },
 255:           ],
 256:           timing: "Weeks 2-4",
 257:           notes: ["Gentle introduction to feeding - young roots are sensitive"],
 258:         },
 259:         vegetativeGrowth: {
 260:           products: [
 261:             {
 262:               name: "Balanced liquid fertilizer",
 263:               dilution: "full strength",
 264:               amount: "regular application",
 265:               frequency: "every 1-2 weeks",
 266:             },
 267:           ],
 268:           timing: "Weeks 4-8",
 269:           notes: ["Higher nitrogen during vine development phase"],
 270:         },
 271:         flowering: {
 272:           products: [
 273:             {
 274:               name: "Higher P-K fertilizer (tomato/bloom booster)",
 275:               dilution: "as directed",
 276:               amount: "regular application",
 277:               frequency: "every 1-2 weeks",
 278:             },
 279:           ],
 280:           timing: "When first flowers appear",
 281:           notes: [
 282:             "Switch from nitrogen-heavy to phosphorus-potassium emphasis",
 283:             "Supports flower production and fruit development",
 284:           ],
 285:         },
 286:         fruitingHarvesting: {
 287:           products: [
 288:             {
 289:               name: "Higher P-K fertilizer",
 290:               dilution: "as directed",
 291:               amount: "consistent application",
 292:               frequency: "every 1-2 weeks",
 293:             },
 294:           ],
 295:           timing: "Throughout harvest period",
 296:           notes: ["Continuous fruiting demands consistent nutrition"],
 297:         },
 298:       },
 299:       environment: {
 300:         pH: { min: 5.8, max: 6.5, optimal: 6.2 },
 301:       },
 302:       soilMixture: {
 303:         components: {
 304:           "coco coir": 30,
 305:           perlite: 25,
 306:           vermiculite: 25,
 307:           compost: 20,
 308:         },
 309:         amendments: {
 310:           "well-rotted manure": "3 tbsp per gallon",
 311:           "bone meal": "1 tbsp per gallon",
 312:         },
 313:       },
 314:       container: {
 315:         minSize: "≥2-3 gallons",
 316:         depth: "18-24 inches minimum",
 317:         staging: {
 318:           seedling: "4 inch pot or cell tray with deeper cells",
 319:           final: "Large container or main bed section",
 320:         },
 321:       },
 322:       succession: {
 323:         interval: 21,
 324:         method: "continuous",
 325:         harvestMethod: "selective",
 326:         productiveWeeks: 8,
 327:         notes: [
 328:           "Succession every 3-4 weeks for overlapping production",
 329:           "Each plant produces for 6-8 weeks once fruiting begins",
 330:         ],
 331:       },
 332:       specialRequirements: [
 333:         "A-frame trellis essential for vine support and light exposure",
 334:         "Hand pollination critical - transfer pollen from male to female flowers daily",
 335:         "Female flowers identifiable by tiny cucumber at base",
 336:         "Harvest regularly to encourage continued production",
 337:         "Heavy feeders requiring rich, well-draining soil",
 338:       ],
 339:     },
 340:   },
 341: 
 342:   {
 343:     name: "Sugar Snap Peas",
 344:     category: "fruiting-plants",
 345:     isEverbearing: true,
 346:     productiveLifespan: 56,
 347:     growthTimeline: {
 348:       germination: 10,
 349:       seedling: 14,
 350:       vegetative: 21,
 351:       maturation: 60,
 352:     },
 353:     protocols: {
 354:       lighting: {
 355:         germinationEmergence: {
 356:           ppfd: { min: 100, max: 250, unit: "µmol/m²/s" },
 357:           photoperiod: { hours: 14, maxHours: 16 },
 358:           dli: { min: 5.0, max: 14.4, unit: "mol/m²/day" },
 359:           notes: ["Keep soil consistently moist during germination period"],
 360:         },
 361:         seedling: {
 362:           ppfd: { min: 200, max: 400, unit: "µmol/m²/s" },
 363:           photoperiod: { hours: 14, maxHours: 16 },
 364:           dli: { min: 11.5, max: 23.0, unit: "mol/m²/day" },
 365:           notes: [
 366:             "First true leaves and tendrils developing - watch for climbing behavior",
 367:           ],
 368:         },
 369:         vegetativeVining: {
 370:           ppfd: { min: 400, max: 600, unit: "µmol/m²/s" },
 371:           photoperiod: { hours: 14, maxHours: 16 },
 372:           dli: { min: 23.0, max: 34.6, unit: "mol/m²/day" },
 373:           notes: ["Rapid vine growth - ensure trellis support is adequate"],
 374:         },
 375:         flowerBudFormation: {
 376:           ppfd: { min: 500, max: 700, unit: "µmol/m²/s" },
 377:           photoperiod: { hours: 12, maxHours: 14 },
 378:           dli: { min: 21.6, max: 35.3, unit: "mol/m²/day" },
 379:           notes: [
 380:             "Slight photoperiod reduction can encourage flowering",
 381:             "Monitor for first flower buds around days 40-50",
 382:           ],
 383:         },
 384:         podSetMaturation: {
 385:           ppfd: { min: 500, max: 700, unit: "µmol/m²/s" },
 386:           photoperiod: { hours: 12 },
 387:           dli: { min: 21.6, max: 30.2, unit: "mol/m²/day" },
 388:           notes: [
 389:             "Harvest pods when plump but before peas become starchy",
 390:             "Regular harvesting encourages continued pod production",
 391:           ],
 392:         },
 393:       },
 394:       watering: {
 395:         germinationEmergence: {
 396:           trigger: { moistureLevel: "3-4" },
 397:           target: { moistureLevel: "7-8" },
 398:           volume: { amount: "16-24 oz (470-710 mL)", frequency: "3x/week" },
 399:           notes: [
 400:             "Keep consistently moist but not waterlogged during germination",
 401:           ],
 402:         },
 403:         seedling: {
 404:           trigger: { moistureLevel: "3-4" },
 405:           target: { moistureLevel: "7-8" },
 406:           volume: { amount: "20-32 oz (590-945 mL)", frequency: "3x/week" },
 407:           notes: ["Establishing root system requires consistent moisture"],
 408:         },
 409:         vegetativeVining: {
 410:           trigger: { moistureLevel: "3-4" },
 411:           target: { moistureLevel: "7-8" },
 412:           volume: { amount: "32-42 oz (945-1240 mL)", frequency: "3-4x/week" },
 413:           notes: ["Rapid vine growth increases water demands significantly"],
 414:         },
 415:         flowerBudFormation: {
 416:           trigger: { moistureLevel: "3-4" },
 417:           target: { moistureLevel: "7-8" },
 418:           volume: { amount: "40-48 oz (1180-1419 mL)", frequency: "4x/week" },
 419:           notes: [
 420:             "Critical period - water stress reduces flower and pod formation",
 421:           ],
 422:         },
 423:         podSetMaturation: {
 424:           trigger: { moistureLevel: "3-4" },
 425:           target: { moistureLevel: "7-8" },
 426:           volume: { amount: "40-54 oz (1180-1600 mL)", frequency: "3-4x/week" },
 427:           notes: ["Pod filling requires substantial water uptake"],
 428:         },
 429:       },
 430:       fertilization: {
 431:         germinationEmergence: {
 432:           products: [
 433:             {
 434:               name: "Rhizobium leguminosarum inoculant",
 435:               dilution: "as directed",
 436:               amount: "apply to seed or planting hole",
 437:               frequency: "at sowing",
 438:               method: "soil-drench",
 439:             },
 440:           ],
 441:           timing: "At sowing",
 442:           notes: [
 443:             "Inoculant enables nitrogen fixation - critical for pea nutrition",
 444:             "Soil pre-amended with gypsum, bone meal, and kelp meal",
 445:           ],
 446:         },
 447:         seedling: {
 448:           products: [
 449:             {
 450:               name: "5-10-10 fertilizer (light dose)",
 451:               dilution: "as directed for containers",
 452:               amount: "light application",
 453:               frequency: "early in containers if needed",
 454:             },
 455:           ],
 456:           timing: "Days 14-20",
 457:           notes: ["Minimal nitrogen needed - peas fix their own nitrogen"],
 458:         },
 459:         vegetativeVining: {
 460:           products: [
 461:             {
 462:               name: "Fish emulsion/fish+kelp (optional)",
 463:               dilution: "as directed",
 464:               amount: "light application",
 465:               frequency: "weekly/biweekly if desired",
 466:             },
 467:             {
 468:               name: "Worm casting top-dress",
 469:               dilution: "N/A",
 470:               amount: "light sprinkle around base",
 471:               frequency: "monthly",
 472:               method: "top-dress",
 473:             },
 474:           ],
 475:           timing: "Weeks 3-6",
 476:           notes: [
 477:             "Light feeding only - excessive nitrogen reduces pod production",
 478:           ],
 479:         },
 480:         flowerBudFormation: {
 481:           products: [
 482:             {
 483:               name: "Bone meal side-dress",
 484:               dilution: "N/A",
 485:               amount: "light application around base",
 486:               frequency: "one-time",
 487:               method: "top-dress",
 488:             },
 489:             {
 490:               name: "Kelp/sea-mineral (if continuing liquid feed)",
 491:               dilution: "as directed",
 492:               amount: "dilute application",
 493:               frequency: "if needed",
 494:             },
 495:           ],
 496:           timing: "Weeks 6-8",
 497:           notes: [
 498:             "Reduce nitrogen completely",
 499:             "Boost phosphorus and potassium for flower and pod development",
 500:           ],
 501:         },
 502:         podSetMaturation: {
 503:           products: [
 504:             {
 505:               name: "Light feeding only if needed",
 506:               dilution: "very dilute",
 507:               amount: "minimal",
 508:               frequency: "rarely",
 509:             },
 510:           ],
 511:           timing: "Days 60-70+",
 512:           notes: [
 513:             "Minimal feeding during harvest - focus on consistent watering",
 514:           ],
 515:         },
 516:       },
 517:       environment: {
 518:         pH: { min: 6.2, max: 6.8, optimal: 6.5 },
 519:       },
 520:       soilMixture: {
 521:         components: {
 522:           "coco coir": 35,
 523:           perlite: 20,
 524:           vermiculite: 20,
 525:           compost: 15,
 526:           "worm castings": 5,
 527:           biochar: 5,
 528:         },
 529:         amendments: {
 530:           gypsum: "½ cup per 15-gal bag",
 531:           "bone meal": "2-3 Tbsp forked into top 4-6 inches",
 532:           "kelp meal": "2 Tbsp into top 4-6 inches",
 533:           "basalt rock dust (optional)": "¼ cup for additional micronutrients",
 534:         },
 535:       },
 536:       container: {
 537:         minSize: "≥2-3 gallons (15-gallon preferred)",
 538:         depth: "12 inches minimum",
 539:       },
 540:       succession: {
 541:         interval: 14,
 542:         method: "continuous",
 543:         harvestMethod: "selective",
 544:         productiveWeeks: 6,
 545:         notes: [
 546:           "Succession every 2-3 weeks for continuous harvest",
 547:           "Each planting productive for 6-8 weeks once podding begins",
 548:         ],
 549:       },
 550:       specialRequirements: [
 551:         "Rhizobium inoculant essential for nitrogen fixation",
 552:         "A-frame trellis or netting required for climbing support",
 553:         "Self-pollinating but benefits from gentle daily shaking of flowers",
 554:         "Harvest pods when full but before peas become starchy",
 555:         "Cool-season crop - performs best in moderate temperatures",
 556:         "Succession planting every 2-3 weeks extends harvest window",
 557:       ],
 558:     },
 559:   },
 560:   {
 561:     name: "Greek Dwarf Basil",
 562:     category: "herbs",
 563:     isEverbearing: true,
 564:     productiveLifespan: 84,
 565:     growthTimeline: {
 566:       germination: 7,
 567:       seedling: 21,
 568:       vegetative: 28,
 569:       maturation: 56,
 570:     },
 571:     protocols: {
 572:       lighting: {
 573:         seedling: {
 574:           ppfd: { min: 100, max: 400, unit: "µmol/m²/s" },
 575:           photoperiod: { hours: 12, maxHours: 16 },
 576:           dli: { min: 4.3, max: 23.0, unit: "mol/m²/day" },
 577:           notes: [
 578:             "Basil loves warmth - keep soil consistently warm during germination",
 579:             "Small plants emerge with initial characteristic basil leaves",
 580:           ],
 581:         },
 582:         vegetative: {
 583:           ppfd: { min: 400, max: 600, unit: "µmol/m²/s" },
 584:           photoperiod: { hours: 14, maxHours: 16 },
 585:           dli: { min: 23.0, max: 34.6, unit: "mol/m²/day" },
 586:           notes: [
 587:             "Pinching off growing tips encourages bushier growth",
 588:             "Higher light intensity produces more essential oils and stronger flavor",
 589:           ],
 590:         },
 591:         flowering: {
 592:           ppfd: { min: 600, max: 1000, unit: "µmol/m²/s" },
 593:           photoperiod: { hours: 14, maxHours: 16 },
 594:           dli: { min: 34.6, max: 57.6, unit: "mol/m²/day" },
 595:           notes: [
 596:             "Flowering usually occurs around 6-8 weeks after planting",
 597:             "Pinch flower buds immediately to extend leaf harvest period",
 598:           ],
 599:         },
 600:       },
 601:       watering: {
 602:         seedling: {
 603:           trigger: { moistureLevel: "when surface begins to dry" },
 604:           target: { moistureLevel: "evenly moist but not waterlogged" },
 605:           volume: {
 606:             amount: "light applications",
 607:             frequency: "daily monitoring",
 608:           },
 609:           notes: [
 610:             "Consistent moisture during establishment phase",
 611:             "Avoid overwatering which can cause damping-off disease",
 612:           ],
 613:         },
 614:         vegetative: {
 615:           trigger: { moistureLevel: "when top inch becomes dry" },
 616:           target: { moistureLevel: "thoroughly moist" },
 617:           volume: {
 618:             amount: "moderate watering",
 619:             frequency: "every 2-3 days typically",
 620:           },
 621:           notes: [
 622:             "Allow slight drying between waterings once established",
 623:             "Deep, less frequent watering encourages strong root development",
 624:           ],
 625:         },
 626:         flowering: {
 627:           trigger: { moistureLevel: "when top inch becomes dry" },
 628:           target: { moistureLevel: "adequately moist" },
 629:           volume: {
 630:             amount: "consistent applications",
 631:             frequency: "as soil indicates",
 632:           },
 633:           notes: [
 634:             "Maintain consistent moisture during active harvest period",
 635:             "Avoid getting water on leaves to prevent fungal issues",
 636:           ],
 637:         },
 638:       },
 639:       fertilization: {
 640:         seedling: {
 641:           products: [
 642:             {
 643:               name: "Bio-Tone starter fertilizer",
 644:               dilution: "0.5 teaspoon per container",
 645:               amount: "light application at transplanting",
 646:               frequency: "one-time at transplant",
 647:               method: "mix-in-soil",
 648:             },
 649:           ],
 650:           timing: "At transplant to larger container",
 651:           notes: [
 652:             "Gentle introduction to feeding - basil responds well to organic fertilizers",
 653:           ],
 654:         },
 655:         vegetative: {
 656:           products: [
 657:             {
 658:               name: "Balanced organic fertilizer or compost tea",
 659:               dilution: "half strength initially",
 660:               amount: "light but regular feeding",
 661:               frequency: "every 2-3 weeks",
 662:             },
 663:           ],
 664:           timing: "Active growth phase",
 665:           notes: [
 666:             "Avoid excessive nitrogen which reduces essential oil concentration",
 667:             "Organic fertilizers produce better flavor than synthetic",
 668:           ],
 669:         },
 670:         flowering: {
 671:           products: [
 672:             {
 673:               name: "Reduced feeding if flowers are pinched",
 674:               dilution: "very light",
 675:               amount: "minimal applications",
 676:               frequency: "monthly if needed",
 677:             },
 678:           ],
 679:           timing: "If flowering occurs",
 680:           notes: [
 681:             "Reduce feeding to maintain leaf quality",
 682:             "Focus on preventing flowering rather than supporting it",
 683:           ],
 684:         },
 685:       },
 686:       environment: {
 687:         temperature: { min: 65, max: 80, optimal: 75, unit: "F" },
 688:         pH: { min: 6.0, max: 7.0, optimal: 6.5 },
 689:       },
 690:       soilMixture: {
 691:         components: {
 692:           "coco coir": 40,
 693:           perlite: 30,
 694:           vermiculite: 20,
 695:           compost: 10,
 696:         },
 697:         amendments: {
 698:           "worm castings": "1 tbsp per gallon",
 699:           "Bio-Tone": "0.5 teaspoon per container",
 700:         },
 701:       },
 702:       container: {
 703:         minSize: "2-gallon container (8 inch diameter)",
 704:         depth: "6-8 inches adequate for compact variety",
 705:       },
 706:       succession: {
 707:         interval: 14,
 708:         method: "continuous",
 709:         harvestMethod: "cut-and-come-again",
 710:         productiveWeeks: 8,
 711:         notes: [
 712:           "Succession every 2-3 weeks ensures continuous fresh leaves",
 713:           "Pinch flowers immediately to extend productive harvest period",
 714:         ],
 715:       },
 716:       specialRequirements: [
 717:         "Warmth-loving plant - keep soil temperature above 65°F",
 718:         "Pinch growing tips regularly to encourage bushy growth",
 719:         "Remove flower buds immediately to maintain leaf production",
 720:         "Harvest frequently to encourage new growth",
 721:         "Prefers well-draining soil - avoid waterlogged conditions",
 722:       ],
 723:     },
 724:   },
 725: 
 726:   {
 727:     name: "English Thyme",
 728:     category: "herbs",
 729:     isEverbearing: true,
 730:     productiveLifespan: 1095,
 731:     growthTimeline: {
 732:       germination: 14,
 733:       seedling: 21,
 734:       vegetative: 84,
 735:       maturation: 365,
 736:     },
 737:     protocols: {
 738:       lighting: {
 739:         seedling: {
 740:           ppfd: { min: 100, max: 300, unit: "µmol/m²/s" },
 741:           photoperiod: { hours: 10, maxHours: 14 },
 742:           dli: { min: 3.6, max: 15.1, unit: "mol/m²/day" },
 743:           notes: [
 744:             "Tiny seedlings emerge slowly - patience required",
 745:             "Soil temperature between 68-77°F critical for germination",
 746:           ],
 747:         },
 748:         vegetative: {
 749:           ppfd: { min: 300, max: 600, unit: "µmol/m²/s" },
 750:           photoperiod: { hours: 12, maxHours: 16 },
 751:           dli: { min: 13.0, max: 34.6, unit: "mol/m²/day" },
 752:           notes: [
 753:             "Leaves grow to about 1 inch long, becoming dark green and aromatic",
 754:             "Plant develops characteristic low, spreading growth habit",
 755:           ],
 756:         },
 757:         flowering: {
 758:           ppfd: { min: 600, max: 900, unit: "µmol/m²/s" },
 759:           photoperiod: { hours: 14, maxHours: 16 },
 760:           dli: { min: 30.2, max: 51.8, unit: "mol/m²/day" },
 761:           notes: [
 762:             "Small flowers appear in late spring to early summer",
 763:             "Flowers can be pink, lavender, or white depending on variety",
 764:           ],
 765:         },
 766:       },
 767:       watering: {
 768:         seedling: {
 769:           trigger: { moistureLevel: "when surface begins to dry" },
 770:           target: { moistureLevel: "barely moist" },
 771:           volume: {
 772:             amount: "very light applications",
 773:             frequency: "careful monitoring",
 774:           },
 775:           notes: [
 776:             "Critical period - overwatering kills more thyme seedlings than drought",
 777:             "Use spray bottle for gentle moisture application",
 778:           ],
 779:         },
 780:         vegetative: {
 781:           trigger: { moistureLevel: "when soil is dry 1-2 inches down" },
 782:           target: { moistureLevel: "lightly moist throughout" },
 783:           volume: {
 784:             amount: "moderate watering",
 785:             frequency: "infrequent but thorough",
 786:           },
 787:           notes: [
 788:             "Allow significant drying between waterings",
 789:             "Thyme tolerates drought better than excess moisture",
 790:           ],
 791:         },
 792:         flowering: {
 793:           trigger: { moistureLevel: "when soil is quite dry" },
 794:           target: { moistureLevel: "lightly moist" },
 795:           volume: {
 796:             amount: "minimal watering",
 797:             frequency: "only when necessary",
 798:           },
 799:           notes: [
 800:             "Established thyme is extremely drought tolerant",
 801:             "Excess water dilutes essential oils and reduces flavor intensity",
 802:           ],
 803:         },
 804:       },
 805:       fertilization: {
 806:         seedling: {
 807:           products: [
 808:             {
 809:               name: "Crushed oyster shell",
 810:               dilution: "0.5 teaspoon per container",
 811:               amount: "mixed into soil at planting",
 812:               frequency: "one-time soil amendment",
 813:               method: "mix-in-soil",
 814:             },
 815:           ],
 816:           timing: "At transplanting",
 817:           notes: [
 818:             "Provides slow-release calcium and helps with drainage",
 819:             "Mediterranean herbs prefer slightly alkaline conditions",
 820:           ],
 821:         },
 822:         vegetative: {
 823:           products: [
 824:             {
 825:               name: "Very dilute compost tea (optional)",
 826:               dilution: "quarter strength or less",
 827:               amount: "minimal application",
 828:               frequency: "monthly if at all",
 829:             },
 830:           ],
 831:           timing: "Growing season only",
 832:           notes: [
 833:             "Thyme actually performs better in lean soils",
 834:             "Too much fertility produces weak, less flavorful growth",
 835:           ],
 836:         },
 837:         flowering: {
 838:           notes: [
 839:             "No fertilization needed during flowering period",
 840:             "Plant has adapted to survive on minimal nutrients",
 841:           ],
 842:         },
 843:       },
 844:       environment: {
 845:         temperature: { min: 60, max: 80, optimal: 70, unit: "F" },
 846:         humidity: { min: 30, max: 50, optimal: 40 },
 847:         pH: { min: 6.0, max: 8.0, optimal: 6.5 },
 848:       },
 849:       soilMixture: {
 850:         components: {
 851:           "coco coir": 40,
 852:           perlite: 30,
 853:           "coarse sand": 20,
 854:           vermiculite: 10,
 855:         },
 856:         amendments: {
 857:           compost: "0.5 tablespoon per container (minimal)",
 858:           "crushed oyster shell": "0.5 teaspoon per container",
 859:         },
 860:       },
 861:       container: {
 862:         minSize: "2-gallon pot (8 inch diameter)",
 863:         depth: "6-8 inches adequate",
 864:         drainage: "Excellent drainage absolutely essential",
 865:       },
 866:       specialRequirements: [
 867:         "Excellent drainage absolutely critical - will not tolerate wet feet",
 868:         "Prefers lean, mineral soils over rich organic matter",
 869:         "Drought tolerant once established - err on side of underwatering",
 870:         "Benefits from good air circulation to prevent fungal issues",
 871:         "Harvest by cutting stems above woody growth to encourage branching",
 872:         "Extremely long-lived perennial if drainage requirements are met",
 873:       ],
 874:     },
 875:   },
 876: 
 877:   {
 878:     name: "Greek Oregano",
 879:     category: "herbs",
 880:     isEverbearing: true,
 881:     productiveLifespan: 730,
 882:     growthTimeline: {
 883:       germination: 14,
 884:       seedling: 28,
 885:       vegetative: 56,
 886:       maturation: 90,
 887:     },
 888:     protocols: {
 889:       lighting: {
 890:         seedling: {
 891:           ppfd: { min: 100, max: 300, unit: "µmol/m²/s" },
 892:           photoperiod: { hours: 10, maxHours: 14 },
 893:           dli: { min: 3.6, max: 15.1, unit: "mol/m²/day" },
 894:           notes: [
 895:             "Seeds germinate at 65-70°F soil temperature",
 896:             "Transplant when seedlings have four true leaves",
 897:           ],
 898:         },
 899:         vegetative: {
 900:           ppfd: { min: 300, max: 600, unit: "µmol/m²/s" },
 901:           photoperiod: { hours: 12, maxHours: 16 },
 902:           dli: { min: 13.0, max: 34.6, unit: "mol/m²/day" },
 903:           notes: [
 904:             "Plant develops more leaves and branches during this phase",
 905:             "Pinching and pruning encourage bushy growth habit",
 906:           ],
 907:         },
 908:         flowering: {
 909:           ppfd: { min: 500, max: 750, unit: "µmol/m²/s" },
 910:           photoperiod: { hours: 14, maxHours: 16 },
 911:           dli: { min: 25.2, max: 43.2, unit: "mol/m²/day" },
 912:           notes: [
 913:             "Small white flowers appear as plant reaches maturity",
 914:             "Harvest often best when plant is beginning to flower",
 915:           ],
 916:         },
 917:       },
 918:       watering: {
 919:         seedling: {
 920:           trigger: { moistureLevel: "when surface starts to dry" },
 921:           target: { moistureLevel: "evenly moist but not saturated" },
 922:           volume: {
 923:             amount: "light, frequent applications",
 924:             frequency: "daily monitoring",
 925:           },
 926:           notes: [
 927:             "Keep soil consistently moist during establishment",
 928:             "Avoid waterlogging which can cause root rot",
 929:           ],
 930:         },
 931:         vegetative: {
 932:           trigger: { moistureLevel: "when top inch is dry" },
 933:           target: { moistureLevel: "moderately moist throughout" },
 934:           volume: {
 935:             amount: "thorough but infrequent watering",
 936:             frequency: "every 2-4 days",
 937:           },
 938:           notes: [
 939:             "Allow some drying between waterings to encourage strong roots",
 940:             "Deep watering less frequently better than frequent shallow watering",
 941:           ],
 942:         },
 943:         flowering: {
 944:           trigger: { moistureLevel: "when soil is quite dry" },
 945:           target: { moistureLevel: "lightly moist" },
 946:           volume: { amount: "minimal watering", frequency: "only as needed" },
 947:           notes: [
 948:             "Mature oregano is quite drought tolerant",
 949:             "Reduce watering to concentrate essential oils for better flavor",
 950:           ],
 951:         },
 952:       },
 953:       fertilization: {
 954:         seedling: {
 955:           products: [
 956:             {
 957:               name: "Light compost incorporation",
 958:               dilution: "0.5 tablespoon per container",
 959:               amount: "mixed into soil at planting",
 960:               frequency: "one-time soil preparation",
 961:               method: "mix-in-soil",
 962:             },
 963:           ],
 964:           timing: "At container preparation",
 965:           notes: [
 966:             "Light organic matter supports establishment without overfeeding",
 967:           ],
 968:         },
 969:         vegetative: {
 970:           products: [
 971:             {
 972:               name: "Dilute compost tea or fish emulsion",
 973:               dilution: "quarter to half strength",
 974:               amount: "light application",
 975:               frequency: "monthly during active growth",
 976:             },
 977:           ],
 978:           timing: "Growing season",
 979:           notes: [
 980:             "Light feeding only - oregano prefers lean conditions",
 981:             "Overfertilization reduces essential oil concentration",
 982:           ],
 983:         },
 984:         flowering: {
 985:           notes: [
 986:             "Cease fertilization when flowering begins",
 987:             "Lean conditions during flowering concentrate flavor compounds",
 988:           ],
 989:         },
 990:       },
 991:       environment: {
 992:         temperature: { min: 65, max: 85, optimal: 75, unit: "F" },
 993:         humidity: { min: 30, max: 60, optimal: 45 },
 994:         pH: { min: 6.0, max: 8.0, optimal: 6.8 },
 995:       },
 996:       soilMixture: {
 997:         components: {
 998:           "coco coir": 40,
 999:           perlite: 30,
1000:           "coarse sand": 20,
1001:           vermiculite: 10,
1002:         },
1003:         amendments: {
1004:           compost: "0.5 tablespoon per container",
1005:           "crushed oyster shell": "0.5 teaspoon per container",
1006:         },
1007:       },
1008:       container: {
1009:         minSize: "12 inch diameter pot",
1010:         depth: "6-8 inches adequate for root system",
1011:       },
1012:       succession: {
1013:         interval: 0,
1014:         method: "single",
1015:         harvestMethod: "cut-and-come-again",
1016:         notes: [
1017:           "Harvest by cutting top third of stems above a node",
1018:           "Regular harvesting encourages new branching and continued production",
1019:         ],
1020:       },
1021:       specialRequirements: [
1022:         "Requires excellent drainage - will not tolerate waterlogged soil",
1023:         "Benefits from slightly alkaline soil conditions",
1024:         "Regular harvesting by cutting stems encourages bushier growth",
1025:         "Can be somewhat invasive if allowed to spread naturally",
1026:         "Winter protection may be needed in very cold climates",
1027:       ],
1028:     },
1029:   },
1030: 
1031:   {
1032:     name: "Albion Strawberries",
1033:     category: "berries",
1034:     isEverbearing: true,
1035:     productiveLifespan: 730,
1036:     growthTimeline: {
1037:       germination: 14,
1038:       seedling: 28,
1039:       vegetative: 42,
1040:       maturation: 90,
1041:     },
1042:     protocols: {
1043:       lighting: {
1044:         establishment: {
1045:           ppfd: { min: 200, max: 200, optimal: 200, unit: "µmol/m²/s" },
1046:           photoperiod: {
1047:             hours: 14,
1048:             maxHours: 16,
1049:             constraint: "day-neutral varieties require consistent photoperiod",
1050:           },
1051:           dli: { min: 10.1, max: 11.5, unit: "mol/m²/day" },
1052:           notes: [
1053:             "Remove flowers for the first 4-6 weeks to encourage strong plant establishment",
1054:             "Focus energy on root and crown development",
1055:           ],
1056:         },
1057:         vegetative: {
1058:           ppfd: { min: 300, max: 400, unit: "µmol/m²/s" },
1059:           photoperiod: {
1060:             hours: 16,
1061:             constraint:
1062:               "consistent 16h photoperiod is critical for continuous production",
1063:           },
1064:           dli: { min: 17.3, max: 23.0, unit: "mol/m²/day" },
1065:           notes: [
1066:             "Remove ALL runners as soon as they are spotted - check weekly",
1067:             "Energy must go to fruit production, not vegetative reproduction",
1068:           ],
1069:         },
1070:         flowering: {
1071:           ppfd: { min: 350, max: 400, unit: "µmol/m²/s" },
1072:           photoperiod: {
1073:             hours: 16,
1074:             constraint:
1075:               "critical for continuous flowering in day-neutral types",
1076:           },
1077:           dli: { min: 20.2, max: 23.0, unit: "mol/m²/day" },
1078:           notes: [
1079:             "Hand pollination is critical indoors",
1080:             "Use a small brush to transfer pollen every 1-2 days",
1081:           ],
1082:         },
1083:         fruiting: {
1084:           ppfd: { min: 450, max: 500, unit: "µmol/m²/s" },
1085:           photoperiod: { hours: 16 },
1086:           dli: { min: 25.9, max: 28.8, unit: "mol/m²/day" },
1087:           notes: [
1088:             "Higher light intensity supports fruit development and sugar accumulation",
1089:           ],
1090:         },
1091:         ongoingProduction: {
1092:           ppfd: { min: 350, max: 400, unit: "µmol/m²/s" },
1093:           photoperiod: { hours: 16 },
1094:           dli: { min: 20.2, max: 23.0, unit: "mol/m²/day" },
1095:           notes: [
1096:             "Monthly flush with pH-adjusted plain water until 20-30% runoff",
1097:             "Prevents salt buildup from intensive feeding",
1098:           ],
1099:         },
1100:       },
1101:       watering: {
1102:         establishment: {
1103:           trigger: { moistureLevel: "3-4" },
1104:           target: { moistureLevel: "6-7" },
1105:           volume: {
1106:             amount:
1107:               "5-gal: 20-30 oz (590-890 mL), 2-gal hanging: 8-10 oz (235-300 mL)",
1108:             frequency: "3-4x/week",
1109:             perPlant: true,
1110:           },
1111:           notes: [
1112:             "Remove flowers for first 4-6 weeks to encourage establishment",
1113:           ],
1114:         },
1115:         vegetative: {
1116:           trigger: { moistureLevel: "3-4" },
1117:           target: { moistureLevel: "6-7" },
1118:           volume: {
1119:             amount:
1120:               "5-gal: 25-35 oz (740-1030 mL), 2-gal hanging: 10-13 oz (300-385 mL)",
1121:             frequency: "3-5x/week",
1122:             perPlant: true,
1123:           },
1124:           notes: [
1125:             "Remove ALL runners as soon as spotted - weekly checks essential",
1126:           ],
1127:         },
1128:         flowering: {
1129:           trigger: { moistureLevel: "3-4" },
1130:           target: { moistureLevel: "6-7" },
1131:           volume: {
1132:             amount:
1133:               "5-gal: 30-35 oz (890-1030 mL), 2-gal hanging: 10-13 oz (300-385 mL)",
1134:             frequency: "4-5x/week",
1135:             perPlant: true,
1136:           },
1137:           notes: [
1138:             "Consistent moisture critical during flower and early fruit development",
1139:           ],
1140:         },
1141:         fruiting: {
1142:           trigger: { moistureLevel: "3-4" },
1143:           target: { moistureLevel: "6-7" },
1144:           volume: {
1145:             amount:
1146:               "5-gal: 30-35 oz (890-1030 mL), 2-gal hanging: 10-13 oz (300-385 mL)",
1147:             frequency: "4-5x/week",
1148:             perPlant: true,
1149:           },
1150:         },
1151:         ongoingProduction: {
1152:           trigger: { moistureLevel: "3-4" },
1153:           target: { moistureLevel: "6-7" },
1154:           volume: {
1155:             amount:
1156:               "5-gal: 25-35 oz (740-1030 mL), 2-gal hanging: 10-13 oz (300-385 mL)",
1157:             frequency: "3-5x/week",
1158:             perPlant: true,
1159:           },
1160:           notes: [
1161:             "Monthly flush: irrigate with pH-adjusted plain water until 20-30% runoff",
1162:           ],
1163:         },
1164:       },
1165:       fertilization: {
1166:         establishment: {
1167:           products: [
1168:             {
1169:               name: "Neptune's Harvest Fish + Seaweed",
1170:               dilution: "½ strength, 0.5 Tbsp/gal",
1171:               amount: "Week 2 application",
1172:               frequency: "one-time during establishment",
1173:             },
1174:             {
1175:               name: "Bone meal",
1176:               dilution: "1 Tbsp/5gal",
1177:               amount: "mixed at planting",
1178:               frequency: "at planting",
1179:               method: "mix-in-soil",
1180:             },
1181:           ],
1182:           timing: "Weeks 0-3",
1183:           notes: ["Remove flowers for first 4-6 weeks"],
1184:         },
1185:         vegetative: {
1186:           products: [
1187:             {
1188:               name: "Neptune's Harvest",
1189:               dilution: "½ strength",
1190:               amount: "Week 4, 6 applications",
1191:               frequency: "bi-weekly",
1192:             },
1193:             {
1194:               name: "Neptune's Harvest",
1195:               dilution: "full strength, 1 Tbsp/gal",
1196:               amount: "Week 5, 7 applications",
1197:               frequency: "bi-weekly",
1198:             },
1199:           ],
1200:           timing: "Weeks 4-6",
1201:           notes: [
1202:             "Remove flowers for first 4-6 weeks",
1203:             "Remove ALL runners weekly",
1204:           ],
1205:         },
1206:         flowering: {
1207:           products: [
1208:             {
1209:               name: "Espoma Berry-Tone",
1210:               dilution: "2 Tbsp/bag",
1211:               amount: "Week 8 application",
1212:               frequency: "one-time",
1213:               method: "top-dress",
1214:             },
1215:             {
1216:               name: "Kelp/sea-mineral",
1217:               dilution: "1 Tbsp/gal",
1218:               amount: "Week 9, 11 applications",
1219:               frequency: "bi-weekly",
1220:             },
1221:             {
1222:               name: "Bone meal",
1223:               dilution: "½ Tbsp/bag",
1224:               amount: "Week 10 application",
1225:               frequency: "one-time",
1226:               method: "top-dress",
1227:             },
1228:           ],
1229:           timing: "Weeks 7-8",
1230:           notes: ["Hand pollinate every 1-2 days during flowering"],
1231:         },
1232:         fruiting: {
1233:           products: [
1234:             {
1235:               name: "Kelp/sea-mineral",
1236:               dilution: "1 Tbsp/gal",
1237:               amount: "Week 13, 15 applications",
1238:               frequency: "bi-weekly",
1239:             },
1240:             {
1241:               name: "Fish & Seaweed + high-K supplement",
1242:               dilution: "as directed",
1243:               amount: "bi-weekly applications",
1244:               frequency: "every 2 weeks",
1245:             },
1246:           ],
1247:           timing: "Weeks 9-13",
1248:           notes: ["Harvest begins 4-5 weeks after flowering"],
1249:         },
1250:         ongoingProduction: {
1251:           products: [
1252:             {
1253:               name: "Kelp",
1254:               dilution: "1 Tbsp/gal",
1255:               amount: "Week 1 of cycle",
1256:               frequency: "alternating 2-week cycle",
1257:             },
1258:             {
1259:               name: "Berry-Tone",
1260:               dilution: "1 Tbsp/bag",
1261:               amount: "Week 3 of cycle",
1262:               frequency: "alternating 2-week cycle",
1263:               method: "top-dress",
1264:             },
1265:           ],
1266:           timing: "Week 14+",
1267:           notes: [
1268:             "Monthly flush with pH-adjusted water to prevent salt buildup",
1269:           ],
1270:         },
1271:       },
1272:       environment: {
1273:         pH: { min: 5.8, max: 6.5, optimal: 6.2 },
1274:       },
1275:       soilMixture: {
1276:         components: {
1277:           "coco coir": 35,
1278:           perlite: 25,
1279:           compost: 20,
1280:           "worm castings": 15,
1281:           vermiculite: 5,
1282:         },
1283:         amendments: {
1284:           "bone meal": "1 Tbsp per gallon of mix at planting",
1285:           "rock dust": "¼ cup per 5-gal bag",
1286:         },
1287:       },
1288:       specialRequirements: [
1289:         "Day-neutral varieties require consistent 16-hour photoperiod for continuous production",
1290:         "Hand pollination essential indoors - use small brush every 1-2 days during flowering",
1291:         "Remove ALL runners immediately to focus energy on fruit production",
1292:         "Remove flowers for first 4-6 weeks to establish strong root system",
1293:         "Monthly salt flush prevents nutrient lockout from intensive feeding",
1294:         "Replace plants every 2 years when productivity declines",
1295:       ],
1296:     },
1297:   },
1298: 
1299:   {
1300:     name: "Caroline Raspberries",
1301:     category: "berries",
1302:     isEverbearing: true,
1303:     productiveLifespan: 1095,
1304:     growthTimeline: {
1305:       germination: 0,
1306:       seedling: 21,
1307:       vegetative: 42,
1308:       maturation: 120,
1309:     },
1310:     protocols: {
1311:       lighting: {
1312:         caneEstablishment: {
1313:           ppfd: { min: 200, max: 300, unit: "µmol/m²/s" },
1314:           photoperiod: { hours: 16, maxHours: 18 },
1315:           dli: { min: 11.5, max: 19.4, unit: "mol/m²/day" },
1316:           notes: [
1317:             "Focus on establishing strong root system and cane structure",
1318:           ],
1319:         },
1320:         vegetative: {
1321:           ppfd: { min: 300, max: 400, unit: "µmol/m²/s" },
1322:           photoperiod: { hours: 16 },
1323:           dli: { min: 17.3, max: 23.0, unit: "mol/m²/day" },
1324:         },
1325:         floweringFruiting: {
1326:           ppfd: { min: 400, max: 600, unit: "µmol/m²/s" },
1327:           photoperiod: { hours: 14, maxHours: 16 },
1328:           dli: { min: 22.7, max: 34.6, unit: "mol/m²/day" },
1329:           notes: [
1330:             "Higher light intensity supports fruit development and sugar content",
1331:           ],
1332:         },
1333:         ongoing: {
1334:           ppfd: { min: 350, max: 500, unit: "µmol/m²/s" },
1335:           photoperiod: { hours: 16 },
1336:           dli: { min: 20.2, max: 28.8, unit: "mol/m²/day" },
1337:         },
1338:       },
1339:       watering: {
1340:         caneEstablishment: {
1341:           trigger: { moistureLevel: "3-4" },
1342:           target: { moistureLevel: "6-7" },
1343:           volume: {
1344:             amount: "monitor with soil moisture meter",
1345:             frequency: "as needed",
1346:           },
1347:           notes: ["Always water until slight drainage occurs"],
1348:         },
1349:         vegetative: {
1350:           trigger: { moistureLevel: "3-4" },
1351:           target: { moistureLevel: "6-7" },
1352:           volume: {
1353:             amount: "monitor with soil moisture meter",
1354:             frequency: "as needed",
1355:           },
1356:         },
1357:         floweringFruiting: {
1358:           trigger: { moistureLevel: "3-4" },
1359:           target: { moistureLevel: "7-8" },
1360:           volume: {
1361:             amount: "monitor with soil moisture meter",
1362:             frequency: "as needed",
1363:           },
1364:           notes: ["Higher moisture during fruit development"],
1365:         },
1366:         ongoing: {
1367:           trigger: { moistureLevel: "3-4" },
1368:           target: { moistureLevel: "6-7" },
1369:           volume: {
1370:             amount: "monitor with soil moisture meter",
1371:             frequency: "as needed",
1372:           },
1373:         },
1374:       },
1375:       fertilization: {
1376:         caneEstablishment: {
1377:           products: [
1378:             {
1379:               name: "Compost top-dress",
1380:               dilution: "1-2 inches",
1381:               amount: "at planting",
1382:               frequency: "at planting",
1383:               method: "top-dress",
1384:             },
1385:           ],
1386:         },
1387:         vegetative: {
1388:           products: [
1389:             {
1390:               name: "Fish Emulsion",
1391:               dilution: "1-2 tbsp/gallon",
1392:               amount: "as needed",
1393:               frequency: "every 2-4 weeks",
1394:             },
1395:           ],
1396:         },
1397:         floweringFruiting: {
1398:           products: [
1399:             {
1400:               name: "Liquid Kelp + balanced organic fertilizer",
1401:               dilution: "as directed",
1402:               amount: "as needed",
1403:               frequency: "every 2-3 weeks",
1404:             },
1405:             {
1406:               name: "Kelp Extract + K-rich formula",
1407:               dilution: "as directed",
1408:               amount: "as needed",
1409:               frequency: "every 1-2 weeks",
1410:             },
1411:           ],
1412:           notes: ["Higher potassium supports fruit development and flavor"],
1413:         },
1414:         ongoing: {
1415:           products: [
1416:             {
1417:               name: "Aerobically brewed compost tea",
1418:               dilution: "as brewed",
1419:               amount: "monthly applications",
1420:               frequency: "monthly",
1421:             },
1422:           ],
1423:         },
1424:       },
1425:       environment: {
1426:         pH: { min: 5.8, max: 6.5, optimal: 6.0 },
1427:       },
1428:       soilMixture: {
1429:         components: {
1430:           "compost (equal parts worm castings and composted manure)": 50,
1431:           "peat moss": 20,
1432:           perlite: 20,
1433:           "pine bark fines": 10,
1434:         },
1435:         amendments: {
1436:           "bone meal": "2.7 tbsp per 10-gallon container",
1437:           "dried blood meal": "1.3 tbsp per 10-gallon container",
1438:         },
1439:       },
1440:       container: {
1441:         minSize: "2 × 10-gallon containers per plant",
1442:         depth: "12 inches minimum",
1443:       },
1444:       specialRequirements: [
1445:         "Primocane-fruiting variety produces on current year's canes",
1446:         "Requires strong trellis system for support",
1447:         "Prune spent canes after harvest to encourage new growth",
1448:         "Benefits from good air circulation to prevent fungal issues",
1449:         "Hand pollination by gently shaking plants during flowering",
1450:       ],
1451:     },
1452:   },
1453:   {
1454:     name: "Little Finger Carrots",
1455:     category: "root-vegetables",
1456:     isEverbearing: false,
1457:     growthTimeline: {
1458:       germination: 14,
1459:       seedling: 14,
1460:       vegetative: 28,
1461:       maturation: 70,
1462:     },
1463:     protocols: {
1464:       lighting: {
1465:         germination: {
1466:           ppfd: { min: 100, max: 150, unit: "µmol/m²/s" },
1467:           photoperiod: {
1468:             hours: 12,
1469:             maxHours: 12,
1470:             constraint: "strict maximum to prevent bolting",
1471:           },
1472:           dli: { min: 4.3, max: 6.5, unit: "mol/m²/day" },
1473:           notes: [
1474:             "Maintain consistent moisture",
1475:             "Critical photoperiod control",
1476:           ],
1477:         },
1478:         seedling: {
1479:           ppfd: { min: 150, max: 300, unit: "µmol/m²/s" },
1480:           photoperiod: {
1481:             hours: 12,
1482:             maxHours: 12,
1483:             constraint: "photoperiods >12h may trigger premature bolting",
1484:           },
1485:           dli: { min: 6.5, max: 13.0, unit: "mol/m²/day" },
1486:           notes: ["Critical photoperiod - max 12 hours"],
1487:         },
1488:         vegetative: {
1489:           ppfd: { min: 200, max: 200, optimal: 200, unit: "µmol/m²/s" },
1490:           photoperiod: {
1491:             hours: 12,
1492:             maxHours: 12,
1493:             constraint:
1494:               "photoperiods >12h may trigger premature bolting, especially if warm",
1495:           },
1496:           dli: { min: 8.6, max: 8.6, unit: "mol/m²/day" },
1497:           notes: ["Strict 12-hour maximum", "Especially critical if warm"],
1498:         },
1499:         rootDevelopment: {
1500:           ppfd: { min: 300, max: 600, unit: "µmol/m²/s" },
1501:           photoperiod: {
1502:             hours: 12,
1503:             maxHours: 12,
1504:             constraint: "maintain strict limit",
1505:           },
1506:           dli: { min: 13.0, max: 25.9, unit: "mol/m²/day" },
1507:           notes: [
1508:             "Consistent moisture prevents splitting",
1509:             "21-day succession",
1510:           ],
1511:         },
1512:       },
1513:       watering: {
1514:         germination: {
1515:           trigger: {
1516:             moistureLevel: "surface dry",
1517:             description: "Keep surface moist",
1518:           },
1519:           target: { moistureLevel: "6-7", description: "top inch" },
1520:           volume: { amount: "8-12 oz", frequency: "daily" },
1521:           notes: ["Maintain consistent moisture"],
1522:         },
1523:         seedling: {
1524:           trigger: { moistureLevel: "4-5" },
1525:           target: { moistureLevel: "6-7" },
1526:           volume: { amount: "16-24 oz", frequency: "every 2-3 days" },
1527:         },
1528:         vegetative: {
1529:           trigger: { moistureLevel: "3-4" },
1530:           target: { moistureLevel: "6-7" },
1531:           volume: { amount: "24-32 oz", frequency: "every 2-4 days" },
1532:           notes: [
1533:             "Photoperiods >12h may trigger premature bolting, especially if warm",
1534:           ],
1535:         },
1536:         rootDevelopment: {
1537:           trigger: { moistureLevel: "3-4" },
1538:           target: { moistureLevel: "6-7" },
1539:           volume: { amount: "32-40 oz", frequency: "every 3-4 days" },
1540:           notes: [
1541:             "Consistent moisture prevents splitting",
1542:             "21-day succession",
1543:           ],
1544:         },
1545:       },
1546:       fertilization: {
1547:         germination: {
1548:           notes: ["None until true leaves appear"],
1549:         },
1550:         seedling: {
1551:           products: [
1552:             {
1553:               name: "Worm Casting Tea",
1554:               dilution: "1 part castings:10 parts water, steep 12-24h",
1555:               amount: "apply as needed",
1556:               frequency: "every 1-2 weeks",
1557:             },
1558:             {
1559:               name: "Fish Emulsion (alternative)",
1560:               dilution: "0.5-1 Tbsp/gal",
1561:               amount: "apply as needed",
1562:               frequency: "every 2-3 weeks",
1563:             },
1564:           ],
1565:           timing: "Weeks 3-5",
1566:         },
1567:         vegetative: {
1568:           products: [
1569:             {
1570:               name: "Lower-N Fish Emulsion",
1571:               dilution: "1 Tbsp/gal",
1572:               amount: "apply as needed",
1573:               frequency: "every 2-3 weeks",
1574:             },
1575:             {
1576:               name: "Worm Casting Tea",
1577:               dilution: "1 part castings:10 parts water",
1578:               amount: "apply as needed",
1579:               frequency: "every 1-2 weeks",
1580:             },
1581:             {
1582:               name: "Liquid Kelp/Seaweed Extract",
1583:               dilution: "1-2 Tbsp/gal",
1584:               amount: "apply as needed",
1585:               frequency: "every 2-3 weeks",
1586:             },
1587:           ],
1588:           timing: "Weeks 5/6 to Harvest",
1589:         },
1590:         rootDevelopment: {
1591:           products: [
1592:             {
1593:               name: "Continue same as vegetative",
1594:               dilution: "as above",
1595:               amount: "as above",
1596:               frequency: "as above",
1597:             },
1598:           ],
1599:         },
1600:       },
1601:       environment: {
1602:         pH: { min: 6.0, max: 6.8, optimal: 6.5 },
1603:       },
1604:       soilMixture: {
1605:         components: {
1606:           "coco coir": 40,
1607:           perlite: 30,
1608:           vermiculite: 25,
1609:           "coarse sand (2-4mm)": 5,
1610:         },
1611:       },
1612:       container: {
1613:         depth: "12 inches minimum",
1614:         staging: {
1615:           final:
1616:             "Direct sow only - avoid transplanting to prevent root deformities",
1617:         },
1618:       },
1619:       succession: {
1620:         interval: 21,
1621:         method: "zoned",
1622:         harvestMethod: "single-harvest",
1623:         notes: ["Divide bed into zones", "Sow new zone every 3 weeks"],
1624:       },
1625:       specialRequirements: [
1626:         "Strict 12-hour photoperiod maximum",
1627:         "Direct sow only - no transplanting",
1628:         "Stone-free soil essential for straight roots",
1629:         "Fresh manure causes forking - avoid",
1630:       ],
1631:     },
1632:   },
1633: 
1634:   {
1635:     name: "Astro Arugula",
1636:     category: "leafy-greens",
1637:     isEverbearing: true,
1638:     productiveLifespan: 56,
1639:     growthTimeline: {
1640:       germination: 5,
1641:       seedling: 14,
1642:       vegetative: 14,
1643:       maturation: 37,
1644:     },
1645:     protocols: {
1646:       lighting: {
1647:         germination: {
1648:           ppfd: { min: 70, max: 150, unit: "µmol/m²/s" },
1649:           photoperiod: { hours: 12, maxHours: 12 },
1650:           dli: { min: 3.0, max: 6.5, unit: "mol/m²/day" },
1651:           notes: ["Keep soil warm 60-70°F", "Even moisture"],
1652:         },
1653:         seedling: {
1654:           ppfd: { min: 150, max: 250, unit: "µmol/m²/s" },
1655:           photoperiod: { hours: 10, maxHours: 12 },
1656:           dli: { min: 5.4, max: 10.8, unit: "mol/m²/day" },
1657:           notes: ["Keep soil warm 60-70°F", "Even moisture"],
1658:         },
1659:         vegetative: {
1660:           ppfd: { min: 200, max: 250, unit: "µmol/m²/s" },
1661:           photoperiod: { hours: 10, maxHours: 12 },
1662:           dli: { min: 7.2, max: 10.8, unit: "mol/m²/day" },
1663:         },
1664:         postHarvestRegrowth: {
1665:           ppfd: { min: 200, max: 250, unit: "µmol/m²/s" },
1666:           photoperiod: { hours: 10, maxHours: 12 },
1667:           dli: { min: 7.2, max: 10.8, unit: "mol/m²/day" },
1668:           notes: ["14-day succession interval", "Cut-and-come-again"],
1669:         },
1670:       },
1671:       watering: {
1672:         germination: {
1673:           trigger: { moistureLevel: "3-4" },
1674:           target: { moistureLevel: "6-7" },
1675:           volume: { amount: "2-4 fl oz (60-120 mL)", frequency: "2-3x/week" },
1676:           notes: ["Keep soil warm (60-70°F)", "Even moisture"],
1677:         },
1678:         seedling: {
1679:           trigger: { moistureLevel: "3-4" },
1680:           target: { moistureLevel: "6-7" },
1681:           volume: { amount: "2-4 fl oz (60-120 mL)", frequency: "2-3x/week" },
1682:           notes: ["Keep soil warm (60-70°F)", "Even moisture"],
1683:         },
1684:         vegetative: {
1685:           trigger: { moistureLevel: "3-4" },
1686:           target: { moistureLevel: "6-7" },
1687:           volume: { amount: "8-12 fl oz (240-350 mL)", frequency: "2-3x/week" },
1688:         },
1689:         postHarvestRegrowth: {
1690:           trigger: { moistureLevel: "3-4" },
1691:           target: { moistureLevel: "6-7" },
1692:           volume: {
1693:             amount: "12-16 fl oz (350-470 mL)",
1694:             frequency: "2-3x/week",
1695:           },
1696:           notes: ["14-day succession interval"],
1697:         },
1698:       },
1699:       fertilization: {
1700:         germination: {
1701:           notes: ["None until true leaves appear"],
1702:         },
1703:         seedling: {
1704:           products: [
1705:             {
1706:               name: "Fish Emulsion",
1707:               dilution: "1-2 Tbsp/gal",
1708:               amount: "apply as needed",
1709:               frequency: "every 2 weeks",
1710:             },
1711:           ],
1712:         },
1713:         vegetative: {
1714:           products: [
1715:             {
1716:               name: "Fish Emulsion",
1717:               dilution: "1-2 Tbsp/gal",
1718:               amount: "apply as needed",
1719:               frequency: "every 2 weeks",
1720:             },
1721:           ],
1722:         },
1723:         postHarvestRegrowth: {
1724:           products: [
1725:             {
1726:               name: "Fish Emulsion",
1727:               dilution: "1-2 Tbsp/gal",
1728:               amount: "apply as needed",
1729:               frequency: "every 2 weeks",
1730:             },
1731:           ],
1732:         },
1733:       },
1734:       environment: {
1735:         temperature: { min: 60, max: 70, optimal: 65, unit: "F" },
1736:         pH: { min: 6.0, max: 7.0, optimal: 6.5 },
1737:       },
1738:       soilMixture: {
1739:         components: {
1740:           "coco coir": 40,
1741:           perlite: 25,
1742:           vermiculite: 25,
1743:           "worm castings": 10,
1744:         },
1745:         amendments: {
1746:           "additional compost or organic 4-4-4 granular fertilizer":
1747:             "½–1 cup per cubic foot",
1748:         },
1749:       },
1750:       container: {
1751:         depth: "4-6 inches",
1752:         staging: {
1753:           seedling: "Cell tray",
1754:           intermediate: "4 inch pot",
1755:           final: "4-6 inch pot or bed section",
1756:         },
1757:       },
1758:       succession: {
1759:         interval: 14,
1760:         method: "continuous",
1761:         harvestMethod: "cut-and-come-again",
1762:         productiveWeeks: 8,
1763:         notes: [
1764:           "Baby leaves ~21 days",
1765:           "Full flavor ~37-40 days",
1766:           "6-8 weeks productive per plant",
1767:         ],
1768:       },
1769:       specialRequirements: [
1770:         "Strict photoperiod control prevents bolting",
1771:         "Cut outer leaves only, leave center intact",
1772:         "Temperature control critical in warm conditions",
1773:       ],
1774:     },
1775:   },
1776:   {
1777:     name: "Detroit Dark Red Beets",
1778:     category: "root-vegetables",
1779:     isEverbearing: false,
1780:     growthTimeline: {
1781:       germination: 7,
1782:       seedling: 14,
1783:       vegetative: 21,
1784:       maturation: 60,
1785:     },
1786:     protocols: {
1787:       lighting: {
1788:         germination: {
1789:           ppfd: { min: 100, max: 200, unit: "µmol/m²/s" },
1790:           photoperiod: { hours: 12, maxHours: 14 },
1791:           dli: { min: 4.3, max: 10.1, unit: "mol/m²/day" },
1792:           notes: ["Ideal temp: 70-85°F for germination"],
1793:         },
1794:         vegetative: {
1795:           ppfd: { min: 250, max: 400, unit: "µmol/m²/s" },
1796:           photoperiod: { hours: 12, maxHours: 14 },
1797:           dli: { min: 10.8, max: 20.2, unit: "mol/m²/day" },
1798:           notes: ["Temperatures >75°F can cause bolting"],
1799:         },
1800:         rootDevelopment: {
1801:           ppfd: { min: 400, max: 600, unit: "µmol/m²/s" },
1802:           photoperiod: { hours: 12, maxHours: 14 },
1803:           dli: { min: 17.3, max: 30.2, unit: "mol/m²/day" },
1804:           notes: ["Maintain consistent moisture"],
1805:         },
1806:         maturation: {
1807:           ppfd: { min: 300, max: 450, unit: "µmol/m²/s" },
1808:           photoperiod: { hours: 12, maxHours: 14 },
1809:           dli: { min: 13.0, max: 22.7, unit: "mol/m²/day" },
1810:           notes: ["21-day succession"],
1811:         },
1812:       },
1813:       watering: {
1814:         germination: {
1815:           trigger: { moistureLevel: "surface dry" },
1816:           target: { moistureLevel: "7-8" },
1817:           volume: { amount: "8-12 oz per session", frequency: "daily misting" },
1818:           notes: ["Ideal temp: 70-85°F (21-29°C) for germination"],
1819:         },
1820:         vegetative: {
1821:           trigger: { moistureLevel: "4-5 (weeks 1-3), 3-4 (weeks 3-6)" },
1822:           target: { moistureLevel: "7-8 (weeks 1-3), 6-7 (weeks 3-6)" },
1823:           volume: {
1824:             amount: "16-20 oz (weeks 1-3), 20-24 oz (weeks 3-6)",
1825:             frequency: "every 2-3 days (weeks 1-3), every 3-4 days (weeks 3-6)",
1826:           },
1827:           notes: ["Temperatures >75°F (24°C) can cause bolting"],
1828:         },
1829:         rootDevelopment: {
1830:           trigger: { moistureLevel: "3-4" },
1831:           target: { moistureLevel: "6-7" },
1832:           volume: { amount: "24-28 oz", frequency: "every 3-4 days" },
1833:           notes: ["Maintain consistent moisture"],
1834:         },
1835:         maturation: {
1836:           trigger: { moistureLevel: "2-3" },
1837:           target: { moistureLevel: "5-6" },
1838:           volume: { amount: "20-24 oz", frequency: "every 4-5 days" },
1839:           notes: ["21-day succession"],
1840:         },
1841:       },
1842:       fertilization: {
1843:         germination: {
1844:           notes: ["None during germination"],
1845:         },
1846:         vegetative: {
1847:           products: [
1848:             {
1849:               name: "Diluted fish/kelp tea",
1850:               dilution: "¼ strength",
1851:               amount: "apply after 2nd true leaf",
1852:               frequency: "weeks 1-3",
1853:             },
1854:             {
1855:               name: "Worm castings + bone meal",
1856:               dilution: "1 tbsp worm castings + 1 tbsp bone meal per container",
1857:               amount: "at transplant",
1858:               frequency: "weeks 3-6",
1859:             },
1860:           ],
1861:         },
1862:         rootDevelopment: {
1863:           products: [
1864:             {
1865:               name: "Liquid kelp or fish + seaweed",
1866:               dilution: "1 tbsp/gal",
1867:               amount: "apply as needed",
1868:               frequency: "every 2 weeks",
1869:             },
1870:             {
1871:               name: "Kelp meal for boron",
1872:               dilution: "as directed",
1873:               amount: "supplement",
1874:               frequency: "as needed",
1875:             },
1876:           ],
1877:         },
1878:         maturation: {
1879:           notes: ["Stop feeding 10–14 days before harvest"],
1880:         },
1881:       },
1882:       environment: {
1883:         temperature: { min: 65, max: 75, optimal: 70, unit: "F" },
1884:         pH: { min: 6.5, max: 7.0, optimal: 6.8 },
1885:       },
1886:       soilMixture: {
1887:         components: {
1888:           "coco coir": 40,
1889:           perlite: 30,
1890:           vermiculite: 25,
1891:           "compost (or worm castings)": 5,
1892:         },
1893:         amendments: {
1894:           "compost or worm castings": "2 tbsp per gallon",
1895:           "Epsom salts": "1 tsp per gallon",
1896:           "bone meal": "1 tbsp per gallon",
1897:         },
1898:       },
1899:       container: {
1900:         depth: "10 inches minimum",
1901:       },
1902:       succession: {
1903:         interval: 21,
1904:         method: "zoned",
1905:         harvestMethod: "selective",
1906:         notes: ["Can harvest greens at 30-40 days", "Roots ready 50-70 days"],
1907:       },
1908:       specialRequirements: [
1909:         "Sensitive to boron deficiency",
1910:         "Avoid high nitrogen after seedling stage",
1911:         "Can be direct sown or carefully transplanted",
1912:       ],
1913:     },
1914:   },
1915: 
1916:   {
1917:     name: "Beauregard Sweet Potatoes",
1918:     category: "root-vegetables",
1919:     isEverbearing: false,
1920:     growthTimeline: {
1921:       germination: 14,
1922:       seedling: 21,
1923:       vegetative: 42,
1924:       maturation: 100,
1925:     },
1926:     protocols: {
1927:       lighting: {
1928:         slipProduction: {
1929:           ppfd: { min: 200, max: 200, optimal: 200, unit: "µmol/m²/s" },
1930:           photoperiod: { hours: 14, maxHours: 16 },
1931:           dli: { min: 10.1, max: 11.5, unit: "mol/m²/day" },
1932:           notes: ["High humidity 85-90%", "Temp: 75-80°F"],
1933:         },
1934:         vegetativeGrowth: {
1935:           ppfd: { min: 350, max: 600, unit: "µmol/m²/s" },
1936:           photoperiod: { hours: 14, maxHours: 16 },
1937:           dli: { min: 17.6, max: 34.6, unit: "mol/m²/day" },
1938:           notes: ["Vigorous vine growth phase"],
1939:         },
1940:         tuberDevelopment: {
1941:           ppfd: { min: 600, max: 800, unit: "µmol/m²/s" },
1942:           photoperiod: {
1943:             hours: 10,
1944:             maxHours: 12,
1945:             constraint: "reduce photoperiod to trigger tuber formation",
1946:           },
1947:           dli: { min: 21.6, max: 34.6, unit: "mol/m²/day" },
1948:           notes: ["Critical photoperiod reduction for tuberization"],
1949:         },
1950:         maturation: {
1951:           ppfd: { min: 500, max: 600, unit: "µmol/m²/s" },
1952:           photoperiod: { hours: 8, maxHours: 10 },
1953:           dli: { min: 14.4, max: 21.6, unit: "mol/m²/day" },
1954:           notes: ["Further photoperiod reduction"],
1955:         },
1956:       },
1957:       watering: {
1958:         slipProduction: {
1959:           trigger: { moistureLevel: "top 1 inch dry (~4-5)" },
1960:           target: { moistureLevel: "adequate moisture" },
1961:           volume: {
1962:             amount: "16-20 oz (470-590 mL)/plant",
1963:             frequency: "daily for first week, then every 1-2 days",
1964:           },
1965:           notes: ["High humidity (85-90%)", "Temp: 75-80°F (24-27°C)"],
1966:         },
1967:         vegetativeGrowth: {
1968:           trigger: { moistureLevel: "top 1-2 inches dry (~4)" },
1969:           target: { moistureLevel: "adequate moisture" },
1970:           volume: {
1971:             amount: "30-40 oz (890-1200 mL)/plant",
1972:             frequency: "2x per week",
1973:           },
1974:           notes: ["Vigorous vine growth phase"],
1975:         },
1976:         tuberDevelopment: {
1977:           trigger: { moistureLevel: "top 2 inches dry (~3-4)" },
1978:           target: { moistureLevel: "adequate moisture" },
1979:           volume: { amount: "40-48 oz (1200-1400 mL)", frequency: "2x/week" },
1980:           notes: ["Reduce photoperiod to trigger tuber formation"],
1981:         },
1982:         maturation: {
1983:           trigger: { moistureLevel: "top 2-3 inches dry (~3)" },
1984:           target: { moistureLevel: "minimal" },
1985:           volume: {
1986:             amount: "12-20 oz (350-590 mL)/plant",
1987:             frequency: "1x/week then stop completely 3-7 days pre-harvest",
1988:           },
1989:           notes: ["Final phase preparation"],
1990:         },
1991:       },
1992:       fertilization: {
1993:         slipProduction: {
1994:           products: [
1995:             {
1996:               name: "Beauregard: Soil amendments at planting",
1997:               dilution: "N/A",
1998:               amount: "soil prep",
1999:               frequency: "at planting",
2000:             },
2001:             {
2002:               name: "Jewel: Neptune's Harvest (likely ½ strength)",
2003:               dilution: "½ strength",
2004:               amount: "Wk 1 & 2",
2005:               frequency: "weekly",
2006:             },
2007:             {
2008:               name: "Tomato & Veg Formula (2-4-2)",
2009:               dilution: "as directed",
2010:               amount: "for establishment",
2011:               frequency: "Wk 1 & 2",
2012:             },
2013:           ],
2014:         },
2015:         vegetativeGrowth: {
2016:           products: [
2017:             {
2018:               name: "Beauregard: Blood Meal",
2019:               dilution: "0.5c bed / 5 Tbsp bag",
2020:               amount: "at Wk 4-5",
2021:               frequency: "once",
2022:             },
2023:             {
2024:               name: "Jewel: Blood Meal + Fish & Seaweed Blend",
2025:               dilution: "as directed",
2026:               amount: "Wk 4-5",
2027:               frequency: "as directed",
2028:             },
2029:           ],
2030:         },
2031:         tuberDevelopment: {
2032:           products: [
2033:             {
2034:               name: "Beauregard: Kelp Meal",
2035:               dilution: "0.75c bed / 7.5 Tbsp bag",
2036:               amount: "Wk 8-9",
2037:               frequency: "once",
2038:             },
2039:             {
2040:               name: "Foliar K₂SO₄",
2041:               dilution: "1-2 Tbsp/gal",
2042:               amount: "foliar spray",
2043:               frequency: "Wk 10-11",
2044:               method: "foliar-spray",
2045:             },
2046:             {
2047:               name: "2nd Kelp Meal",
2048:               dilution: "as above",
2049:               amount: "Wk 12-13",
2050:               frequency: "once",
2051:             },
2052:           ],
2053:         },
2054:         maturation: {
2055:           products: [
2056:             {
2057:               name: "Final K₂SO₄/KNO₃",
2058:               dilution: "as directed",
2059:               amount: "for skin set",
2060:               frequency: "2-3 wks pre-harvest",
2061:             },
2062:           ],
2063:           notes: ["Cease all feeding 3-4 wks pre-harvest"],
2064:         },
2065:       },
2066:       environment: {
2067:         temperature: {
2068:           min: 75,
2069:           max: 85,
2070:           optimal: 80,
2071:           unit: "F",
2072:           stage: "tuber development",
2073:         },
2074:         humidity: { min: 85, max: 90, optimal: 87 },
2075:         pH: { min: 5.8, max: 6.2, optimal: 6.0 },
2076:       },
2077:       soilMixture: {
2078:         components: {
2079:           "coco coir": 40,
2080:           perlite: 30,
2081:           vermiculite: 25,
2082:           "sandy loam": 5,
2083:         },
2084:         amendments: {
2085:           "well-rotted manure": "3 tbsp per gallon",
2086:         },
2087:       },
2088:       container: {
2089:         depth: "18-24 inches",
2090:         staging: {
2091:           final: "Large containers for extensive root system",
2092:         },
2093:       },
2094:       succession: {
2095:         interval: 0,
2096:         method: "single",
2097:         harvestMethod: "single-harvest",
2098:         notes: ["Long cycle (90-120 days) best for single large harvest"],
2099:       },
2100:       specialRequirements: [
2101:         "Post-harvest curing at 80-85°F with high humidity for 5-10 days",
2102:         "Critical photoperiod reduction for tuberization",
2103:         "Soil temperature 75-85°F optimal for tuber development",
2104:       ],
2105:     },
2106:   },
2107: 
2108:   {
2109:     name: "Baby's Leaf Spinach",
2110:     category: "leafy-greens",
2111:     isEverbearing: true,
2112:     productiveLifespan: 42,
2113:     growthTimeline: {
2114:       germination: 7,
2115:       seedling: 14,
2116:       vegetative: 14,
2117:       maturation: 45,
2118:     },
2119:     protocols: {
2120:       lighting: {
2121:         germination: {
2122:           ppfd: { min: 100, max: 150, unit: "µmol/m²/s" },
2123:           photoperiod: { hours: 12, maxHours: 14 },
2124:           dli: { min: 4.3, max: 7.6, unit: "mol/m²/day" },
2125:           notes: ["Keep consistent temperature"],
2126:         },
2127:         seedling: {
2128:           ppfd: { min: 150, max: 200, unit: "µmol/m²/s" },
2129:           photoperiod: { hours: 12, maxHours: 14 },
2130:           dli: { min: 6.5, max: 10.1, unit: "mol/m²/day" },
2131:         },
2132:         transplant: {
2133:           ppfd: { min: 200, max: 250, unit: "µmol/m²/s" },
2134:           photoperiod: { hours: 12, maxHours: 14 },
2135:           dli: { min: 8.6, max: 12.6, unit: "mol/m²/day" },
2136:         },
2137:         vegetativeHarvest: {
2138:           ppfd: { min: 250, max: 250, optimal: 250, unit: "µmol/m²/s" },
2139:           photoperiod: { hours: 12, maxHours: 14 },
2140:           dli: { min: 10.8, max: 12.6, unit: "mol/m²/day" },
2141:           notes: ["14-day succession interval"],
2142:         },
2143:       },
2144:       watering: {
2145:         germination: {
2146:           trigger: { moistureLevel: "less than 4" },
2147:           target: { moistureLevel: 6 },
2148:           volume: { amount: "mist as needed", frequency: "daily" },
2149:         },
2150:         seedling: {
2151:           trigger: { moistureLevel: "less than 4" },
2152:           target: { moistureLevel: 6 },
2153:           volume: { amount: "mist as needed", frequency: "as needed" },
2154:         },
2155:         transplant: {
2156:           trigger: { moistureLevel: "less than 4" },
2157:           target: { moistureLevel: 6 },
2158:           volume: {
2159:             amount: "water thoroughly to settle then as needed",
2160:             frequency: "as needed",
2161:           },
2162:         },
2163:         vegetativeHarvest: {
2164:           trigger: { moistureLevel: "less than 4" },
2165:           target: { moistureLevel: 6 },
2166:           volume: { amount: "~1 gal/week for bed", frequency: "as needed" },
2167:           notes: ["14-day succession interval"],
2168:         },
2169:       },
2170:       fertilization: {
2171:         germination: {
2172:           notes: ["None during germination"],
2173:         },
2174:         seedling: {
2175:           products: [
2176:             {
2177:               name: "Fish emulsion",
2178:               dilution: "2 Tbsp/gal",
2179:               amount: "around Wk 2 (1-2 true leaves)",
2180:               frequency: "every 2 weeks",
2181:             },
2182:           ],
2183:         },
2184:         transplant: {
2185:           products: [
2186:             {
2187:               name: "Fish emulsion",
2188:               dilution: "2 Tbsp/gal",
2189:               amount: "continue regimen",
2190:               frequency: "every 2 weeks",
2191:             },
2192:           ],
2193:         },
2194:         vegetativeHarvest: {
2195:           products: [
2196:             {
2197:               name: "Fish emulsion",
2198:               dilution: "2 Tbsp/gal",
2199:               amount: "continue regimen",
2200:               frequency: "every 2 weeks",
2201:             },
2202:           ],
2203:           notes: ["14-day succession interval"],
2204:         },
2205:       },
2206:       environment: {
2207:         pH: { min: 6.0, max: 7.5, optimal: 6.7 },
2208:       },
2209:       soilMixture: {
2210:         components: {
2211:           "coco coir": 35,
2212:           perlite: 25,
2213:           vermiculite: 15,
2214:           compost: 25,
2215:         },
2216:         amendments: {
2217:           "worm castings": "1 tbsp per gallon",
2218:         },
2219:       },
2220:       succession: {
2221:         interval: 14,
2222:         method: "continuous",
2223:         harvestMethod: "cut-and-come-again",
2224:         notes: ["Baby leaves ready 30-45 days", "Multiple harvests per plant"],
2225:       },
2226:       specialRequirements: [
2227:         "Highly sensitive to bolting - strict photoperiod control",
2228:         "Cool season crop - avoid temperatures above 75°F",
2229:         "Cut outer leaves only for continuous harvest",
2230:       ],
2231:     },
2232:   },
2233:   {
2234:     name: "Rosemary",
2235:     category: "herbs",
2236:     isEverbearing: true,
2237:     productiveLifespan: 1095,
2238:     growthTimeline: {
2239:       germination: 21,
2240:       seedling: 84,
2241:       vegetative: 365,
2242:       maturation: 730,
2243:     },
2244:     protocols: {
2245:       lighting: {
2246:         seedling: {
2247:           ppfd: { min: 100, max: 300, unit: "µmol/m²/s" },
2248:           photoperiod: { hours: 12, maxHours: 16 },
2249:           dli: { min: 4.3, max: 17.3, unit: "mol/m²/day" },
2250:           notes: [
2251:             "Starting from seed extremely challenging - low germination rates",
2252:             "Growth initially very slow - patience absolutely essential",
2253:             "Consider starting from cuttings for more reliable establishment",
2254:           ],
2255:         },
2256:         vegetative: {
2257:           ppfd: { min: 300, max: 600, unit: "µmol/m²/s" },
2258:           photoperiod: { hours: 14, maxHours: 16 },
2259:           dli: { min: 17.3, max: 34.6, unit: "mol/m²/day" },
2260:           notes: [
2261:             "Plant slowly develops into bush with woody stems and needle-like leaves",
2262:             "Growth accelerates significantly in second year",
2263:           ],
2264:         },
2265:         flowering: {
2266:           ppfd: { min: 200, max: 400, unit: "µmol/m²/s" },
2267:           photoperiod: { hours: 12, maxHours: 16 },
2268:           dli: { min: 8.6, max: 23.0, unit: "mol/m²/day" },
2269:           notes: [
2270:             "Small blue flowers appear along stems when mature",
2271:             "Pruning after flowering helps maintain compact shape",
2272:           ],
2273:         },
2274:       },
2275:       watering: {
2276:         seedling: {
2277:           trigger: { moistureLevel: "when surface becomes dry" },
2278:           target: { moistureLevel: "barely moist" },
2279:           volume: {
2280:             amount: "minimal applications",
2281:             frequency: "infrequent but careful",
2282:           },
2283:           notes: [
2284:             "Most critical phase - overwatering kills more rosemary than drought",
2285:             "Use spray bottle or very gentle watering to avoid disturbing tiny roots",
2286:           ],
2287:         },
2288:         vegetative: {
2289:           trigger: { moistureLevel: "when soil is dry 2-3 inches down" },
2290:           target: { moistureLevel: "lightly moist in root zone only" },
2291:           volume: {
2292:             amount: "deep but infrequent watering",
2293:             frequency: "weekly or less",
2294:           },
2295:           notes: [
2296:             "Allow substantial drying between waterings",
2297:             "Established rosemary can survive weeks without water",
2298:           ],
2299:         },
2300:         flowering: {
2301:           trigger: { moistureLevel: "when soil is quite dry throughout" },
2302:           target: { moistureLevel: "minimal moisture" },
2303:           volume: {
2304:             amount: "very light watering",
2305:             frequency: "only when absolutely necessary",
2306:           },
2307:           notes: [
2308:             "Mature rosemary is extremely drought tolerant",
2309:             "Excess water during flowering reduces essential oil concentration",
2310:           ],
2311:         },
2312:       },
2313:       fertilization: {
2314:         seedling: {
2315:           products: [
2316:             {
2317:               name: "Limestone",
2318:               dilution: "0.5 tbsp per gallon of soil mix",
2319:               amount: "incorporated during soil preparation",
2320:               frequency: "one-time soil amendment",
2321:               method: "mix-in-soil",
2322:             },
2323:           ],
2324:           timing: "Soil preparation",
2325:           notes: [
2326:             "Limestone provides calcium and raises pH to preferred alkaline range",
2327:             "No other fertilization needed during establishment",
2328:           ],
2329:         },
2330:         vegetative: {
2331:           products: [
2332:             {
2333:               name: "Very dilute compost tea (optional)",
2334:               dilution: "quarter strength maximum",
2335:               amount: "minimal application",
2336:               frequency: "2-3 times per growing season maximum",
2337:             },
2338:           ],
2339:           timing: "Spring growing season only",
2340:           notes: [
2341:             "Rosemary actually performs better with minimal nutrition",
2342:             "Rich soil produces weak growth susceptible to fungal problems",
2343:           ],
2344:         },
2345:         flowering: {
2346:           notes: [
2347:             "No fertilization during flowering or dormant periods",
2348:             "Plant has evolved to thrive in nutrient-poor Mediterranean soils",
2349:           ],
2350:         },
2351:       },
2352:       environment: {
2353:         temperature: { min: 55, max: 80, optimal: 68, unit: "F" },
2354:         humidity: { min: 20, max: 50, optimal: 35 },
2355:         pH: { min: 6.0, max: 7.0, optimal: 6.5 },
2356:       },
2357:       soilMixture: {
2358:         components: {
2359:           "coco coir": 40,
2360:           perlite: 30,
2361:           "coarse sand": 25,
2362:           compost: 5,
2363:         },
2364:         amendments: {
2365:           limestone: "0.5 tbsp per gallon of mix",
2366:         },
2367:       },
2368:       container: {
2369:         minSize: "2-gallon pot minimum (12 inch diameter preferred)",
2370:         depth: "8-10 inches minimum for mature root system",
2371:         drainage: "Exceptional drainage absolutely critical",
2372:       },
2373:       specialRequirements: [
2374:         "Requires exceptional drainage - will die in waterlogged soil",
2375:         "Extremely sensitive to overwatering at all growth stages",
2376:         "Benefits from good air circulation to prevent fungal issues",
2377:         "Harvest by cutting stems, never pull or damage woody structure",
2378:         "May require winter protection or reduced watering in cold periods",
2379:         "Can live for many years if drainage and watering requirements are met",
2380:         "Consider propagation from cuttings rather than seed for better success",
2381:       ],
2382:     },
2383:   },
2384: 
2385:   {
2386:     name: "Italian Flat Leaf Parsley",
2387:     category: "herbs",
2388:     isEverbearing: true,
2389:     productiveLifespan: 365,
2390:     growthTimeline: {
2391:       germination: 21,
2392:       seedling: 42,
2393:       vegetative: 63,
2394:       maturation: 90,
2395:     },
2396:     protocols: {
2397:       lighting: {
2398:         seedling: {
2399:           ppfd: { min: 100, max: 300, unit: "µmol/m²/s" },
2400:           photoperiod: { hours: 12, maxHours: 16 },
2401:           dli: { min: 4.3, max: 17.3, unit: "mol/m²/day" },
2402:           notes: [
2403:             "Germination can take 2-4 weeks - be patient",
2404:             "Soak seeds 12-24 hours before planting to improve germination",
2405:           ],
2406:         },
2407:         vegetativeHarvest: {
2408:           ppfd: { min: 300, max: 600, unit: "µmol/m²/s" },
2409:           photoperiod: { hours: 14, maxHours: 16 },
2410:           dli: { min: 17.3, max: 34.6, unit: "mol/m²/day" },
2411:           notes: [
2412:             "Plant develops abundant, flavorful leaves with characteristic flat shape",
2413:             "Higher light produces more robust growth and stronger flavor",
2414:           ],
2415:         },
2416:         flowering: {
2417:           ppfd: { min: 200, max: 400, unit: "µmol/m²/s" },
2418:           photoperiod: { hours: 12, maxHours: 16 },
2419:           dli: { min: 8.6, max: 23.0, unit: "mol/m²/day" },
2420:           notes: [
2421:             "Bolting produces tall flower stalk with yellow-green flowers",
2422:             "Flowering makes leaves bitter - harvest before bolting occurs",
2423:           ],
2424:         },
2425:       },
2426:       watering: {
2427:         seedling: {
2428:           trigger: { moistureLevel: "when surface begins to dry" },
2429:           target: { moistureLevel: "consistently moist" },
2430:           volume: {
2431:             amount: "gentle, frequent applications",
2432:             frequency: "daily monitoring",
2433:           },
2434:           notes: [
2435:             "Consistent moisture critical during long germination period",
2436:             "Use fine spray to avoid disturbing seeds or tiny seedlings",
2437:           ],
2438:         },
2439:         vegetativeHarvest: {
2440:           trigger: { moistureLevel: "when top inch becomes dry" },
2441:           target: { moistureLevel: "evenly moist throughout" },
2442:           volume: {
2443:             amount: "thorough watering",
2444:             frequency: "every 2-3 days typically",
2445:           },
2446:           notes: [
2447:             "Unlike Mediterranean herbs, parsley prefers consistent moisture",
2448:             "Deeper root system benefits from thorough watering",
2449:           ],
2450:         },
2451:         flowering: {
2452:           trigger: { moistureLevel: "as vegetative stage" },
2453:           target: { moistureLevel: "consistently moist" },
2454:           volume: {
2455:             amount: "maintain regular watering",
2456:             frequency: "as needed",
2457:           },
2458:           notes: [
2459:             "Continue consistent watering even if plant begins to bolt",
2460:             "Consistent moisture may delay onset of flowering",
2461:           ],
2462:         },
2463:       },
2464:       fertilization: {
2465:         seedling: {
2466:           products: [
2467:             {
2468:               name: "Worm castings",
2469:               dilution: "1 tbsp per gallon of soil mix",
2470:               amount: "incorporated during soil preparation",
2471:               frequency: "one-time soil amendment",
2472:               method: "mix-in-soil",
2473:             },
2474:           ],
2475:           timing: "Soil preparation",
2476:           notes: [
2477:             "Gentle organic matter supports establishment without burning tender roots",
2478:           ],
2479:         },
2480:         vegetativeHarvest: {
2481:           products: [
2482:             {
2483:               name: "Balanced organic fertilizer or compost tea",
2484:               dilution: "half to full strength",
2485:               amount: "regular applications",
2486:               frequency: "every 2-3 weeks during active harvest",
2487:             },
2488:           ],
2489:           timing: "Throughout growing season",
2490:           notes: [
2491:             "Parsley is a moderate feeder requiring regular nutrition",
2492:             "Benefits from nitrogen for leaf production unlike Mediterranean herbs",
2493:           ],
2494:         },
2495:         flowering: {
2496:           products: [
2497:             {
2498:               name: "Reduce feeding if bolting occurs",
2499:               dilution: "light applications only",
2500:               amount: "minimal",
2501:               frequency: "monthly if needed",
2502:             },
2503:           ],
2504:           notes: [
2505:             "Focus on preventing bolting rather than supporting flower production",
2506:           ],
2507:         },
2508:       },
2509:       environment: {
2510:         temperature: { min: 60, max: 75, optimal: 68, unit: "F" },
2511:         humidity: { min: 40, max: 70, optimal: 55 },
2512:         pH: { min: 6.0, max: 7.0, optimal: 6.5 },
2513:       },
2514:       soilMixture: {
2515:         components: {
2516:           "coco coir": 35,
2517:           perlite: 25,
2518:           vermiculite: 25,
2519:           compost: 15,
2520:         },
2521:         amendments: {
2522:           "worm castings": "1 tbsp per gallon",
2523:         },
2524:       },
2525:       container: {
2526:         minSize: "2-gallon container minimum",
2527:         depth: "8-12 inches - deeper than most herbs due to taproot",
2528:         drainage:
2529:           "Good drainage but retains more moisture than Mediterranean herbs",
2530:       },
2531:       succession: {
2532:         interval: 21,
2533:         method: "continuous",
2534:         harvestMethod: "cut-and-come-again",
2535:         notes: [
2536:           "Cut outer stems at base, leave center growing point intact",
2537:           "Succession planting every 3 weeks provides continuous fresh harvest",
2538:         ],
2539:       },
2540:       specialRequirements: [
2541:         "Unlike Mediterranean herbs, parsley needs consistent moisture and feeding",
2542:         "Deeper containers required to accommodate taproot development",
2543:         "Harvest outer stems regularly to encourage continued production",
2544:         "Cool-season crop that may bolt in hot weather",
2545:         "Biennial but typically grown as annual for best leaf quality",
2546:       ],
2547:     },
2548:   },
2549: 
2550:   {
2551:     name: "Garlic",
2552:     category: "herbs",
2553:     isEverbearing: false,
2554:     productiveLifespan: 240,
2555:     growthTimeline: {
2556:       germination: 14,
2557:       seedling: 28,
2558:       vegetative: 120,
2559:       maturation: 240,
2560:     },
2561:     protocols: {
2562:       lighting: {
2563:         earlyGrowth: {
2564:           ppfd: { min: 100, max: 300, unit: "µmol/m²/s" },
2565:           photoperiod: { hours: 10, maxHours: 14 },
2566:           dli: { min: 3.6, max: 15.1, unit: "mol/m²/day" },
2567:           notes: [
2568:             "Green shoots emerge from planted cloves",
2569:             "Plant establishes root system during this phase",
2570:           ],
2571:         },
2572:         bulbDevelopment: {
2573:           ppfd: { min: 400, max: 600, unit: "µmol/m²/s" },
2574:           photoperiod: { hours: 12, maxHours: 16 },
2575:           dli: { min: 17.3, max: 34.6, unit: "mol/m²/day" },
2576:           notes: [
2577:             "Occurs as daylight hours increase and soil temperatures rise above 60°F",
2578:             "Plant focuses energy on growing the bulb underground",
2579:           ],
2580:         },
2581:         maturation: {
2582:           ppfd: { min: 200, max: 400, unit: "µmol/m²/s" },
2583:           photoperiod: { hours: 8, maxHours: 12 },
2584:           dli: { min: 5.8, max: 17.3, unit: "mol/m²/day" },
2585:           notes: [
2586:             "Lower leaves begin to yellow and die back",
2587:             "Reduced light needs as plant approaches harvest",
2588:           ],
2589:         },
2590:       },
2591:       watering: {
2592:         earlyGrowth: {
2593:           trigger: { moistureLevel: "when top inch becomes dry" },
2594:           target: { moistureLevel: "evenly moist" },
2595:           volume: {
2596:             amount: "moderate applications",
2597:             frequency: "weekly typically",
2598:           },
2599:           notes: [
2600:             "Consistent moisture supports root development",
2601:             "Avoid waterlogging which can cause clove rot",
2602:           ],
2603:         },
2604:         bulbDevelopment: {
2605:           trigger: { moistureLevel: "when top 2 inches become dry" },
2606:           target: { moistureLevel: "adequately moist" },
2607:           volume: { amount: "regular watering", frequency: "every 5-7 days" },
2608:           notes: [
2609:             "Critical period for bulb formation requires consistent moisture",
2610:             "Monitor soil moisture more carefully during active bulbing",
2611:           ],
2612:         },
2613:         maturation: {
2614:           trigger: { moistureLevel: "allow significant drying" },
2615:           target: { moistureLevel: "minimal moisture" },
2616:           volume: {
2617:             amount: "reduce watering significantly",
2618:             frequency: "infrequent",
2619:           },
2620:           notes: [
2621:             "Reduce watering as harvest approaches to firm up bulbs",
2622:             "Stop watering completely 2-3 weeks before harvest",
2623:           ],
2624:         },
2625:       },
2626:       fertilization: {
2627:         earlyGrowth: {
2628:           products: [
2629:             {
2630:               name: "Well-rotted compost",
2631:               dilution: "2 tbsp per gallon of soil",
2632:               amount: "incorporated during soil preparation",
2633:               frequency: "one-time soil amendment",
2634:               method: "mix-in-soil",
2635:             },
2636:             {
2637:               name: "Bone meal",
2638:               dilution: "1 tsp per gallon",
2639:               amount: "mixed into soil at planting",
2640:               frequency: "one-time amendment",
2641:               method: "mix-in-soil",
2642:             },
2643:           ],
2644:           timing: "At planting",
2645:           notes: ["Slow-release nutrients support long growing cycle"],
2646:         },
2647:         bulbDevelopment: {
2648:           products: [
2649:             {
2650:               name: "Balanced liquid fertilizer (low nitrogen)",
2651:               dilution: "half strength",
2652:               amount: "light application",
2653:               frequency: "monthly during active bulbing",
2654:             },
2655:           ],
2656:           timing: "Spring growing season",
2657:           notes: [
2658:             "Moderate feeding during bulb development",
2659:             "Avoid high nitrogen which produces more leaves than bulb",
2660:           ],
2661:         },
2662:         maturation: {
2663:           notes: [
2664:             "Cease all fertilization 6-8 weeks before harvest",
2665:             "Allow plant to focus energy on bulb maturation",
2666:           ],
2667:         },
2668:       },
2669:       environment: {
2670:         temperature: { min: 50, max: 80, optimal: 65, unit: "F" },
2671:         pH: { min: 6.0, max: 7.0, optimal: 6.5 },
2672:       },
2673:       soilMixture: {
2674:         components: {
2675:           "coco coir": 40,
2676:           perlite: 30,
2677:           vermiculite: 20,
2678:           compost: 10,
2679:         },
2680:         amendments: {
2681:           "well-rotted compost": "2 tbsp per gallon",
2682:           "bone meal": "1 tsp per gallon",
2683:         },
2684:       },
2685:       container: {
2686:         minSize: "2-gallon pot (8 inch diameter)",
2687:         depth: "6-8 inches adequate for bulb development",
2688:       },
2689:       succession: {
2690:         interval: 0,
2691:         method: "single",
2692:         harvestMethod: "single-harvest",
2693:         notes: [
2694:           "Plant cloves in fall for summer harvest",
2695:           "Harvest when lower leaves begin to brown but upper leaves still green",
2696:         ],
2697:       },
2698:       specialRequirements: [
2699:         "Requires cold period for proper bulb formation - may need refrigeration",
2700:         "Plant individual cloves pointed end up, 2 inches deep",
2701:         "Harvest timing critical - too early gives small bulbs, too late causes splitting",
2702:         "Cure harvested bulbs in warm, dry, well-ventilated area for storage",
2703:         "Remove flower stalks (scapes) to encourage bulb development",
2704:       ],
2705:     },
2706:   },
2707:   {
2708:     name: "May Queen Lettuce",
2709:     category: "leafy-greens",
2710:     isEverbearing: true,
2711:     productiveLifespan: 63,
2712:     growthTimeline: {
2713:       germination: 7,
2714:       seedling: 20,
2715:       vegetative: 35,
2716:       maturation: 56,
2717:     },
2718:     protocols: {
2719:       lighting: {
2720:         germination: {
2721:           ppfd: { min: 100, max: 150, unit: "µmol/m²/s" },
2722:           photoperiod: { hours: 10, maxHours: 12 },
2723:           dli: { min: 3.6, max: 6.5, unit: "mol/m²/day" },
2724:           notes: [
2725:             "Keep surface moist during germination",
2726:             "Pre-soak seed 2h in 0.2% kelp solution",
2727:           ],
2728:         },
2729:         seedling: {
2730:           ppfd: { min: 200, max: 300, unit: "µmol/m²/s" },
2731:           photoperiod: { hours: 10, maxHours: 12 },
2732:           dli: { min: 7.2, max: 13.0, unit: "mol/m²/day" },
2733:           notes: [
2734:             "Once 3-4 true leaves appear, begin light fertilization",
2735:             "Strict photoperiod control to prevent bolting",
2736:           ],
2737:         },
2738:         vegetativeRosette: {
2739:           ppfd: { min: 300, max: 350, unit: "µmol/m²/s" },
2740:           photoperiod: { hours: 10, maxHours: 12 },
2741:           dli: { min: 10.8, max: 15.1, unit: "mol/m²/day" },
2742:           notes: [
2743:             "Critical phase for leaf and rosette development",
2744:             "Maintain strict 10-12 hour maximum photoperiod",
2745:           ],
2746:         },
2747:         headFormation: {
2748:           ppfd: { min: 300, max: 350, unit: "µmol/m²/s" },
2749:           photoperiod: { hours: 10, maxHours: 12 },
2750:           dli: { min: 10.8, max: 15.1, unit: "mol/m²/day" },
2751:           notes: [
2752:             "Outer leaves curl inward to form head",
2753:             "Monitor for tip burn (calcium deficiency)",
2754:           ],
2755:         },
2756:       },
2757:       watering: {
2758:         germination: {
2759:           trigger: { moistureLevel: "surface moist" },
2760:           target: { moistureLevel: "7-8" },
2761:           volume: {
2762:             amount: "16-32 oz (0.5-1 L)",
2763:             frequency: "daily/as needed",
2764:           },
2765:           notes: [
2766:             "Keep surface consistently moist",
2767:             "Use mist or light watering",
2768:           ],
2769:         },
2770:         seedling: {
2771:           trigger: { moistureLevel: "3-4" },
2772:           target: { moistureLevel: "8-10" },
2773:           volume: {
2774:             amount: "0.5-1 gal (1.9-3.8 L)",
2775:             frequency: "every 1-3 days",
2776:           },
2777:           notes: ["Water thoroughly until drainage occurs"],
2778:         },
2779:         vegetativeRosette: {
2780:           trigger: { moistureLevel: "3-4" },
2781:           target: { moistureLevel: "8-10" },
2782:           volume: {
2783:             amount: "0.75-1.5 gal (2.8-5.7 L)",
2784:             frequency: "every 2-3 days",
2785:           },
2786:           notes: ["Consistent moisture critical for leaf development"],
2787:         },
2788:         headFormation: {
2789:           trigger: { moistureLevel: "3-4" },
2790:           target: { moistureLevel: "8-10" },
2791:           volume: {
2792:             amount: "0.75-1.5 gal (2.8-5.7 L)",
2793:             frequency: "every 2-3 days",
2794:           },
2795:           notes: ["Stop fertilization 1-2 weeks before final head harvest"],
2796:         },
2797:       },
2798:       fertilization: {
2799:         seedling: {
2800:           products: [
2801:             {
2802:               name: "Diluted fish emulsion",
2803:               dilution: "0.5-1 Tbsp/gal",
2804:               amount: "as needed",
2805:               frequency: "every 2-3 weeks",
2806:             },
2807:             {
2808:               name: "Fish+kelp blend",
2809:               dilution: "0.5-1 Tbsp/gal",
2810:               amount: "as needed",
2811:               frequency: "every 2-3 weeks",
2812:             },
2813:           ],
2814:           timing: "Once 3-4 true leaves appear",
2815:         },
2816:         vegetativeRosette: {
2817:           products: [
2818:             {
2819:               name: "Fish emulsion/fish+kelp",
2820:               dilution: "1-2 Tbsp/gal",
2821:               amount: "as needed",
2822:               frequency: "every 2-3 weeks",
2823:             },
2824:           ],
2825:         },
2826:         headFormation: {
2827:           products: [
2828:             {
2829:               name: "Continue as vegetative",
2830:               dilution: "1-2 Tbsp/gal",
2831:               amount: "as needed",
2832:               frequency: "every 2-3 weeks",
2833:             },
2834:           ],
2835:           notes: ["Stop 1-2 weeks before final head harvest"],
2836:         },
2837:       },
2838:       environment: {
2839:         temperature: { min: 60, max: 75, optimal: 68, unit: "F" },
2840:         humidity: { min: 40, max: 70, optimal: 55 },
2841:         pH: { min: 6.0, max: 7.0, optimal: 6.5 },
2842:         constraints: [
2843:           {
2844:             description:
2845:               "Prone to bolting in warm conditions with extended daylight",
2846:             parameter: "light",
2847:             threshold: 12,
2848:             consequence: "premature bolting reduces head quality",
2849:           },
2850:         ],
2851:       },
2852:       soilMixture: {
2853:         components: {
2854:           "coco coir": 40,
2855:           perlite: 30,
2856:           vermiculite: 20,
2857:           compost: 10,
2858:         },
2859:         amendments: {
2860:           compost: "2 tbsp per gallon",
2861:           "worm castings": "1 tbsp per gallon",
2862:         },
2863:       },
2864:       container: {
2865:         minSize: "bed section 24 inch width",
2866:         depth: "4-6 inches soil depth",
2867:       },
2868:       succession: {
2869:         interval: 14,
2870:         method: "continuous",
2871:         harvestMethod: "cut-and-come-again",
2872:         notes: [
2873:           "Baby leaves ready 30-35 days",
2874:           "Full heads ready 45-60 days",
2875:           "Can harvest outer leaves for extended yield",
2876:         ],
2877:       },
2878:       specialRequirements: [
2879:         "Strict 10-12 hour photoperiod maximum to prevent bolting",
2880:         "Monitor for tip burn (calcium deficiency) - add gypsum if needed",
2881:         "Butterhead lettuce variety - forms loose heads",
2882:         "Cut-and-come-again harvesting extends yield",
2883:         "Succession plant every 1-2 weeks for continuous harvest",
2884:       ],
2885:     },
2886:   },
2887: 
2888: 
2889: 
2890: 
2891: 
2892: 
2893: 
2894: 
2895: 
2896: 
2897: 
2898: 
2899: 
2900: 
2901: 
2902: 
2903: 
2904: 
2905: 
2906: 
2907: 
2908: 
2909: 
2910: 
2911: 
2912: 
2913: 
2914: 
2915: 
2916: 
2917: 
2918: 
2919: 
2920: 
2921: 
2922: 
2923: 
2924: 
2925: 
2926: 
2927: 
2928: 
2929: 
2930: ];

================
File: src/hooks/useDynamicStage.ts
================
 1: import { useEffect, useState } from "react";
 2: import { PlantRecord, varietyService } from "@/types/database";
 3: import { calculateCurrentStageWithVariety } from "@/utils/growthStage";
 4: import { GrowthStage } from "@/types";
 5: 
 6: export function useDynamicStage(plant: PlantRecord): GrowthStage {
 7:   const [calculatedStage, setCalculatedStage] = useState<GrowthStage>(
 8:     plant.currentStage
 9:   );
10: 
11:   useEffect(() => {
12:     const calculateStage = async () => {
13:       try {
14:         const variety = await varietyService.getVariety(plant.varietyId);
15:         const stage = calculateCurrentStageWithVariety(
16:           plant.plantedDate,
17:           variety
18:         );
19:         setCalculatedStage(stage);
20:       } catch (error) {
21:         console.error("useDynamicStage: Error calculating stage:", error);
22:         setCalculatedStage(plant.currentStage);
23:       }
24:     };
25: 
26:     calculateStage();
27:   }, [plant.varietyId, plant.plantedDate, plant.currentStage]);
28: 
29:   return calculatedStage;
30: }

================
File: src/pages/care/PhotoCapture.tsx
================
  1: import React, { useState, useRef } from "react";
  2: import { Button } from "@/components/ui/Button";
  3: 
  4: interface PhotoCaptureProps {
  5:   photos: string[];
  6:   onPhotosChange: (photos: string[]) => void;
  7:   maxPhotos?: number;
  8: }
  9: 
 10: export function PhotoCapture({
 11:   photos,
 12:   onPhotosChange,
 13:   maxPhotos = 5,
 14: }: PhotoCaptureProps) {
 15:   const [isCapturing, setIsCapturing] = useState(false);
 16:   const [error, setError] = useState<string | null>(null);
 17:   const videoRef = useRef<HTMLVideoElement>(null);
 18:   const canvasRef = useRef<HTMLCanvasElement>(null);
 19:   const streamRef = useRef<MediaStream | null>(null);
 20: 
 21: 
 22:   async function startCamera() {
 23:     setError(null);
 24:     setIsCapturing(true);
 25: 
 26:     try {
 27: 
 28:       const stream = await navigator.mediaDevices.getUserMedia({
 29:         video: {
 30:           facingMode: "environment",
 31:           width: { ideal: 1280 },
 32:           height: { ideal: 720 },
 33:         },
 34:       });
 35: 
 36:       if (videoRef.current) {
 37:         videoRef.current.srcObject = stream;
 38:         streamRef.current = stream;
 39:       }
 40:     } catch (err) {
 41:       console.error("Failed to start camera:", err);
 42:       setError("Unable to access camera. Please check permissions.");
 43:       setIsCapturing(false);
 44:     }
 45:   }
 46: 
 47: 
 48:   function stopCamera() {
 49:     if (streamRef.current) {
 50:       streamRef.current.getTracks().forEach((track) => track.stop());
 51:       streamRef.current = null;
 52:     }
 53:     setIsCapturing(false);
 54:   }
 55: 
 56: 
 57:   function capturePhoto() {
 58:     if (!videoRef.current || !canvasRef.current) return;
 59: 
 60:     const video = videoRef.current;
 61:     const canvas = canvasRef.current;
 62:     const context = canvas.getContext("2d");
 63: 
 64:     if (!context) return;
 65: 
 66: 
 67:     canvas.width = video.videoWidth;
 68:     canvas.height = video.videoHeight;
 69: 
 70: 
 71:     context.drawImage(video, 0, 0, canvas.width, canvas.height);
 72: 
 73: 
 74:     canvas.toBlob(
 75:       (blob) => {
 76:         if (blob) {
 77:           const photoUrl = URL.createObjectURL(blob);
 78:           onPhotosChange([...photos, photoUrl]);
 79:         }
 80:       },
 81:       "image/jpeg",
 82:       0.8
 83:     );
 84: 
 85:     stopCamera();
 86:   }
 87: 
 88: 
 89:   function removePhoto(index: number) {
 90:     const newPhotos = photos.filter((_, i) => i !== index);
 91:     onPhotosChange(newPhotos);
 92:   }
 93: 
 94: 
 95:   function handleFileInput(event: React.ChangeEvent<HTMLInputElement>) {
 96:     const files = event.target.files;
 97:     if (!files) return;
 98: 
 99:     Array.from(files).forEach((file) => {
100:       if (file.type.startsWith("image/")) {
101:         const photoUrl = URL.createObjectURL(file);
102:         onPhotosChange([...photos, photoUrl]);
103:       }
104:     });
105: 
106: 
107:     event.target.value = "";
108:   }
109: 
110:   const canAddMore = photos.length < maxPhotos;
111: 
112:   return (
113:     <div className="space-y-4">
114:       {}
115:       {isCapturing ? (
116:         <div className="space-y-4">
117:           <div className="relative bg-black rounded-lg overflow-hidden">
118:             <video
119:               ref={videoRef}
120:               autoPlay
121:               playsInline
122:               className="w-full h-64 object-cover"
123:             />
124:             <canvas ref={canvasRef} className="hidden" />
125:           </div>
126: 
127:           <div className="flex gap-2">
128:             <Button
129:               type="button"
130:               variant="primary"
131:               onClick={capturePhoto}
132:               className="flex-1"
133:             >
134:               📸 Capture Photo
135:             </Button>
136:             <Button type="button" variant="outline" onClick={stopCamera}>
137:               Cancel
138:             </Button>
139:           </div>
140:         </div>
141:       ) : (
142: 
143:         <div className="space-y-4">
144:           {}
145:           <div className="flex gap-2">
146:             {canAddMore && (
147:               <>
148:                 <Button
149:                   type="button"
150:                   variant="outline"
151:                   onClick={startCamera}
152:                   className="flex-1"
153:                 >
154:                   📷 Take Photo
155:                 </Button>
156: 
157:                 {}
158:                 <label className="flex-1">
159:                   <Button
160:                     type="button"
161:                     variant="outline"
162:                     className="w-full"
163:                     onClick={() => {}}
164:                   >
165:                     📁 Choose File
166:                   </Button>
167:                   <input
168:                     type="file"
169:                     accept="image/*"
170:                     multiple
171:                     onChange={handleFileInput}
172:                     className="hidden"
173:                   />
174:                 </label>
175:               </>
176:             )}
177:           </div>
178: 
179:           {}
180:           {error && (
181:             <div className="p-3 bg-red-50 border border-red-200 rounded-md">
182:               <p className="text-sm text-red-600">{error}</p>
183:             </div>
184:           )}
185: 
186:           {}
187:           {photos.length > 0 && (
188:             <p className="text-sm text-muted-foreground">
189:               {photos.length} of {maxPhotos} photos added
190:             </p>
191:           )}
192:         </div>
193:       )}
194: 
195:       {}
196:       {photos.length > 0 && (
197:         <div className="grid grid-cols-2 gap-2">
198:           {photos.map((photo, index) => (
199:             <div key={index} className="relative">
200:               <img
201:                 src={photo}
202:                 alt={`Captured photo ${index + 1}`}
203:                 className="w-full h-24 object-cover rounded-md border border-border"
204:               />
205:               <button
206:                 type="button"
207:                 onClick={() => removePhoto(index)}
208:                 className="absolute -top-2 -right-2 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs hover:bg-red-600"
209:               >
210:                 ×
211:               </button>
212:             </div>
213:           ))}
214:         </div>
215:       )}
216:     </div>
217:   );
218: }

================
File: src/pages/plants/AddPlant.tsx
================
 1: import React from "react";
 2: import { PlantRegistrationForm } from "@/components/plant/PlantRegistrationForm";
 3: import { useNavigate } from "react-router-dom";
 4: 
 5: const AddPlant: React.FC = () => {
 6:   const navigate = useNavigate();
 7: 
 8:   const handleSuccess = () => {
 9:     navigate("/plants");
10:   };
11: 
12:   const handleCancel = () => {
13:     navigate("/plants");
14:   };
15: 
16:   return (
17:     <div className="p-4">
18:       <h1 className="text-2xl font-bold text-foreground mb-6 text-center">
19:         Add New Plant
20:       </h1>
21:       <PlantRegistrationForm
22:         onSuccess={handleSuccess}
23:         onCancel={handleCancel}
24:       />
25:     </div>
26:   );
27: };
28: 
29: export default AddPlant;

================
File: src/services/growthStageService.ts
================
 1: import { plantService, varietyService } from "@/types/database";
 2: import { calculateCurrentStageWithVariety } from "@/utils/growthStage";
 3: 
 4: export class GrowthStageService {
 5:   static async updatePlantStages(): Promise<void> {
 6:     const plants = await plantService.getActivePlants();
 7: 
 8:     for (const plant of plants) {
 9:       const variety = await varietyService.getVariety(plant.varietyId);
10: 
11:       const currentStage = calculateCurrentStageWithVariety(
12:         plant.plantedDate,
13:         variety
14:       );
15: 
16:       if (currentStage !== plant.currentStage) {
17:         await plantService.updatePlant(plant.id, {
18:           currentStage,
19:           updatedAt: new Date(),
20:         });
21:       }
22:     }
23:   }
24: }

================
File: src/services/smartDefaultsService.ts
================
  1: import { varietyService, PlantRecord, VarietyRecord } from "@/types/database";
  2: import { calculateCurrentStage } from "@/utils/growthStage";
  3: import { GrowthStage, PlantCategory, ApplicationMethod } from "@/types/core";
  4: 
  5: export interface WateringDefaults {
  6:   suggestedAmount: number;
  7:   unit: "oz" | "ml" | "cups" | "liters" | "gallons";
  8:   confidence: "high" | "medium" | "low";
  9:   source: "protocol" | "category" | "universal";
 10:   reasoning: string;
 11: }
 12: 
 13: export interface FertilizerDefaults {
 14:   products: {
 15:     name: string;
 16:     dilution: string;
 17:     amount: string;
 18:     method?: "soil-drench" | "foliar-spray" | "top-dress" | "mix-in-soil";
 19:     confidence: "high" | "medium" | "low";
 20:   }[];
 21:   source: "protocol" | "category" | "universal";
 22:   reasoning: string;
 23: }
 24: 
 25: export interface SmartDefaults {
 26:   watering?: WateringDefaults;
 27:   fertilizer?: FertilizerDefaults;
 28:   plantName: string;
 29:   currentStage: GrowthStage;
 30:   daysSincePlanting: number;
 31: }
 32: 
 33: export interface QuickCompletionValues {
 34:   waterValue?: number;
 35:   waterUnit?: string;
 36:   product?: string;
 37:   dilution?: string;
 38:   amount?: string;
 39: }
 40: 
 41: interface VolumeAmount {
 42:   amount: number;
 43:   unit: "oz" | "ml" | "cups" | "liters" | "gallons";
 44: }
 45: 
 46: export class SmartDefaultsService {
 47: 
 48: 
 49: 
 50:   static async getDefaultsForPlant(
 51:     plant: PlantRecord
 52:   ): Promise<SmartDefaults | null> {
 53:     try {
 54:       const variety = await varietyService.getVariety(plant.varietyId);
 55:       if (!variety) return null;
 56: 
 57:       const currentStage = calculateCurrentStage(
 58:         plant.plantedDate,
 59:         variety.growthTimeline
 60:       );
 61:       const daysSincePlanting = Math.floor(
 62:         (Date.now() - plant.plantedDate.getTime()) / (1000 * 60 * 60 * 24)
 63:       );
 64: 
 65:       const wateringDefaults = this.getWateringDefaults(variety, currentStage);
 66:       const fertilizerDefaults = this.getFertilizerDefaults(
 67:         variety,
 68:         currentStage
 69:       );
 70: 
 71:       return {
 72:         watering: wateringDefaults,
 73:         fertilizer: fertilizerDefaults,
 74:         plantName: plant.name || plant.varietyName,
 75:         currentStage,
 76:         daysSincePlanting,
 77:       };
 78:     } catch (error) {
 79:       console.error("Error getting smart defaults:", error);
 80:       return null;
 81:     }
 82:   }
 83: 
 84: 
 85: 
 86: 
 87:   private static getWateringDefaults(
 88:     variety: VarietyRecord,
 89:     currentStage: GrowthStage
 90:   ): WateringDefaults | undefined {
 91: 
 92:     const stageProtocol = variety.protocols?.watering?.[currentStage] as {
 93:       volume?: { amount?: number | string; unit?: string };
 94:     };
 95: 
 96:     if (stageProtocol?.volume?.amount) {
 97:       const parsed = this.parseWaterAmount(stageProtocol.volume.amount);
 98:       if (parsed && stageProtocol.volume.unit) {
 99:         return {
100:           suggestedAmount: parsed.amount,
101:           unit: stageProtocol.volume.unit as
102:             | "oz"
103:             | "ml"
104:             | "cups"
105:             | "liters"
106:             | "gallons",
107:           confidence: "high",
108:           source: "protocol",
109:           reasoning: `Based on ${variety.name} protocol for ${currentStage} stage`,
110:         };
111:       }
112:     }
113: 
114: 
115:     const categoryDefaults = this.getCategoryWateringDefaults(
116:       variety.category,
117:       currentStage
118:     );
119:     if (categoryDefaults) {
120:       return {
121:         suggestedAmount: categoryDefaults.amount,
122:         unit: categoryDefaults.unit,
123:         confidence: "medium",
124:         source: "category",
125:         reasoning: `Based on ${variety.category} category guidelines for ${currentStage} stage`,
126:       };
127:     }
128: 
129: 
130:     return {
131:       suggestedAmount: 16,
132:       unit: "oz",
133:       confidence: "low",
134:       source: "universal",
135:       reasoning: "Using universal default amount",
136:     };
137:   }
138: 
139: 
140: 
141: 
142:   private static getFertilizerDefaults(
143:     variety: VarietyRecord,
144:     currentStage: GrowthStage
145:   ): FertilizerDefaults | undefined {
146:     const stageProtocol = variety.protocols?.fertilization?.[currentStage] as {
147:       fertilizer?: { product?: string };
148:       application?: { dilution?: string; amount?: string; method?: string };
149:     };
150: 
151:     if (stageProtocol?.fertilizer?.product && stageProtocol?.application) {
152:       return {
153:         products: [
154:           {
155:             name: stageProtocol.fertilizer.product,
156:             dilution: stageProtocol.application.dilution || "As directed",
157:             amount: stageProtocol.application.amount || "Apply to runoff",
158:             method:
159:               (stageProtocol.application.method as ApplicationMethod) ||
160:               "soil-drench",
161:             confidence: "high",
162:           },
163:         ],
164:         source: "protocol",
165:         reasoning: `Based on ${variety.name} fertilization protocol for ${currentStage} stage`,
166:       };
167:     }
168: 
169: 
170:     const categoryDefaults = this.getCategoryFertilizerDefaults(
171:       variety.category,
172:       currentStage
173:     );
174:     if (categoryDefaults) {
175:       return categoryDefaults;
176:     }
177: 
178:     return undefined;
179:   }
180: 
181: 
182: 
183: 
184:   private static getCategoryWateringDefaults(
185:     category: PlantCategory,
186:     stage: GrowthStage
187:   ): VolumeAmount | undefined {
188:     const categoryWateringGuides: Record<
189:       PlantCategory,
190:       Record<GrowthStage, VolumeAmount>
191:     > = {
192:       "leafy-greens": {
193:         germination: { amount: 8, unit: "oz" },
194:         seedling: { amount: 12, unit: "oz" },
195:         vegetative: { amount: 16, unit: "oz" },
196:         flowering: { amount: 16, unit: "oz" },
197:         fruiting: { amount: 16, unit: "oz" },
198:         maturation: { amount: 16, unit: "oz" },
199:         harvest: { amount: 16, unit: "oz" },
200:         "ongoing-production": { amount: 16, unit: "oz" },
201:       },
202:       "fruiting-plants": {
203:         germination: { amount: 12, unit: "oz" },
204:         seedling: { amount: 16, unit: "oz" },
205:         vegetative: { amount: 24, unit: "oz" },
206:         flowering: { amount: 28, unit: "oz" },
207:         fruiting: { amount: 32, unit: "oz" },
208:         maturation: { amount: 32, unit: "oz" },
209:         harvest: { amount: 32, unit: "oz" },
210:         "ongoing-production": { amount: 32, unit: "oz" },
211:       },
212:       "root-vegetables": {
213:         germination: { amount: 8, unit: "oz" },
214:         seedling: { amount: 12, unit: "oz" },
215:         vegetative: { amount: 20, unit: "oz" },
216:         flowering: { amount: 20, unit: "oz" },
217:         fruiting: { amount: 24, unit: "oz" },
218:         maturation: { amount: 24, unit: "oz" },
219:         harvest: { amount: 24, unit: "oz" },
220:         "ongoing-production": { amount: 24, unit: "oz" },
221:       },
222:       herbs: {
223:         germination: { amount: 6, unit: "oz" },
224:         seedling: { amount: 10, unit: "oz" },
225:         vegetative: { amount: 14, unit: "oz" },
226:         flowering: { amount: 14, unit: "oz" },
227:         fruiting: { amount: 14, unit: "oz" },
228:         maturation: { amount: 14, unit: "oz" },
229:         harvest: { amount: 14, unit: "oz" },
230:         "ongoing-production": { amount: 14, unit: "oz" },
231:       },
232:       berries: {
233:         germination: { amount: 10, unit: "oz" },
234:         seedling: { amount: 14, unit: "oz" },
235:         vegetative: { amount: 20, unit: "oz" },
236:         flowering: { amount: 24, unit: "oz" },
237:         fruiting: { amount: 28, unit: "oz" },
238:         maturation: { amount: 28, unit: "oz" },
239:         harvest: { amount: 28, unit: "oz" },
240:         "ongoing-production": { amount: 28, unit: "oz" },
241:       },
242:     };
243: 
244:     return categoryWateringGuides[category]?.[stage];
245:   }
246: 
247: 
248: 
249: 
250:   private static getCategoryFertilizerDefaults(
251:     category: PlantCategory,
252:     stage: GrowthStage
253:   ): FertilizerDefaults | undefined {
254:     const categoryFertilizerGuides: Record<
255:       PlantCategory,
256:       Record<string, { product: string; dilution: string; amount: string }>
257:     > = {
258:       "leafy-greens": {
259:         general: {
260:           product: "Balanced liquid fertilizer",
261:           dilution: "Half strength",
262:           amount: "Apply every 2 weeks",
263:         },
264:       },
265:       "fruiting-plants": {
266:         vegetative: {
267:           product: "High nitrogen fertilizer",
268:           dilution: "Full strength",
269:           amount: "Apply weekly",
270:         },
271:         flowering: {
272:           product: "Bloom booster",
273:           dilution: "Full strength",
274:           amount: "Apply bi-weekly",
275:         },
276:         fruiting: {
277:           product: "Potassium-rich fertilizer",
278:           dilution: "Full strength",
279:           amount: "Apply weekly",
280:         },
281:       },
282:       "root-vegetables": {
283:         general: {
284:           product: "Root vegetable fertilizer",
285:           dilution: "Half strength",
286:           amount: "Apply monthly",
287:         },
288:       },
289:       herbs: {
290:         general: {
291:           product: "Light liquid fertilizer",
292:           dilution: "Quarter strength",
293:           amount: "Apply monthly",
294:         },
295:       },
296:       berries: {
297:         general: {
298:           product: "Berry fertilizer",
299:           dilution: "Full strength",
300:           amount: "Apply bi-weekly",
301:         },
302:       },
303:     };
304: 
305:     const stageKey = ["flowering", "fruiting"].includes(stage)
306:       ? stage
307:       : "general";
308:     const defaults = categoryFertilizerGuides[category]?.[stageKey];
309: 
310:     if (defaults) {
311:       return {
312:         products: [
313:           {
314:             name: defaults.product,
315:             dilution: defaults.dilution,
316:             amount: defaults.amount,
317:             confidence: "medium",
318:           },
319:         ],
320:         source: "category",
321:         reasoning: `General ${category} fertilization guidelines`,
322:       };
323:     }
324: 
325:     return undefined;
326:   }
327: 
328: 
329: 
330: 
331:   private static parseWaterAmount(
332:     amount: string | number
333:   ): { amount: number } | null {
334:     if (typeof amount === "number") {
335:       return { amount };
336:     }
337: 
338:     if (typeof amount === "string") {
339: 
340:       const rangeMatch = amount.match(/(\d+(?:\.\d+)?)-(\d+(?:\.\d+)?)/);
341:       if (rangeMatch) {
342:         const min = parseFloat(rangeMatch[1]);
343:         const max = parseFloat(rangeMatch[2]);
344:         return { amount: Math.round((min + max) / 2) };
345:       }
346: 
347: 
348:       const singleMatch = amount.match(/(\d+(?:\.\d+)?)/);
349:       if (singleMatch) {
350:         return { amount: parseFloat(singleMatch[1]) };
351:       }
352:     }
353: 
354:     return null;
355:   }
356: 
357: 
358: 
359: 
360:   static async getQuickCompletionOptions(
361:     plant: PlantRecord,
362:     activityType: "water" | "fertilize"
363:   ): Promise<Array<{ label: string; values: QuickCompletionValues }> | null> {
364:     const defaults = await this.getDefaultsForPlant(plant);
365:     if (!defaults) return null;
366: 
367:     if (activityType === "water" && defaults.watering) {
368:       const { suggestedAmount, unit } = defaults.watering;
369: 
370: 
371:       const baseAmount = suggestedAmount;
372:       const options = [
373:         {
374:           label: `Quick: ${baseAmount}${unit}`,
375:           values: {
376:             waterValue: baseAmount,
377:             waterUnit: unit,
378:           },
379:         },
380:       ];
381: 
382: 
383:       if (defaults.watering.confidence === "high") {
384:         const lightAmount = Math.round(baseAmount * 0.75);
385:         const heavyAmount = Math.round(baseAmount * 1.25);
386: 
387:         options.unshift({
388:           label: `Light: ${lightAmount}${unit}`,
389:           values: {
390:             waterValue: lightAmount,
391:             waterUnit: unit,
392:           },
393:         });
394: 
395:         options.push({
396:           label: `Heavy: ${heavyAmount}${unit}`,
397:           values: {
398:             waterValue: heavyAmount,
399:             waterUnit: unit,
400:           },
401:         });
402:       }
403: 
404:       return options;
405:     }
406: 
407:     if (
408:       activityType === "fertilize" &&
409:       defaults.fertilizer?.products &&
410:       defaults.fertilizer.products.length > 0
411:     ) {
412:       return defaults.fertilizer.products.slice(0, 3).map((product) => ({
413:         label: `Quick: ${product.name}`,
414:         values: {
415:           product: product.name,
416:           dilution: product.dilution,
417:           amount: product.amount,
418:         },
419:       }));
420:     }
421: 
422:     return null;
423:   }
424: }

================
File: src/styles/globals.css
================
 1: @tailwind base;
 2: @tailwind components;
 3: @tailwind utilities;
 4: 
 5: @layer base {
 6:   :root {
 7: 
 8:     --background: 249 250 251;
 9:     --foreground: 17 24 39;
10:     --card: 255 255 255;
11:     --card-foreground: 17 24 39;
12:     --primary: 52 211 153;
13:     --primary-foreground: 17 24 39;
14:     --secondary: 156 163 175;
15:     --secondary-foreground: 17 24 39;
16:     --muted: 243 244 246;
17:     --muted-foreground: 107 114 128;
18:     --accent: 52 211 153;
19:     --accent-foreground: 17 24 39;
20:     --border: 229 231 235;
21:     --ring: 52 211 153;
22:     --input: 255 255 255;
23:     --input-foreground: 17 24 39;
24:   }
25: 
26:   .dark {
27: 
28:     --background: 17 24 39;
29:     --foreground: 243 244 246;
30:     --card: 31 41 55;
31:     --card-foreground: 243 244 246;
32:     --primary: 34 197 94;
33:     --primary-foreground: 243 244 246;
34:     --secondary: 75 85 99;
35:     --secondary-foreground: 243 244 246;
36:     --muted: 55 65 81;
37:     --muted-foreground: 156 163 175;
38:     --accent: 34 197 94;
39:     --accent-foreground: 243 244 246;
40:     --border: 75 85 99;
41:     --ring: 34 197 94;
42:     --input: 31 41 55;
43:     --input-foreground: 243 244 246;
44:   }
45: }
46: 
47: 
48: * {
49:   -webkit-tap-highlight-color: transparent;
50: }
51: 
52: html {
53:   scroll-behavior: smooth;
54: }
55: 
56: body {
57:   background-color: rgb(var(--background));
58:   color: rgb(var(--foreground));
59:   font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
60:     "Helvetica Neue", Arial, sans-serif;
61:   -webkit-font-smoothing: antialiased;
62:   -moz-osx-font-smoothing: grayscale;
63: }
64: 
65: #root {
66:   background-color: rgb(var(--background));
67:   min-height: 100vh;
68: }
69: 
70: 
71: button {
72:   -webkit-appearance: none;
73:   appearance: none;
74: }
75: 
76: 
77: button:focus-visible {
78:   outline: 2px solid #3b82f6;
79:   outline-offset: 2px;
80: }

================
File: src/types/core.ts
================
  1: export type GrowthStage =
  2:   | "germination"
  3:   | "seedling"
  4:   | "vegetative"
  5:   | "flowering"
  6:   | "fruiting"
  7:   | "maturation"
  8:   | "harvest"
  9:   | "ongoing-production";
 10: 
 11: export type PlantCategory =
 12:   | "root-vegetables"
 13:   | "leafy-greens"
 14:   | "herbs"
 15:   | "berries"
 16:   | "fruiting-plants";
 17: 
 18: export type CareActivityType =
 19:   | "water"
 20:   | "fertilize"
 21:   | "observe"
 22:   | "harvest"
 23:   | "transplant";
 24: 
 25: export type QualityRating =
 26:   | "excellent"
 27:   | "good"
 28:   | "fair"
 29:   | "poor"
 30:   | "unsaleable";
 31: 
 32: export type HealthAssessment =
 33:   | "excellent"
 34:   | "good"
 35:   | "fair"
 36:   | "concerning"
 37:   | "critical";
 38: 
 39: export type VolumeUnit = "oz" | "ml" | "gal" | "L";
 40: export type WeightUnit = "oz" | "lbs" | "g" | "kg";
 41: export type LengthUnit = "inches" | "cm" | "ft" | "m";
 42: export type TemperatureUnit = "F" | "C";
 43: 
 44: export interface FertilizerProtocol {
 45:   product?: string;
 46:   dilution?: string;
 47:   amount?: string;
 48:   method?: ApplicationMethod;
 49: }
 50: 
 51: export interface ApplicationDetails {
 52:   dilution?: string;
 53:   amount?: string;
 54:   method?: ApplicationMethod;
 55: }
 56: 
 57: export interface VarietyProtocols {
 58:   watering?: Record<
 59:     GrowthStage,
 60:     {
 61:       trigger?: { moistureLevel?: string | number };
 62:       target?: { moistureLevel?: string | number };
 63:       volume?: { amount?: string | number; frequency?: string };
 64:     }
 65:   >;
 66:   fertilizing?: Record<
 67:     GrowthStage,
 68:     {
 69:       fertilizer?: FertilizerProtocol;
 70:       application?: ApplicationDetails;
 71:     }
 72:   >;
 73:   lighting?: Record<
 74:     GrowthStage,
 75:     {
 76:       ppfd?: { min: number; max: number; unit: string };
 77:       photoperiod?: { hours: number };
 78:       dli?: { min: number; max: number; unit: string };
 79:     }
 80:   >;
 81: }
 82: 
 83: export type ApplicationMethod =
 84:   | "soil-drench"
 85:   | "foliar-spray"
 86:   | "top-dress"
 87:   | "mix-in-soil";
 88: 
 89: export type WateringMethod =
 90:   | "top-watering"
 91:   | "bottom-watering"
 92:   | "drip"
 93:   | "misting";
 94: 
 95: 
 96: export interface BaseRecord {
 97:   id: string;
 98:   createdAt: Date;
 99:   updatedAt: Date;
100: }
101: 
102: export interface TimestampedRecord {
103:   id: string;
104:   createdAt: Date;
105: }
106: 
107: export interface MoistureReading {
108:   before: number;
109:   after: number;
110:   scale: "1-10" | "visual";
111: }
112: 
113: export interface Volume {
114:   amount: number;
115:   unit: VolumeUnit;
116: }
117: 
118: export interface Weight {
119:   amount: number;
120:   unit: WeightUnit;
121: }
122: 
123: export interface GrowthTimeline {
124:   germination: number;
125:   seedling: number;
126:   vegetative: number;
127:   maturation: number;
128: }
129: export interface CategoryMoistureDefaults {
130:   trigger: [number, number];
131:   target: [number, number];
132: }
133: 
134: export interface MoistureProtocolInfo {
135:   trigger: [number, number];
136:   target: [number, number];
137:   varietyName: string;
138:   currentStage: GrowthStage;
139:   isDefault: boolean;
140:   source: "custom" | "category" | "universal";
141: }

================
File: src/types/index.ts
================
 1: export * from "./core";
 2: export type { CategoryMoistureDefaults, MoistureProtocolInfo } from "./core";
 3: 
 4: 
 5: export * from "./database";
 6: 
 7: 
 8: export type {
 9:   PlantRecord as PlantInstance,
10:   VarietyRecord as PlantVariety,
11:   CareRecord as CareActivity,
12: } from "./database";
13: 
14: 
15: export * from "./scheduling";
16: 
17: 
18: export * from "./user";

================
File: index.html
================
 1: <!DOCTYPE html>
 2: <html lang="en">
 3:   <head>
 4:     <meta charset="UTF-8" />
 5:     <meta name="darkreader-lock" />
 6:     <link rel="icon" type="image/svg+xml" href="/vite.svg" />
 7:     <meta name="viewport" content="width=device-width, initial-scale=1.0" />
 8:     <title>Vite + React + TS</title>
 9:   </head>
10:   <body>
11:     <div id="root"></div>
12:     <script type="module" src="/src/main.tsx"></script>
13:   </body>
14: </html>

================
File: print_structure.py
================
 1: import os
 2: 
 3: def print_directory_structure(root_dir, prefix=""):
 4:     for item in os.listdir(root_dir):
 5:         path = os.path.join(root_dir, item)
 6:         if os.path.isdir(path):
 7: 
 8:             if item == "node_modules":
 9:                 continue
10:             if item == "__pycache__":
11:                 continue
12:             if item == ".git":
13:                 continue
14:             if item == ".vscode":
15:                 continue
16:             if item == ".idea":
17:                 continue
18:             if item == ".DS_Store":
19:                 continue
20:             print(f"{prefix}├── {item}/")
21:             print_directory_structure(path, prefix + "│   ")
22:         else:
23:             print(f"{prefix}├── {item}")
24: 
25: if __name__ == "__main__":
26:     project_root = "."
27:     print_directory_structure(project_root)

================
File: README.md
================
 1: # 🌱 SmartGarden PWA
 2: 
 3: A Progressive Web Application for managing indoor gardening with scientifically-backed growing protocols, offline-first plant tracking, and intelligent care scheduling.
 4: 
 5: ## ✨ Features
 6: 
 7: - **Plant Registration**: Track varieties with custom container configurations
 8: - **Growth Stage Tracking**: Automated stage progression based on planting dates
 9: - **Care Scheduling**: Protocol-driven watering, fertilizing, and observation reminders
10: - **Offline-First**: Full functionality without internet connection
11: - **Mobile Optimized**: Touch-friendly interface designed for gloved hands
12: - **PWA**: Installable app experience on mobile and desktop
13: 
14: ## 🛠️ Tech Stack
15: 
16: - **Frontend**: React 18 + TypeScript
17: - **Styling**: TailwindCSS + shadcn/ui components
18: - **State**: Zustand for global state management
19: - **Database**: IndexedDB via Dexie.js (offline-first)
20: - **Testing**: Jest + React Testing Library + Cypress
21: - **PWA**: Service Worker + Web App Manifest
22: 
23: ## 🚀 Quick Start
24: 
25: ```bash
26: # Install dependencies
27: npm install
28: 
29: # Start development server
30: npm run dev
31: 
32: # Run tests
33: npm test
34: 
35: # Build for production
36: npm run build
37: ```

================
File: tailwind.config.js
================
 1: module.exports = {
 2:   content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],
 3:   theme: {
 4:     extend: {
 5:       colors: {
 6: 
 7:         background: "rgb(var(--background) / <alpha-value>)",
 8:         foreground: "rgb(var(--foreground) / <alpha-value>)",
 9:         card: {
10:           DEFAULT: "rgb(var(--card) / <alpha-value>)",
11:           foreground: "rgb(var(--card-foreground) / <alpha-value>)",
12:         },
13:         primary: {
14:           DEFAULT: "rgb(var(--primary) / <alpha-value>)",
15:           foreground: "rgb(var(--primary-foreground) / <alpha-value>)",
16:         },
17:         secondary: {
18:           DEFAULT: "rgb(var(--secondary) / <alpha-value>)",
19:           foreground: "rgb(var(--secondary-foreground) / <alpha-value>)",
20:         },
21:         muted: {
22:           DEFAULT: "rgb(var(--muted) / <alpha-value>)",
23:           foreground: "rgb(var(--muted-foreground) / <alpha-value>)",
24:         },
25:         accent: {
26:           DEFAULT: "rgb(var(--accent) / <alpha-value>)",
27:           foreground: "rgb(var(--accent-foreground) / <alpha-value>)",
28:         },
29:         border: "rgb(var(--border) / <alpha-value>)",
30:         ring: "rgb(var(--ring) / <alpha-value>)",
31: 
32: 
33:         garden: {
34:           50: "#f0f9f4",
35:           100: "#dcf2e4",
36:           200: "#bce5cd",
37:           300: "#8dd0aa",
38:           400: "#57b380",
39:           500: "#349960",
40:           600: "#2F6F4E",
41:           700: "#1e5a3a",
42:           800: "#1a4a31",
43:           900: "#163d29",
44:         },
45: 
46: 
47:         success: "#38A169",
48:         warning: "#DD6B20",
49:         error: "#E53E3E",
50: 
51:         input: {
52:           DEFAULT: "rgb(var(--input) / <alpha-value>)",
53:           foreground: "rgb(var(--input-foreground) / <alpha-value>)",
54:         },
55:       },
56:       boxShadow: {
57:         sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
58:         md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
59:         lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
60:       },
61:     },
62:   },
63:   darkMode: "class",
64:   plugins: [],
65: };

================
File: src/__tests__/integration/stageCalculationDisplay.test.tsx
================
  1: import { render, screen, waitFor } from "@testing-library/react";
  2: import { BrowserRouter } from "react-router-dom";
  3: import Plants from "../../pages/plants/Plants";
  4: import { plantService, varietyService } from "@/types/database";
  5: import { initializeDatabase } from "@/db/seedData";
  6: import { subDays } from "date-fns";
  7: 
  8: describe("Stage Calculation Integration", () => {
  9:   beforeEach(async () => {
 10:     const { db } = await import("@/types/database");
 11:     await db.plants.clear();
 12:     await db.varieties.clear();
 13:     await initializeDatabase();
 14:   });
 15: 
 16:   const renderWithRouter = (component: React.ReactElement) => {
 17:     return render(<BrowserRouter>{component}</BrowserRouter>);
 18:   };
 19: 
 20:   describe("Stage calculation for mature plants", () => {
 21:     it("displays correct stage for 103-day-old Albion strawberry in Plants page", async () => {
 22:       const varieties = await varietyService.getAllVarieties();
 23:       const albion = varieties.find((v) => v.name === "Albion Strawberries");
 24:       expect(albion).toBeDefined();
 25: 
 26:       const plantedDate = subDays(new Date(), 103);
 27:       await plantService.addPlant({
 28:         varietyId: albion!.id,
 29:         varietyName: albion!.name,
 30:         name: "Test Strawberry",
 31:         plantedDate,
 32:         currentStage: "germination",
 33:         location: "Indoor",
 34:         container: "5 gallon",
 35:         isActive: true,
 36:       });
 37: 
 38:       renderWithRouter(<Plants />);
 39: 
 40: 
 41:       await waitFor(() => {
 42:         const matches = screen.getAllByText("Test Strawberry");
 43:         expect(matches.length).toBeGreaterThan(0);
 44:       });
 45: 
 46: 
 47:       await waitFor(() => {
 48:         const stageText =
 49:           screen.queryByText(/ongoing.?production/i) ||
 50:           screen.queryByText(/ongoing\s+production/i) ||
 51:           screen.queryByText(/Stage.*ongoing.?production/i);
 52:         expect(stageText).toBeInTheDocument();
 53:       });
 54:     });
 55: 
 56:     it("displays correct stage for 50-day-old Astro Arugula (everbearing)", async () => {
 57:       const varieties = await varietyService.getAllVarieties();
 58:       const arugula = varieties.find((v) => v.name === "Astro Arugula");
 59:       expect(arugula).toBeDefined();
 60: 
 61:       const plantedDate = subDays(new Date(), 50);
 62:       await plantService.addPlant({
 63:         varietyId: arugula!.id,
 64:         varietyName: arugula!.name,
 65:         name: "Test Arugula",
 66:         plantedDate,
 67:         currentStage: "germination",
 68:         location: "Indoor",
 69:         container: "4 inch pot",
 70:         isActive: true,
 71:       });
 72: 
 73:       renderWithRouter(<Plants />);
 74: 
 75:       await waitFor(() => {
 76:         const matches = screen.getAllByText("Test Arugula");
 77:         expect(matches.length).toBeGreaterThan(0);
 78:       });
 79: 
 80: 
 81:       await waitFor(() => {
 82:         const stageText =
 83:           screen.queryByText(/ongoing.?production/i) ||
 84:           screen.queryByText(/ongoing\s+production/i) ||
 85:           screen.queryByText(/Stage.*ongoing.?production/i);
 86:         expect(stageText).toBeInTheDocument();
 87:       });
 88:     });
 89: 
 90:     it("displays correct stage for 80-day-old non-everbearing plant", async () => {
 91:       const varieties = await varietyService.getAllVarieties();
 92: 
 93:       const carrots = varieties.find((v) => v.name === "Little Finger Carrots");
 94:       expect(carrots).toBeDefined();
 95: 
 96:       const plantedDate = subDays(new Date(), 80);
 97:       await plantService.addPlant({
 98:         varietyId: carrots!.id,
 99:         varietyName: carrots!.name,
100:         name: "Test Carrots",
101:         plantedDate,
102:         currentStage: "germination",
103:         location: "Indoor",
104:         container: "Deep container",
105:         isActive: true,
106:       });
107: 
108:       renderWithRouter(<Plants />);
109: 
110:       await waitFor(() => {
111:         const matches = screen.getAllByText("Test Carrots");
112:         expect(matches.length).toBeGreaterThan(0);
113:       });
114: 
115: 
116:       await waitFor(() => {
117:         const stageText =
118:           screen.queryByText(/harvest/i) ||
119:           screen.queryByText(/Stage.*harvest/i);
120:         expect(stageText).toBeInTheDocument();
121:       });
122:     });
123: 
124:     it("displays correct stage for plant in vegetative stage", async () => {
125:       const varieties = await varietyService.getAllVarieties();
126:       const spinach = varieties.find((v) => v.name === "Baby's Leaf Spinach");
127:       expect(spinach).toBeDefined();
128: 
129: 
130:       const plantedDate = subDays(new Date(), 25);
131:       await plantService.addPlant({
132:         varietyId: spinach!.id,
133:         varietyName: spinach!.name,
134:         name: "Test Spinach",
135:         plantedDate,
136:         currentStage: "germination",
137:         location: "Indoor",
138:         container: "Medium container",
139:         isActive: true,
140:       });
141: 
142:       renderWithRouter(<Plants />);
143: 
144:       await waitFor(() => {
145:         const matches = screen.getAllByText("Test Spinach");
146:         expect(matches.length).toBeGreaterThan(0);
147:       });
148: 
149: 
150:       await waitFor(() => {
151:         const stageText =
152:           screen.queryByText(/vegetative/i) ||
153:           screen.queryByText(/Stage.*vegetative/i);
154:         expect(stageText).toBeInTheDocument();
155:       });
156:     });
157: 
158:     it("displays correct stage for plant in seedling stage", async () => {
159:       const varieties = await varietyService.getAllVarieties();
160:       const spinach = varieties.find((v) => v.name === "Baby's Leaf Spinach");
161:       expect(spinach).toBeDefined();
162: 
163: 
164:       const plantedDate = subDays(new Date(), 15);
165:       await plantService.addPlant({
166:         varietyId: spinach!.id,
167:         varietyName: spinach!.name,
168:         name: "Test Spinach Seedling",
169:         plantedDate,
170:         currentStage: "germination",
171:         location: "Indoor",
172:         container: "Small container",
173:         isActive: true,
174:       });
175: 
176:       renderWithRouter(<Plants />);
177: 
178:       await waitFor(() => {
179:         const matches = screen.getAllByText("Test Spinach Seedling");
180:         expect(matches.length).toBeGreaterThan(0);
181:       });
182: 
183: 
184:       await waitFor(() => {
185:         const stageText =
186:           screen.queryByText(/seedling/i) ||
187:           screen.queryByText(/Stage.*seedling/i);
188:         expect(stageText).toBeInTheDocument();
189:       });
190:     });
191:   });
192: });

================
File: src/__tests__/services/careSchedulingService.test.ts
================
  1: import { CareSchedulingService } from "@/services/careSchedulingService";
  2: import { plantService, varietyService, careService } from "@/types/database";
  3: import { initializeDatabase } from "@/db/seedData";
  4: import { subDays } from "date-fns";
  5: 
  6: describe("CareSchedulingService", () => {
  7:   beforeEach(async () => {
  8: 
  9:     const { db } = await import("@/types/database");
 10:     await db.plants.clear();
 11:     await db.varieties.clear();
 12:     await db.careActivities.clear();
 13:     await initializeDatabase();
 14:   });
 15: 
 16:   describe("Reminder Filtering", () => {
 17:     it("filters tasks based on reminder preferences", async () => {
 18: 
 19:       const varieties = await varietyService.getAllVarieties();
 20:       const testVariety = varieties[0];
 21: 
 22: 
 23: 
 24:       const plantWithSelectiveReminders = await plantService.addPlant({
 25:         varietyId: testVariety.id,
 26:         varietyName: testVariety.name,
 27:         plantedDate: subDays(new Date(), 10),
 28:         currentStage: "seedling",
 29:         location: "Indoor",
 30:         container: "4 inch pot",
 31:         isActive: true,
 32:         reminderPreferences: {
 33:           watering: false,
 34:           fertilizing: true,
 35:           observation: true,
 36:           lighting: false,
 37:           pruning: true,
 38:         },
 39:       });
 40: 
 41:       const tasks = await CareSchedulingService.getUpcomingTasks();
 42: 
 43: 
 44:       const plantTasks = tasks.filter(
 45:         (task) => task.plantId === plantWithSelectiveReminders
 46:       );
 47: 
 48: 
 49:       const wateringTasks = plantTasks.filter(
 50:         (task) =>
 51:           task.task.toLowerCase().includes("water") ||
 52:           task.task === "Check water level"
 53:       );
 54: 
 55:       expect(wateringTasks).toHaveLength(0);
 56: 
 57: 
 58:       const observationTasks = plantTasks.filter(
 59:         (task) =>
 60:           task.task === "Health check" ||
 61:           task.task.toLowerCase().includes("observe")
 62:       );
 63: 
 64: 
 65:       expect(observationTasks.length).toBeGreaterThan(0);
 66:     });
 67: 
 68:     it("shows all tasks when no reminder preferences are set", async () => {
 69: 
 70:       const varieties = await varietyService.getAllVarieties();
 71:       const testVariety = varieties[0];
 72: 
 73: 
 74:       const plantWithoutPreferences = await plantService.addPlant({
 75:         varietyId: testVariety.id,
 76:         varietyName: testVariety.name,
 77:         plantedDate: subDays(new Date(), 10),
 78:         currentStage: "seedling",
 79:         location: "Indoor",
 80:         container: "4 inch pot",
 81:         isActive: true,
 82: 
 83:       });
 84: 
 85:       const tasks = await CareSchedulingService.getUpcomingTasks();
 86: 
 87: 
 88:       const plantTasks = tasks.filter(
 89:         (task) => task.plantId === plantWithoutPreferences
 90:       );
 91:       expect(plantTasks.length).toBeGreaterThan(0);
 92: 
 93: 
 94:       const hasWateringTask = plantTasks.some(
 95:         (task) =>
 96:           task.task.toLowerCase().includes("water") ||
 97:           task.task === "Check water level"
 98:       );
 99:       const hasObservationTask = plantTasks.some(
100:         (task) =>
101:           task.task === "Health check" ||
102:           task.task.toLowerCase().includes("observe")
103:       );
104: 
105:       expect(hasWateringTask).toBe(true);
106:       expect(hasObservationTask).toBe(true);
107:     });
108: 
109:     it("handles plants with all reminders disabled", async () => {
110: 
111:       const varieties = await varietyService.getAllVarieties();
112:       const testVariety = varieties[0];
113: 
114: 
115:       const plantWithNoReminders = await plantService.addPlant({
116:         varietyId: testVariety.id,
117:         varietyName: testVariety.name,
118:         plantedDate: subDays(new Date(), 10),
119:         currentStage: "seedling",
120:         location: "Indoor",
121:         container: "4 inch pot",
122:         isActive: true,
123:         reminderPreferences: {
124:           watering: false,
125:           fertilizing: false,
126:           observation: false,
127:           lighting: false,
128:           pruning: false,
129:         },
130:       });
131: 
132:       const tasks = await CareSchedulingService.getUpcomingTasks();
133: 
134: 
135:       const plantTasks = tasks.filter(
136:         (task) => task.plantId === plantWithNoReminders
137:       );
138:       expect(plantTasks).toHaveLength(0);
139:     });
140:   });
141: 
142:   describe("Task Creation", () => {
143:     it("creates observation tasks for plants old enough", async () => {
144:       const varieties = await varietyService.getAllVarieties();
145:       const testVariety = varieties[0];
146: 
147: 
148:       const plantId = await plantService.addPlant({
149:         varietyId: testVariety.id,
150:         varietyName: testVariety.name,
151:         plantedDate: subDays(new Date(), 5),
152:         currentStage: "seedling",
153:         location: "Indoor",
154:         container: "4 inch pot",
155:         isActive: true,
156:         reminderPreferences: {
157:           watering: true,
158:           fertilizing: true,
159:           observation: true,
160:           lighting: true,
161:           pruning: true,
162:         },
163:       });
164: 
165:       const tasks = await CareSchedulingService.getUpcomingTasks();
166:       const plantTasks = tasks.filter((task) => task.plantId === plantId);
167: 
168: 
169:       const observationTasks = plantTasks.filter(
170:         (task) => task.task === "Health check"
171:       );
172: 
173:       expect(observationTasks.length).toBeGreaterThan(0);
174: 
175: 
176:       const observationTask = observationTasks[0];
177:       expect(observationTask.dueIn).toContain("overdue");
178:       expect(observationTask.priority).toBe("high");
179:     });
180: 
181:     it("creates watering tasks for plants that need water", async () => {
182:       const varieties = await varietyService.getAllVarieties();
183:       const testVariety = varieties[0];
184: 
185: 
186:       const plantId = await plantService.addPlant({
187:         varietyId: testVariety.id,
188:         varietyName: testVariety.name,
189:         plantedDate: subDays(new Date(), 5),
190:         currentStage: "seedling",
191:         location: "Indoor",
192:         container: "4 inch pot",
193:         isActive: true,
194:         reminderPreferences: {
195:           watering: true,
196:           fertilizing: true,
197:           observation: true,
198:           lighting: true,
199:           pruning: true,
200:         },
201:       });
202: 
203:       const tasks = await CareSchedulingService.getUpcomingTasks();
204:       const plantTasks = tasks.filter((task) => task.plantId === plantId);
205: 
206: 
207:       const wateringTasks = plantTasks.filter(
208:         (task) => task.task === "Check water level"
209:       );
210: 
211:       expect(wateringTasks.length).toBeGreaterThan(0);
212:     });
213:   });
214: 
215:   describe("getUpcomingTasks Edge Cases", () => {
216:     it("handles plants with no variety data gracefully", async () => {
217: 
218:       const orphanedPlant = await plantService.addPlant({
219:         varietyId: "non-existent-variety",
220:         varietyName: "Unknown Variety",
221:         plantedDate: subDays(new Date(), 5),
222:         currentStage: "seedling",
223:         location: "Indoor",
224:         container: "4 inch pot",
225:         isActive: true,
226:       });
227: 
228:       const tasks = await CareSchedulingService.getUpcomingTasks();
229: 
230: 
231:       const orphanedPlantTasks = tasks.filter(
232:         (task) => task.plantId === orphanedPlant
233:       );
234:       expect(orphanedPlantTasks).toHaveLength(0);
235:     });
236: 
237:     it("correctly prioritizes overdue vs upcoming tasks", async () => {
238:       const varieties = await varietyService.getAllVarieties();
239:       const testVariety = varieties[0];
240: 
241: 
242:       const overduePlant = await plantService.addPlant({
243:         varietyId: testVariety.id,
244:         varietyName: testVariety.name,
245:         plantedDate: subDays(new Date(), 10),
246:         currentStage: "seedling",
247:         location: "Indoor",
248:         container: "4 inch pot",
249:         isActive: true,
250:       });
251: 
252: 
253:       await careService.addCareActivity({
254:         plantId: overduePlant,
255:         type: "water",
256:         date: subDays(new Date(), 5),
257:         details: {
258:           type: "water",
259:           amount: { value: 8, unit: "oz" },
260:         },
261:       });
262: 
263:       const tasks = await CareSchedulingService.getUpcomingTasks();
264: 
265: 
266:       const sortedTasks = tasks.sort(
267:         (a, b) => a.dueDate.getTime() - b.dueDate.getTime()
268:       );
269: 
270: 
271:       const overdueTasks = sortedTasks.filter((task) =>
272:         task.dueIn.includes("overdue")
273:       );
274:       const upcomingTasks = sortedTasks.filter(
275:         (task) => !task.dueIn.includes("overdue")
276:       );
277: 
278:       if (overdueTasks.length > 0 && upcomingTasks.length > 0) {
279:         expect(overdueTasks[0].dueDate.getTime()).toBeLessThanOrEqual(
280:           upcomingTasks[0].dueDate.getTime()
281:         );
282:       }
283:     });
284: 
285:     it("respects reminder preferences filtering", async () => {
286:       const varieties = await varietyService.getAllVarieties();
287:       const testVariety = varieties[0];
288: 
289:       const plantWithSelectivePrefs = await plantService.addPlant({
290:         varietyId: testVariety.id,
291:         varietyName: testVariety.name,
292:         plantedDate: subDays(new Date(), 8),
293:         currentStage: "seedling",
294:         location: "Indoor",
295:         container: "4 inch pot",
296:         isActive: true,
297:         reminderPreferences: {
298:           watering: true,
299:           fertilizing: false,
300:           observation: false,
301:           lighting: false,
302:           pruning: false,
303:         },
304:       });
305: 
306:       const tasks = await CareSchedulingService.getUpcomingTasks();
307:       const plantTasks = tasks.filter(
308:         (task) => task.plantId === plantWithSelectivePrefs
309:       );
310: 
311: 
312:       const wateringTasks = plantTasks.filter(
313:         (task) =>
314:           task.task.toLowerCase().includes("water") ||
315:           task.task === "Check water level"
316:       );
317:       const nonWateringTasks = plantTasks.filter(
318:         (task) =>
319:           !task.task.toLowerCase().includes("water") &&
320:           task.task !== "Check water level"
321:       );
322: 
323:       expect(wateringTasks.length).toBeGreaterThan(0);
324:       expect(nonWateringTasks).toHaveLength(0);
325:     });
326: 
327:     it("handles database errors gracefully", async () => {
328: 
329:       const originalGetActivePlants = plantService.getActivePlants;
330:       jest
331:         .spyOn(plantService, "getActivePlants")
332:         .mockRejectedValue(new Error("Database connection failed"));
333: 
334:       const tasks = await CareSchedulingService.getUpcomingTasks();
335: 
336: 
337:       expect(tasks).toEqual([]);
338: 
339: 
340:       plantService.getActivePlants = originalGetActivePlants;
341:     });
342: 
343:     it("handles plants with corrupt variety references", async () => {
344:       const varieties = await varietyService.getAllVarieties();
345:       const validVariety = varieties[0];
346: 
347: 
348:       const validPlant = await plantService.addPlant({
349:         varietyId: validVariety.id,
350:         varietyName: validVariety.name,
351:         plantedDate: subDays(new Date(), 5),
352:         currentStage: "seedling",
353:         location: "Indoor",
354:         container: "4 inch pot",
355:         isActive: true,
356:       });
357: 
358: 
359:       const originalGetVariety = varietyService.getVariety;
360:       jest
361:         .spyOn(varietyService, "getVariety")
362:         .mockImplementation(async (id) => {
363:           if (id === validVariety.id) {
364:             return undefined;
365:           }
366:           return originalGetVariety(id);
367:         });
368: 
369:       const tasks = await CareSchedulingService.getUpcomingTasks();
370: 
371: 
372:       expect(Array.isArray(tasks)).toBe(true);
373: 
374: 
375:       const corruptedPlantTasks = tasks.filter(
376:         (task) => task.plantId === validPlant
377:       );
378:       expect(corruptedPlantTasks).toHaveLength(0);
379: 
380: 
381:       varietyService.getVariety = originalGetVariety;
382:     });
383: 
384:     it("correctly calculates priority levels", async () => {
385:       const varieties = await varietyService.getAllVarieties();
386:       const testVariety = varieties[0];
387: 
388:       const testPlant = await plantService.addPlant({
389:         varietyId: testVariety.id,
390:         varietyName: testVariety.name,
391:         plantedDate: subDays(new Date(), 10),
392:         currentStage: "seedling",
393:         location: "Indoor",
394:         container: "4 inch pot",
395:         isActive: true,
396:       });
397: 
398: 
399:       await careService.addCareActivity({
400:         plantId: testPlant,
401:         type: "water",
402:         date: subDays(new Date(), 3),
403:         details: {
404:           type: "water",
405:           amount: { value: 8, unit: "oz" },
406:         },
407:       });
408: 
409:       const tasks = await CareSchedulingService.getUpcomingTasks();
410:       const plantTasks = tasks.filter((task) => task.plantId === testPlant);
411: 
412:       if (plantTasks.length > 0) {
413:         const wateringTask = plantTasks.find(
414:           (task) => task.task === "Check water level"
415:         );
416: 
417:         if (wateringTask) {
418: 
419:           if (wateringTask.dueIn.includes("overdue")) {
420:             const overdueDays = parseInt(
421:               wateringTask.dueIn.match(/\d+/)?.[0] || "0"
422:             );
423:             if (overdueDays >= 2) {
424:               expect(wateringTask.priority).toBe("high");
425:             } else if (overdueDays >= 0) {
426:               expect(wateringTask.priority).toBe("medium");
427:             }
428:           }
429:         }
430:       }
431:     });
432: 
433:     it("handles empty plant database", async () => {
434: 
435:       await plantService.getActivePlants().then(async (plants) => {
436:         for (const plant of plants) {
437:           await plantService.deletePlant(plant.id);
438:         }
439:       });
440: 
441:       const tasks = await CareSchedulingService.getUpcomingTasks();
442: 
443:       expect(tasks).toEqual([]);
444:     });
445: 
446:     it("handles inactive plants correctly", async () => {
447:       const varieties = await varietyService.getAllVarieties();
448:       const testVariety = varieties[0];
449: 
450: 
451:       const inactivePlant = await plantService.addPlant({
452:         varietyId: testVariety.id,
453:         varietyName: testVariety.name,
454:         plantedDate: subDays(new Date(), 10),
455:         currentStage: "seedling",
456:         location: "Indoor",
457:         container: "4 inch pot",
458:         isActive: false,
459:       });
460: 
461:       const tasks = await CareSchedulingService.getUpcomingTasks();
462: 
463: 
464:       const inactivePlantTasks = tasks.filter(
465:         (task) => task.plantId === inactivePlant
466:       );
467:       expect(inactivePlantTasks).toHaveLength(0);
468:     });
469:   });
470: 
471:   describe("getNextTaskForPlant Edge Cases", () => {
472:     it("returns null for non-existent plant", async () => {
473:       const task = await CareSchedulingService.getNextTaskForPlant(
474:         "non-existent-id"
475:       );
476:       expect(task).toBeNull();
477:     });
478: 
479:     it("returns null for inactive plant", async () => {
480:       const varieties = await varietyService.getAllVarieties();
481:       const testVariety = varieties[0];
482: 
483:       const inactivePlant = await plantService.addPlant({
484:         varietyId: testVariety.id,
485:         varietyName: testVariety.name,
486:         plantedDate: subDays(new Date(), 5),
487:         currentStage: "seedling",
488:         location: "Indoor",
489:         container: "4 inch pot",
490:         isActive: false,
491:       });
492: 
493:       const task = await CareSchedulingService.getNextTaskForPlant(
494:         inactivePlant
495:       );
496:       expect(task).toBeNull();
497:     });
498: 
499:     it("handles plant with no eligible tasks", async () => {
500:       const varieties = await varietyService.getAllVarieties();
501:       const testVariety = varieties[0];
502: 
503:       const plantWithNoTasks = await plantService.addPlant({
504:         varietyId: testVariety.id,
505:         varietyName: testVariety.name,
506:         plantedDate: new Date(),
507:         currentStage: "germination",
508:         location: "Indoor",
509:         container: "seed tray",
510:         isActive: true,
511:         reminderPreferences: {
512:           watering: false,
513:           fertilizing: false,
514:           observation: false,
515:           lighting: false,
516:           pruning: false,
517:         },
518:       });
519: 
520:       const task = await CareSchedulingService.getNextTaskForPlant(
521:         plantWithNoTasks
522:       );
523:       expect(task).toBeNull();
524:     });
525: 
526:     it("returns highest priority task when multiple exist", async () => {
527:       const varieties = await varietyService.getAllVarieties();
528:       const testVariety = varieties[0];
529: 
530:       const testPlant = await plantService.addPlant({
531:         varietyId: testVariety.id,
532:         varietyName: testVariety.name,
533:         plantedDate: subDays(new Date(), 15),
534:         currentStage: "seedling",
535:         location: "Indoor",
536:         container: "4 inch pot",
537:         isActive: true,
538:       });
539: 
540: 
541:       await careService.addCareActivity({
542:         plantId: testPlant,
543:         type: "water",
544:         date: subDays(new Date(), 5),
545:         details: {
546:           type: "water",
547:           amount: { value: 8, unit: "oz" },
548:         },
549:       });
550: 
551:       const nextTask = await CareSchedulingService.getNextTaskForPlant(
552:         testPlant
553:       );
554: 
555:       if (nextTask) {
556: 
557:         expect(nextTask.plantId).toBe(testPlant);
558:         expect(nextTask.dueDate).toBeInstanceOf(Date);
559:       }
560:     });
561:   });
562: 
563:   describe("Task Formatting and Calculation", () => {
564:     it("correctly formats due dates", async () => {
565:       const varieties = await varietyService.getAllVarieties();
566:       const testVariety = varieties[0];
567: 
568:       const testPlant = await plantService.addPlant({
569:         varietyId: testVariety.id,
570:         varietyName: testVariety.name,
571:         plantedDate: subDays(new Date(), 5),
572:         currentStage: "seedling",
573:         location: "Indoor",
574:         container: "4 inch pot",
575:         isActive: true,
576:       });
577: 
578:       const tasks = await CareSchedulingService.getUpcomingTasks();
579:       const plantTasks = tasks.filter((task) => task.plantId === testPlant);
580: 
581:       plantTasks.forEach((task) => {
582: 
583:         expect(task.dueIn).toMatch(
584:           /^(Due today|Due tomorrow|Due in \d+ days?|\d+ days? overdue)$/
585:         );
586: 
587: 
588:         expect(["low", "medium", "high"]).toContain(task.priority);
589: 
590: 
591:         expect(task.plantStage).toBeDefined();
592:         expect(typeof task.plantStage).toBe("string");
593:       });
594:     });
595: 
596:     it("handles stage calculation errors gracefully", async () => {
597:       const varieties = await varietyService.getAllVarieties();
598:       const testVariety = varieties[0];
599: 
600: 
601:       const testPlant = await plantService.addPlant({
602:         varietyId: testVariety.id,
603:         varietyName: testVariety.name,
604:         plantedDate: subDays(new Date(), 5),
605:         currentStage: "seedling",
606:         location: "Indoor",
607:         container: "4 inch pot",
608:         isActive: true,
609:       });
610: 
611: 
612:       const growthStageModule = await import("@/utils/growthStage");
613:       const mockCalculateCurrentStage = jest
614:         .spyOn(growthStageModule, "calculateCurrentStage")
615:         .mockImplementation(() => {
616:           throw new Error("Stage calculation failed");
617:         });
618: 
619:       const tasks = await CareSchedulingService.getUpcomingTasks();
620: 
621: 
622:       expect(Array.isArray(tasks)).toBe(true);
623: 
624: 
625:       const plantTasks = tasks.filter((task) => task.plantId === testPlant);
626:       expect(plantTasks).toHaveLength(0);
627: 
628: 
629:       expect(mockCalculateCurrentStage).toHaveBeenCalled();
630: 
631: 
632:       mockCalculateCurrentStage.mockRestore();
633:     });
634:   });
635: });

================
File: src/__tests__/utils/growthStage.test.ts
================
  1: import {
  2:   calculateCurrentStage,
  3:   calculateCurrentStageWithVariety,
  4:   getStageProgress,
  5:   estimateStageTransition,
  6:   getNextStage,
  7: } from "../../utils/growthStage";
  8: import { restoreDate } from "../../setupTests";
  9: import { VarietyRecord } from "../../types/database";
 10: import { GrowthStage } from "@/types";
 11: 
 12: describe("Growth Stage Utilities", () => {
 13:   const mockTimeline = {
 14:     germination: 7,
 15:     seedling: 14,
 16:     vegetative: 21,
 17:     maturation: 60,
 18:   };
 19: 
 20: 
 21:   const mockEverbearingVariety: VarietyRecord = {
 22:     id: "albion-strawberry",
 23:     name: "Albion Strawberries",
 24:     category: "berries",
 25:     growthTimeline: {
 26:       germination: 14,
 27:       seedling: 28,
 28:       vegetative: 42,
 29:       maturation: 90,
 30:     },
 31:     isEverbearing: true,
 32:     productiveLifespan: 730,
 33:     createdAt: new Date(),
 34:   };
 35: 
 36:   const mockNonEverbearingVariety: VarietyRecord = {
 37:     id: "little-finger-carrots",
 38:     name: "Little Finger Carrots",
 39:     category: "root-vegetables",
 40:     growthTimeline: {
 41:       germination: 10,
 42:       seedling: 14,
 43:       vegetative: 21,
 44:       maturation: 65,
 45:     },
 46:     isEverbearing: false,
 47:     createdAt: new Date(),
 48:   };
 49: 
 50:   beforeEach(() => {
 51:     restoreDate();
 52:   });
 53: 
 54:   describe("calculateCurrentStage (basic function)", () => {
 55:     it("returns germination for early days", () => {
 56:       const plantedDate = new Date("2024-01-01");
 57:       const currentDate = new Date("2024-01-05");
 58: 
 59:       const stage = calculateCurrentStage(
 60:         plantedDate,
 61:         mockTimeline,
 62:         currentDate
 63:       );
 64:       expect(stage).toBe("germination");
 65:     });
 66: 
 67:     it("transitions to seedling correctly", () => {
 68:       const plantedDate = new Date("2024-01-01");
 69:       const currentDate = new Date("2024-01-08");
 70: 
 71:       const stage = calculateCurrentStage(
 72:         plantedDate,
 73:         mockTimeline,
 74:         currentDate
 75:       );
 76:       expect(stage).toBe("seedling");
 77:     });
 78: 
 79:     it("transitions to vegetative correctly", () => {
 80:       const plantedDate = new Date("2024-01-01");
 81:       const currentDate = new Date("2024-01-22");
 82: 
 83:       const stage = calculateCurrentStage(
 84:         plantedDate,
 85:         mockTimeline,
 86:         currentDate
 87:       );
 88:       expect(stage).toBe("vegetative");
 89:     });
 90: 
 91:     it("transitions to flowering correctly", () => {
 92:       const plantedDate = new Date("2024-01-01");
 93:       const currentDate = new Date("2024-02-12");
 94: 
 95:       const stage = calculateCurrentStage(
 96:         plantedDate,
 97:         mockTimeline,
 98:         currentDate
 99:       );
100:       expect(stage).toBe("flowering");
101:     });
102: 
103:     it("returns harvest for plants past maturation date", () => {
104: 
105:       const plantedDate = new Date("2024-01-01");
106:       const currentDate = new Date("2024-03-05");
107: 
108:       const stage = calculateCurrentStage(
109:         plantedDate,
110:         mockTimeline,
111:         currentDate
112:       );
113:       expect(stage).toBe("harvest");
114:     });
115: 
116:     it("handles future planting dates gracefully", () => {
117:       const plantedDate = new Date("2024-12-31");
118:       const currentDate = new Date("2024-01-01");
119: 
120:       const stage = calculateCurrentStage(
121:         plantedDate,
122:         mockTimeline,
123:         currentDate
124:       );
125:       expect(stage).toBe("germination");
126:     });
127: 
128:     it("handles leap year edge cases", () => {
129:       const plantedDate = new Date("2024-02-28");
130:       const currentDate = new Date("2024-03-01");
131: 
132:       const stage = calculateCurrentStage(
133:         plantedDate,
134:         mockTimeline,
135:         currentDate
136:       );
137:       expect(stage).toBe("germination");
138:     });
139: 
140:     it("handles timezone DST transitions", () => {
141: 
142:       const plantedDate = new Date("2024-03-09T12:00:00");
143:       const currentDate = new Date("2024-03-11T12:00:00");
144: 
145:       const stage = calculateCurrentStage(
146:         plantedDate,
147:         mockTimeline,
148:         currentDate
149:       );
150:       expect(stage).toBe("germination");
151:     });
152:   });
153: 
154:   describe("calculateCurrentStageWithVariety (enhanced function)", () => {
155:     describe("everbearing plants", () => {
156:       it("returns ongoing-production for everbearing plants after maturation", () => {
157:         const plantedDate = new Date("2024-01-01");
158:         const currentDate = new Date("2024-04-05");
159: 
160:         const stage = calculateCurrentStageWithVariety(
161:           plantedDate,
162:           mockEverbearingVariety,
163:           currentDate
164:         );
165:         expect(stage).toBe("ongoing-production");
166:       });
167: 
168:       it("handles the exact strawberry scenario (103 days)", () => {
169:         const plantedDate = new Date("2024-01-01");
170:         const currentDate = new Date("2024-04-14");
171: 
172:         const stage = calculateCurrentStageWithVariety(
173:           plantedDate,
174:           mockEverbearingVariety,
175:           currentDate
176:         );
177:         expect(stage).toBe("ongoing-production");
178:       });
179: 
180:       it("returns harvest when past productive lifespan", () => {
181:         const plantedDate = new Date("2022-01-01");
182:         const currentDate = new Date("2024-02-01");
183: 
184:         const stage = calculateCurrentStageWithVariety(
185:           plantedDate,
186:           mockEverbearingVariety,
187:           currentDate
188:         );
189:         expect(stage).toBe("harvest");
190:       });
191: 
192:       it("follows normal growth stages before maturation", () => {
193:         const testCases = [
194:           { days: 5, expected: "germination" },
195:           { days: 20, expected: "seedling" },
196:           { days: 50, expected: "vegetative" },
197:           { days: 87, expected: "flowering" },
198:         ];
199: 
200:         testCases.forEach(({ days, expected }) => {
201:           const plantedDate = new Date("2024-01-01");
202:           const currentDate = new Date(plantedDate);
203:           currentDate.setDate(currentDate.getDate() + days);
204: 
205:           const stage = calculateCurrentStageWithVariety(
206:             plantedDate,
207:             mockEverbearingVariety,
208:             currentDate
209:           );
210:           expect(stage).toBe(expected);
211:         });
212:       });
213:     });
214: 
215:     describe("non-everbearing plants", () => {
216:       it("returns harvest for non-everbearing plants after maturation", () => {
217:         const plantedDate = new Date("2024-01-01");
218:         const currentDate = new Date("2024-03-10");
219: 
220:         const stage = calculateCurrentStageWithVariety(
221:           plantedDate,
222:           mockNonEverbearingVariety,
223:           currentDate
224:         );
225:         expect(stage).toBe("harvest");
226:       });
227: 
228:       it("follows normal growth stages before maturation", () => {
229:         const testCases = [
230:           { days: 5, expected: "germination" },
231:           { days: 15, expected: "seedling" },
232:           { days: 30, expected: "vegetative" },
233:           { days: 60, expected: "flowering" },
234:         ];
235: 
236:         testCases.forEach(({ days, expected }) => {
237:           const plantedDate = new Date("2024-01-01");
238:           const currentDate = new Date(plantedDate);
239:           currentDate.setDate(currentDate.getDate() + days);
240: 
241:           const stage = calculateCurrentStageWithVariety(
242:             plantedDate,
243:             mockNonEverbearingVariety,
244:             currentDate
245:           );
246:           expect(stage).toBe(expected);
247:         });
248:       });
249:     });
250: 
251:     describe("edge cases", () => {
252:       it("handles everbearing plants without productiveLifespan", () => {
253:         const varietyWithoutLifespan: VarietyRecord = {
254:           ...mockEverbearingVariety,
255:           productiveLifespan: undefined,
256:         };
257: 
258:         const plantedDate = new Date("2022-01-01");
259:         const currentDate = new Date("2024-01-01");
260: 
261:         const stage = calculateCurrentStageWithVariety(
262:           plantedDate,
263:           varietyWithoutLifespan,
264:           currentDate
265:         );
266:         expect(stage).toBe("harvest");
267:       });
268: 
269:       it("handles future planting dates gracefully", () => {
270:         const plantedDate = new Date("2024-12-31");
271:         const currentDate = new Date("2024-01-01");
272: 
273:         const stage = calculateCurrentStageWithVariety(
274:           plantedDate,
275:           mockEverbearingVariety,
276:           currentDate
277:         );
278:         expect(stage).toBe("germination");
279:       });
280:     });
281:   });
282: 
283:   describe("getStageProgress", () => {
284:     it("calculates progress correctly mid-stage", () => {
285:       const plantedDate = new Date("2024-01-01");
286:       const currentDate = new Date("2024-01-11");
287: 
288:       const progress = getStageProgress(plantedDate, mockTimeline, currentDate);
289: 
290:       expect(progress).toBeCloseTo(21, 0);
291:     });
292: 
293:     it("returns 100% for completed stages", () => {
294:       const plantedDate = new Date("2024-01-01");
295:       const currentDate = new Date("2024-03-01");
296: 
297:       const progress = getStageProgress(plantedDate, mockTimeline, currentDate);
298:       expect(progress).toBe(100);
299:     });
300: 
301:     it("handles all new stage types", () => {
302:       const plantedDate = new Date("2024-01-01");
303:       const currentDate = new Date("2024-03-01");
304: 
305: 
306:       const timeline = { ...mockTimeline };
307:       const progress = getStageProgress(plantedDate, timeline, currentDate);
308:       expect(progress).toBe(100);
309:     });
310:   });
311: 
312:   describe("getNextStage", () => {
313:     it("returns correct next stages for basic progression", () => {
314:       expect(getNextStage("germination")).toBe("seedling");
315:       expect(getNextStage("seedling")).toBe("vegetative");
316:       expect(getNextStage("vegetative")).toBe("flowering");
317:       expect(getNextStage("flowering")).toBe("maturation");
318:       expect(getNextStage("maturation")).toBe("ongoing-production");
319:       expect(getNextStage("ongoing-production")).toBe("harvest");
320:     });
321: 
322:     it("returns null for the final stage", () => {
323:       expect(getNextStage("harvest")).toBe(null);
324:     });
325: 
326:     it("handles invalid stages gracefully", () => {
327: 
328:       expect(getNextStage(undefined as unknown as GrowthStage)).toBe(null);
329: 
330: 
331:       const invalidStage = "not-a-real-stage" as unknown as GrowthStage;
332:       expect(getNextStage(invalidStage)).toBe(null);
333:     });
334:   });
335: 
336:   describe("estimateStageTransition", () => {
337:     it("estimates correct transition dates", () => {
338:       const plantedDate = new Date("2024-01-01");
339: 
340:       const floweringDate = estimateStageTransition(
341:         plantedDate,
342:         mockTimeline,
343:         "flowering"
344:       );
345:       expect(floweringDate).toEqual(new Date("2024-02-12"));
346:     });
347: 
348:     it("handles new stage types", () => {
349:       const plantedDate = new Date("2024-01-01");
350: 
351:       const ongoingProductionDate = estimateStageTransition(
352:         plantedDate,
353:         mockTimeline,
354:         "ongoing-production"
355:       );
356:       expect(ongoingProductionDate).toEqual(new Date("2024-03-01"));
357: 
358:       const harvestDate = estimateStageTransition(
359:         plantedDate,
360:         mockTimeline,
361:         "harvest"
362:       );
363:       expect(harvestDate).toEqual(new Date("2024-03-01"));
364:     });
365:   });
366: 
367:   describe("integration tests with real variety data", () => {
368:     it("correctly handles Albion strawberry timeline", () => {
369:       const plantedDate = new Date("2024-01-01");
370: 
371: 
372:       const testCases = [
373:         { days: 10, expected: "germination" },
374:         { days: 20, expected: "seedling" },
375:         { days: 50, expected: "vegetative" },
376:         { days: 87, expected: "flowering" },
377:         { days: 103, expected: "ongoing-production" },
378:         { days: 365, expected: "ongoing-production" },
379:         { days: 731, expected: "harvest" },
380:       ];
381: 
382:       testCases.forEach(({ days, expected }) => {
383:         const currentDate = new Date(plantedDate);
384:         currentDate.setDate(currentDate.getDate() + days);
385: 
386:         const stage = calculateCurrentStageWithVariety(
387:           plantedDate,
388:           mockEverbearingVariety,
389:           currentDate
390:         );
391: 
392:         expect(stage).toBe(expected);
393:       });
394:     });
395: 
396:     it("correctly handles Caroline raspberry timeline", () => {
397:       const raspberryVariety: VarietyRecord = {
398:         id: "caroline-raspberry",
399:         name: "Caroline Raspberries",
400:         category: "berries",
401:         growthTimeline: {
402:           germination: 0,
403:           seedling: 21,
404:           vegetative: 42,
405:           maturation: 120,
406:         },
407:         isEverbearing: true,
408:         productiveLifespan: 1095,
409:         createdAt: new Date(),
410:       };
411: 
412:       const plantedDate = new Date("2024-01-01");
413:       const testCases = [
414:         { days: 10, expected: "seedling" },
415:         { days: 30, expected: "vegetative" },
416:         { days: 60, expected: "vegetative" },
417:         { days: 110, expected: "flowering" },
418:         { days: 130, expected: "ongoing-production" },
419:         { days: 1000, expected: "ongoing-production" },
420:         { days: 1100, expected: "harvest" },
421:       ];
422: 
423:       testCases.forEach(({ days, expected }) => {
424:         const currentDate = new Date(plantedDate);
425:         currentDate.setDate(currentDate.getDate() + days);
426: 
427:         const stage = calculateCurrentStageWithVariety(
428:           plantedDate,
429:           raspberryVariety,
430:           currentDate
431:         );
432: 
433:         expect(stage).toBe(expected);
434:       });
435:     });
436:   });
437: });

================
File: src/components/layouts/Welcome.tsx
================
  1: import React, { useState } from "react";
  2: import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/Card";
  3: import { Button } from "@/components/ui/Button";
  4: import { Link } from "react-router-dom";
  5: 
  6: const Welcome: React.FC = () => {
  7:   const [currentStep, setCurrentStep] = useState(0);
  8: 
  9:   const onboardingSteps = [
 10:     {
 11:       title: "Welcome to SmartGarden",
 12:       content: (
 13:         <div className="text-center space-y-6">
 14:           <div className="text-7xl mb-6 animate-bounce">🌿</div>
 15:           <div className="space-y-4">
 16:             <h2 className="text-3xl font-black text-foreground leading-tight">
 17:               Your digital gardening companion
 18:             </h2>
 19:             <p className="text-muted-foreground leading-relaxed text-lg">
 20:               Track your plants, schedule care tasks, and grow healthier gardens
 21:               with science-backed protocols.
 22:             </p>
 23:           </div>
 24:         </div>
 25:       ),
 26:     },
 27:     {
 28:       title: "Smart Care Scheduling",
 29:       content: (
 30:         <div className="text-center space-y-6">
 31:           <div className="text-7xl mb-6 animate-pulse">📅</div>
 32:           <div className="space-y-4">
 33:             <h2 className="text-3xl font-black text-foreground leading-tight">
 34:               Never miss a watering
 35:             </h2>
 36:             <p className="text-muted-foreground leading-relaxed text-lg">
 37:               Get personalized care reminders based on your plants' growth
 38:               stages and your logging history.
 39:             </p>
 40:           </div>
 41:         </div>
 42:       ),
 43:     },
 44:     {
 45:       title: "Photo & Progress Tracking",
 46:       content: (
 47:         <div className="text-center space-y-6">
 48:           <div className="text-7xl mb-6">📸</div>
 49:           <div className="space-y-4">
 50:             <h2 className="text-3xl font-black text-foreground leading-tight">
 51:               Document your garden's journey
 52:             </h2>
 53:             <p className="text-muted-foreground leading-relaxed text-lg">
 54:               Capture photos, log activities, and watch your plants thrive with
 55:               detailed growth tracking.
 56:             </p>
 57:           </div>
 58:         </div>
 59:       ),
 60:     },
 61:     {
 62:       title: "Ready to Start?",
 63:       content: (
 64:         <div className="text-center space-y-6">
 65:           <div className="text-7xl mb-6">🚀</div>
 66:           <div className="space-y-4">
 67:             <h2 className="text-3xl font-black text-foreground leading-tight">
 68:               Let's add your first plant
 69:             </h2>
 70:             <p className="text-muted-foreground leading-relaxed text-lg">
 71:               Start your digital garden by registering your first plant. We'll
 72:               guide you through the process.
 73:             </p>
 74:           </div>
 75:         </div>
 76:       ),
 77:     },
 78:   ];
 79: 
 80:   const nextStep = () => {
 81:     if (currentStep < onboardingSteps.length - 1) {
 82:       setCurrentStep(currentStep + 1);
 83:     }
 84:   };
 85: 
 86:   const previousStep = () => {
 87:     if (currentStep > 0) {
 88:       setCurrentStep(currentStep - 1);
 89:     }
 90:   };
 91: 
 92:   const currentStepData = onboardingSteps[currentStep];
 93:   const isLastStep = currentStep === onboardingSteps.length - 1;
 94:   const isFirstStep = currentStep === 0;
 95: 
 96:   return (
 97:     <div className="min-h-screen bg-gradient-to-br from-emerald-50 via-green-50 to-blue-50 flex items-center justify-center p-4">
 98:       <div className="w-full max-w-sm">
 99:         <Card className="shadow-2xl border-0 bg-card/95 backdrop-blur-lg rounded-3xl overflow-hidden">
100:           <CardHeader className="text-center pb-6 bg-gradient-to-r from-emerald-500/5 to-green-500/5">
101:             <CardTitle className="text-xs font-bold text-muted-foreground uppercase tracking-widest">
102:               {currentStepData.title}
103:             </CardTitle>
104: 
105:             {}
106:             <div className="flex justify-center mt-8 space-x-2">
107:               {onboardingSteps.map((_, index) => (
108:                 <div
109:                   key={index}
110:                   className={`h-3 rounded-full transition-all duration-500 ease-out ${
111:                     index === currentStep
112:                       ? "w-8 bg-gradient-to-r from-emerald-500 to-green-600 shadow-lg shadow-emerald-500/40"
113:                       : index < currentStep
114:                       ? "w-3 bg-emerald-400"
115:                       : "w-3 bg-gray-200"
116:                   }`}
117:                 />
118:               ))}
119:             </div>
120:           </CardHeader>
121: 
122:           <CardContent className="pb-8 px-6">
123:             {}
124:             <div className="min-h-80 flex items-center justify-center mb-8">
125:               {currentStepData.content}
126:             </div>
127: 
128:             {}
129:             <div className="space-y-4">
130:               {}
131:               <div className="w-full">
132:                 {isLastStep ? (
133:                   <Link to="/add-plant" className="block">
134:                     <Button
135:                       size="lg"
136:                       className="w-full group"
137:                       rightIcon={
138:                         <span className="text-2xl group-hover:scale-110 transition-transform duration-200">
139:                           🌱
140:                         </span>
141:                       }
142:                     >
143:                       Add My First Plant
144:                     </Button>
145:                   </Link>
146:                 ) : (
147:                   <Button
148:                     onClick={nextStep}
149:                     size="lg"
150:                     className="w-full group"
151:                     rightIcon={
152:                       <svg
153:                         className="w-5 h-5 group-hover:translate-x-1 transition-transform duration-200"
154:                         fill="none"
155:                         stroke="currentColor"
156:                         viewBox="0 0 24 24"
157:                       >
158:                         <path
159:                           strokeLinecap="round"
160:                           strokeLinejoin="round"
161:                           strokeWidth={3}
162:                           d="M9 5l7 7-7 7"
163:                         />
164:                       </svg>
165:                     }
166:                   >
167:                     Continue
168:                   </Button>
169:                 )}
170:               </div>
171: 
172:               {}
173:               <div className="flex gap-3">
174:                 <div className="flex-1">
175:                   {!isFirstStep && (
176:                     <Button
177:                       variant="ghost"
178:                       onClick={previousStep}
179:                       className="w-full"
180:                       leftIcon={
181:                         <svg
182:                           className="w-4 h-4"
183:                           fill="none"
184:                           stroke="currentColor"
185:                           viewBox="0 0 24 24"
186:                         >
187:                           <path
188:                             strokeLinecap="round"
189:                             strokeLinejoin="round"
190:                             strokeWidth={2}
191:                             d="M15 19l-7-7 7-7"
192:                           />
193:                         </svg>
194:                       }
195:                     >
196:                       Back
197:                     </Button>
198:                   )}
199:                 </div>
200:                 <div className="flex-1">
201:                   {!isLastStep && (
202:                     <Link to="/add-plant" className="block">
203:                       <Button
204:                         variant="ghost"
205:                         className="w-full"
206:                         rightIcon={
207:                           <svg
208:                             className="w-4 h-4"
209:                             fill="none"
210:                             stroke="currentColor"
211:                             viewBox="0 0 24 24"
212:                           >
213:                             <path
214:                               strokeLinecap="round"
215:                               strokeLinejoin="round"
216:                               strokeWidth={2}
217:                               d="M9 5l7 7-7 7"
218:                             />
219:                           </svg>
220:                         }
221:                       >
222:                         Skip
223:                       </Button>
224:                     </Link>
225:                   )}
226:                 </div>
227:               </div>
228:             </div>
229:           </CardContent>
230:         </Card>
231:       </div>
232:     </div>
233:   );
234: };
235: 
236: export default Welcome;

================
File: src/components/plant/CustomVarietyForm.tsx
================
  1: import { useState } from "react";
  2: import { useForm } from "react-hook-form";
  3: import { zodResolver } from "@hookform/resolvers/zod";
  4: import { z } from "zod";
  5: import { Button } from "@/components/ui/Button";
  6: import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/Card";
  7: import { varietyService } from "@/types/database";
  8: import toast from "react-hot-toast";
  9: 
 10: const customVarietySchema = z.object({
 11:   name: z.string().min(1, "Variety name is required"),
 12:   category: z.enum([
 13:     "root-vegetables",
 14:     "leafy-greens",
 15:     "herbs",
 16:     "berries",
 17:     "fruiting-plants",
 18:   ]),
 19:   growthTimeline: z.object({
 20:     germination: z.number().min(1).max(90),
 21:     seedling: z.number().min(1).max(90),
 22:     vegetative: z.number().min(1).max(180),
 23:     maturation: z.number().min(1).max(365),
 24:   }),
 25:   customMoistureRanges: z.boolean().optional(),
 26:   triggerMin: z.number().min(1).max(10).optional(),
 27:   triggerMax: z.number().min(1).max(10).optional(),
 28:   targetMin: z.number().min(1).max(10).optional(),
 29:   targetMax: z.number().min(1).max(10).optional(),
 30: });
 31: 
 32: type CustomVarietyData = z.infer<typeof customVarietySchema>;
 33: 
 34: interface CustomVarietyFormProps {
 35:   onSuccess?: (varietyId: string) => void;
 36:   onCancel?: () => void;
 37: }
 38: 
 39: export function CustomVarietyForm({
 40:   onSuccess,
 41:   onCancel,
 42: }: CustomVarietyFormProps) {
 43:   const [isLoading, setIsLoading] = useState(false);
 44:   const [showMoistureCustomization, setShowMoistureCustomization] =
 45:     useState(false);
 46: 
 47:   const {
 48:     register,
 49:     handleSubmit,
 50:     formState: { errors },
 51:     reset,
 52:   } = useForm<CustomVarietyData>({
 53:     resolver: zodResolver(customVarietySchema),
 54:     defaultValues: {
 55:       triggerMin: 3,
 56:       triggerMax: 4,
 57:       targetMin: 6,
 58:       targetMax: 7,
 59:     },
 60:   });
 61: 
 62:   async function onSubmit(data: CustomVarietyData) {
 63:     setIsLoading(true);
 64:     try {
 65: 
 66:       let moistureProtocols = undefined;
 67:       if (
 68:         data.customMoistureRanges &&
 69:         data.triggerMin &&
 70:         data.triggerMax &&
 71:         data.targetMin &&
 72:         data.targetMax
 73:       ) {
 74:         const ranges = {
 75:           trigger: { min: data.triggerMin, max: data.triggerMax },
 76:           target: { min: data.targetMin, max: data.targetMax },
 77:         };
 78: 
 79: 
 80:         moistureProtocols = {
 81:           germination: ranges,
 82:           seedling: ranges,
 83:           vegetative: ranges,
 84:           flowering: ranges,
 85:           fruiting: ranges,
 86:           maturation: ranges,
 87:           harvest: ranges,
 88:         };
 89:       }
 90: 
 91:       const varietyId = await varietyService.addVariety({
 92:         name: data.name,
 93:         category: data.category,
 94:         growthTimeline: data.growthTimeline,
 95:         moistureProtocols,
 96:         isCustom: true,
 97:       });
 98: 
 99:       toast.success(`Created custom variety: ${data.name}!`);
100:       reset();
101:       onSuccess?.(varietyId);
102:     } catch (error) {
103:       console.error("Failed to create variety:", error);
104:       toast.error("Failed to create variety. Please try again.");
105:     } finally {
106:       setIsLoading(false);
107:     }
108:   }
109: 
110:   return (
111:     <Card className="max-w-2xl mx-auto">
112:       <CardHeader>
113:         <CardTitle>Create Custom Plant Variety</CardTitle>
114:         <p className="text-sm text-muted-foreground mt-1">
115:           Add your own plant varieties like pumpkins, exotic herbs, or local
116:           cultivars
117:         </p>
118:       </CardHeader>
119:       <CardContent>
120:         <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
121:           <div>
122:             <label className="block text-sm font-medium text-foreground mb-2">
123:               Variety Name *
124:             </label>
125:             <input
126:               {...register("name")}
127:               placeholder="e.g., Jack-o'-lantern Pumpkins, Cherokee Purple Tomatoes"
128:               className="w-full p-3 border border-border rounded-md focus:ring-2 focus:ring-garden-500"
129:             />
130:             {errors.name && (
131:               <p className="mt-1 text-sm text-red-600">{errors.name.message}</p>
132:             )}
133:           </div>
134: 
135:           <div>
136:             <label className="block text-sm font-medium text-foreground mb-2">
137:               Category *
138:             </label>
139:             <select
140:               {...register("category")}
141:               className="w-full p-3 border border-border rounded-md focus:ring-2 focus:ring-garden-500"
142:             >
143:               <option value="fruiting-plants">
144:                 🎃 Fruiting Plants (pumpkins, squash, melons, etc.)
145:               </option>
146:               <option value="leafy-greens">
147:                 🥬 Leafy Greens (lettuce, spinach, kale, etc.)
148:               </option>
149:               <option value="root-vegetables">
150:                 🥕 Root Vegetables (carrots, beets, radishes, etc.)
151:               </option>
152:               <option value="herbs">
153:                 🌿 Herbs (basil, cilantro, sage, etc.)
154:               </option>
155:               <option value="berries">
156:                 🫐 Berries (strawberries, raspberries, etc.)
157:               </option>
158:             </select>
159:             <p className="mt-1 text-xs text-muted-foreground">
160:               This determines default care guidelines and protocols
161:             </p>
162:           </div>
163: 
164:           {}
165:           <div>
166:             <h3 className="text-lg font-medium text-foreground mb-4">
167:               Growth Timeline (days)
168:             </h3>
169:             <p className="text-sm text-muted-foreground mb-4">
170:               How long does each growth stage typically last? These help predict
171:               care needs.
172:             </p>
173:             <div className="grid grid-cols-2 gap-4">
174:               <div>
175:                 <label className="block text-sm font-medium text-foreground mb-2">
176:                   Germination Days
177:                 </label>
178:                 <input
179:                   type="number"
180:                   {...register("growthTimeline.germination", {
181:                     valueAsNumber: true,
182:                   })}
183:                   placeholder="7"
184:                   className="w-full p-3 border border-border rounded-md focus:ring-2 focus:ring-garden-500"
185:                 />
186:                 <p className="text-xs text-muted-foreground mt-1">
187:                   Days to sprout
188:                 </p>
189:               </div>
190:               <div>
191:                 <label className="block text-sm font-medium text-foreground mb-2">
192:                   Seedling Stage Days
193:                 </label>
194:                 <input
195:                   type="number"
196:                   {...register("growthTimeline.seedling", {
197:                     valueAsNumber: true,
198:                   })}
199:                   placeholder="14"
200:                   className="w-full p-3 border border-border rounded-md focus:ring-2 focus:ring-garden-500"
201:                 />
202:                 <p className="text-xs text-muted-foreground mt-1">
203:                   Early growth period
204:                 </p>
205:               </div>
206:               <div>
207:                 <label className="block text-sm font-medium text-foreground mb-2">
208:                   Vegetative Growth Days
209:                 </label>
210:                 <input
211:                   type="number"
212:                   {...register("growthTimeline.vegetative", {
213:                     valueAsNumber: true,
214:                   })}
215:                   placeholder="30"
216:                   className="w-full p-3 border border-border rounded-md focus:ring-2 focus:ring-garden-500"
217:                 />
218:                 <p className="text-xs text-muted-foreground mt-1">
219:                   Leaf and stem development
220:                 </p>
221:               </div>
222:               <div>
223:                 <label className="block text-sm font-medium text-foreground mb-2">
224:                   Total Days to Maturity
225:                 </label>
226:                 <input
227:                   type="number"
228:                   {...register("growthTimeline.maturation", {
229:                     valueAsNumber: true,
230:                   })}
231:                   placeholder="120"
232:                   className="w-full p-3 border border-border rounded-md focus:ring-2 focus:ring-garden-500"
233:                 />
234:                 <p className="text-xs text-muted-foreground mt-1">
235:                   From seed to harvest
236:                 </p>
237:               </div>
238:             </div>
239:           </div>
240: 
241:           {}
242:           <div className="border-t pt-6">
243:             <div className="flex items-center justify-between mb-4">
244:               <div>
245:                 <h3 className="text-lg font-medium text-foreground">
246:                   Custom Moisture Protocol
247:                 </h3>
248:                 <p className="text-sm text-muted-foreground">
249:                   Set specific watering ranges, or use category defaults
250:                 </p>
251:               </div>
252:               <button
253:                 type="button"
254:                 onClick={() =>
255:                   setShowMoistureCustomization(!showMoistureCustomization)
256:                 }
257:                 className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${
258:                   showMoistureCustomization ? "bg-garden-600" : "bg-gray-300"
259:                 }`}
260:               >
261:                 <span
262:                   className={`inline-block h-4 w-4 transform rounded-full bg-card transition-transform ${
263:                     showMoistureCustomization
264:                       ? "translate-x-6"
265:                       : "translate-x-1"
266:                   }`}
267:                 />
268:               </button>
269:             </div>
270: 
271:             {showMoistureCustomization && (
272:               <div className="space-y-4 bg-blue-50 p-4 rounded-lg">
273:                 <input
274:                   type="hidden"
275:                   {...register("customMoistureRanges")}
276:                   checked={showMoistureCustomization}
277:                 />
278: 
279:                 <div className="text-sm text-blue-800 mb-3">
280:                   💡 <strong>Moisture Meter Guide:</strong> Most plants prefer
281:                   watering when moisture drops to 3-4, then watered until
282:                   reaching 6-8. Adjust based on your specific variety's needs.
283:                 </div>
284: 
285:                 <div className="grid grid-cols-2 gap-4">
286:                   <div>
287:                     <label className="block text-sm font-medium text-foreground mb-2">
288:                       Water When (Min Level)
289:                     </label>
290:                     <input
291:                       type="number"
292:                       min="1"
293:                       max="10"
294:                       step="0.5"
295:                       {...register("triggerMin", { valueAsNumber: true })}
296:                       className="w-full p-3 border border-border rounded-md focus:ring-2 focus:ring-garden-500"
297:                     />
298:                     <p className="text-xs text-muted-foreground mt-1">
299:                       Lowest moisture before watering
300:                     </p>
301:                   </div>
302:                   <div>
303:                     <label className="block text-sm font-medium text-foreground mb-2">
304:                       Water When (Max Level)
305:                     </label>
306:                     <input
307:                       type="number"
308:                       min="1"
309:                       max="10"
310:                       step="0.5"
311:                       {...register("triggerMax", { valueAsNumber: true })}
312:                       className="w-full p-3 border border-border rounded-md focus:ring-2 focus:ring-garden-500"
313:                     />
314:                     <p className="text-xs text-muted-foreground mt-1">
315:                       Highest moisture before watering
316:                     </p>
317:                   </div>
318:                   <div>
319:                     <label className="block text-sm font-medium text-foreground mb-2">
320:                       Target After (Min Level)
321:                     </label>
322:                     <input
323:                       type="number"
324:                       min="1"
325:                       max="10"
326:                       step="0.5"
327:                       {...register("targetMin", { valueAsNumber: true })}
328:                       className="w-full p-3 border border-border rounded-md focus:ring-2 focus:ring-garden-500"
329:                     />
330:                     <p className="text-xs text-muted-foreground mt-1">
331:                       Minimum moisture after watering
332:                     </p>
333:                   </div>
334:                   <div>
335:                     <label className="block text-sm font-medium text-foreground mb-2">
336:                       Target After (Max Level)
337:                     </label>
338:                     <input
339:                       type="number"
340:                       min="1"
341:                       max="10"
342:                       step="0.5"
343:                       {...register("targetMax", { valueAsNumber: true })}
344:                       className="w-full p-3 border border-border rounded-md focus:ring-2 focus:ring-garden-500"
345:                     />
346:                     <p className="text-xs text-muted-foreground mt-1">
347:                       Maximum moisture after watering
348:                     </p>
349:                   </div>
350:                 </div>
351:                 <p className="text-xs text-blue-700">
352:                   💡 These ranges will apply to all growth stages initially. You
353:                   can refine them later as you learn your plant's specific needs
354:                   through the care logging system.
355:                 </p>
356:               </div>
357:             )}
358:           </div>
359: 
360:           <div className="flex gap-4 pt-4">
361:             <Button
362:               type="submit"
363:               variant="primary"
364:               disabled={isLoading}
365:               className="flex-1"
366:             >
367:               {isLoading ? "Creating..." : "Create Variety"}
368:             </Button>
369:             {onCancel && (
370:               <Button type="button" variant="outline" onClick={onCancel}>
371:                 Cancel
372:               </Button>
373:             )}
374:           </div>
375:         </form>
376:       </CardContent>
377:     </Card>
378:   );
379: }

================
File: src/components/plant/NextTaskDisplay.tsx
================
 1: import React from "react";
 2: import { useNextPlantTask } from "@/hooks/useNextPlantTask";
 3: 
 4: interface NextTaskDisplayProps {
 5:   plantId: string;
 6:   className?: string;
 7:   onClick?: (taskType: string) => void;
 8: }
 9: 
10: const NextTaskDisplay: React.FC<NextTaskDisplayProps> = ({
11:   plantId,
12:   className = "",
13:   onClick,
14: }) => {
15:   const { nextTask, isLoading } = useNextPlantTask(plantId);
16: 
17:   if (isLoading) {
18:     return (
19:       <div className={`text-xs text-muted-foreground ${className}`}>
20:         Loading next task...
21:       </div>
22:     );
23:   }
24: 
25:   if (!nextTask) {
26:     return (
27:       <div className={`text-xs text-muted-foreground ${className}`}>
28:         📅 No tasks scheduled
29:       </div>
30:     );
31:   }
32: 
33:   // Map task descriptions to activity types for the form
34:   const getActivityType = (taskDescription: string): string => {
35:     const task = taskDescription.toLowerCase();
36:     if (task.includes("water") || task.includes("watering")) return "water";
37:     if (task.includes("fertiliz")) return "fertilize";
38:     if (task.includes("health check") || task.includes("observe"))
39:       return "observe";
40:     if (task.includes("harvest")) return "harvest";
41:     if (task.includes("transplant")) return "transplant";
42:     return "water";
43:   };
44: 
45: 
46:   const getTaskIcon = (task: string): string => {
47:     if (task.toLowerCase().includes("water")) return "💧";
48:     if (task.toLowerCase().includes("fertiliz")) return "🌱";
49:     if (
50:       task.toLowerCase().includes("observe") ||
51:       task.toLowerCase().includes("check")
52:     )
53:       return "👁️";
54:     if (task.toLowerCase().includes("harvest")) return "🌾";
55:     return "📋";
56:   };
57: 
58: 
59:   const getPriorityColor = (priority: "low" | "medium" | "high"): string => {
60:     switch (priority) {
61:       case "high":
62:         return "text-red-600";
63:       case "medium":
64:         return "text-orange-600";
65:       case "low":
66:         return "text-green-600";
67:       default:
68:         return "text-muted-foreground";
69:     }
70:   };
71: 
72:   const handleClick = () => {
73:     if (onClick) {
74:       const activityType = getActivityType(nextTask.task);
75:       onClick(activityType);
76:     }
77:   };
78: 
79:   return (
80:     <div
81:       className={`text-xs ${getPriorityColor(nextTask.priority)} ${className} ${
82:         onClick ? "cursor-pointer hover:underline hover:text-blue-600" : ""
83:       }`}
84:       onClick={handleClick}
85:     >
86:       <span className="mr-1">{getTaskIcon(nextTask.task)}</span>
87:       {nextTask.task} - {nextTask.dueIn}
88:       {onClick && (
89:         <span className="text-xs text-muted-foreground ml-2">
90:           → Click to log
91:         </span>
92:       )}
93:     </div>
94:   );
95: };
96: 
97: export default NextTaskDisplay;

================
File: src/components/plant/PlantReminderSettings.tsx
================
  1: import { useState } from "react";
  2: import { Button } from "@/components/ui/Button";
  3: import { plantService, PlantRecord } from "@/types/database";
  4: import ReminderPreferencesSection from "./ReminderPreferencesSection";
  5: import toast from "react-hot-toast";
  6: 
  7: interface PlantReminderSettingsProps {
  8:   plant: PlantRecord;
  9:   onUpdate: (updatedPlant: PlantRecord) => void;
 10: }
 11: 
 12: const PlantReminderSettings = ({
 13:   plant,
 14:   onUpdate,
 15: }: PlantReminderSettingsProps) => {
 16:   const [preferences, setPreferences] = useState(
 17:     plant.reminderPreferences || {
 18:       watering: true,
 19:       fertilizing: true,
 20:       observation: true,
 21:       lighting: true,
 22:       pruning: true,
 23:     }
 24:   );
 25:   const [isLoading, setIsLoading] = useState(false);
 26:   const [saveStatus, setSaveStatus] = useState<"idle" | "success" | "error">(
 27:     "idle"
 28:   );
 29: 
 30:   const handleSave = async () => {
 31:     try {
 32:       setIsLoading(true);
 33:       setSaveStatus("idle");
 34: 
 35:       await plantService.updatePlant(plant.id, {
 36:         reminderPreferences: preferences,
 37:         updatedAt: new Date(),
 38:       });
 39: 
 40:       const updatedPlant = {
 41:         ...plant,
 42:         reminderPreferences: preferences,
 43:       };
 44: 
 45:       onUpdate(updatedPlant);
 46:       setSaveStatus("success");
 47:       toast.success("Reminder preferences updated!");
 48: 
 49: 
 50:       setTimeout(() => setSaveStatus("idle"), 3000);
 51:     } catch (error) {
 52:       console.error("Failed to update reminder preferences:", error);
 53:       setSaveStatus("error");
 54:       toast.error("Failed to update preferences");
 55: 
 56: 
 57:       setTimeout(() => setSaveStatus("idle"), 5000);
 58:     } finally {
 59:       setIsLoading(false);
 60:     }
 61:   };
 62: 
 63: 
 64:   const hasChanges =
 65:     JSON.stringify(preferences) !==
 66:     JSON.stringify(
 67:       plant.reminderPreferences || {
 68:         watering: true,
 69:         fertilizing: true,
 70:         observation: true,
 71:         lighting: true,
 72:         pruning: true,
 73:       }
 74:     );
 75: 
 76:   const getButtonContent = () => {
 77:     if (isLoading) {
 78:       return (
 79:         <div className="flex items-center gap-2">
 80:           <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />
 81:           Saving...
 82:         </div>
 83:       );
 84:     }
 85: 
 86:     if (saveStatus === "success") {
 87:       return (
 88:         <div className="flex items-center gap-2">
 89:           <span className="text-green-600">✓</span>
 90:           Saved Successfully!
 91:         </div>
 92:       );
 93:     }
 94: 
 95:     if (saveStatus === "error") {
 96:       return (
 97:         <div className="flex items-center gap-2">
 98:           <span className="text-red-600">✗</span>
 99:           Save Failed - Retry
100:         </div>
101:       );
102:     }
103: 
104:     return hasChanges ? "Save Changes" : "No Changes";
105:   };
106: 
107:   const getButtonVariant = () => {
108:     if (saveStatus === "success") return "outline";
109:     if (saveStatus === "error") return "destructive";
110:     return hasChanges ? "primary" : "outline";
111:   };
112: 
113:   return (
114:     <div className="space-y-6">
115:       <ReminderPreferencesSection
116:         preferences={preferences}
117:         onChange={setPreferences}
118:       />
119: 
120:       {}
121:       {saveStatus !== "idle" && (
122:         <div
123:           className={`p-3 rounded-lg text-sm font-medium ${
124:             saveStatus === "success"
125:               ? "bg-green-50 text-green-800 border border-green-200"
126:               : "bg-red-50 text-red-800 border border-red-200"
127:           }`}
128:         >
129:           {saveStatus === "success" && (
130:             <div className="flex items-center gap-2">
131:               <span className="text-green-600">✓</span>
132:               Your reminder preferences have been updated successfully!
133:             </div>
134:           )}
135:           {saveStatus === "error" && (
136:             <div className="flex items-center gap-2">
137:               <span className="text-red-600">⚠️</span>
138:               Failed to save your preferences. Please try again.
139:             </div>
140:           )}
141:         </div>
142:       )}
143: 
144:       <div className="flex justify-end">
145:         <Button
146:           onClick={handleSave}
147:           disabled={isLoading || !hasChanges}
148:           variant={getButtonVariant()}
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158:         >
159:           {getButtonContent()}
160:         </Button>
161:       </div>
162: 
163:       {}
164:       {hasChanges && saveStatus === "idle" && (
165:         <div className="text-xs text-amber-600 bg-amber-50 border border-amber-200 rounded p-2 text-center">
166:           <span className="mr-1">⚠️</span>
167:           You have unsaved changes
168:         </div>
169:       )}
170:     </div>
171:   );
172: };
173: 
174: export default PlantReminderSettings;

================
File: src/components/plant/SoilMixtureSelector.tsx
================
  1: import { useState } from "react";
  2: import { Button } from "@/components/ui/Button";
  3: import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/Card";
  4: import { PlantCategory } from "@/types";
  5: 
  6: interface SoilComponent {
  7:   name: string;
  8:   percentage: number;
  9:   description?: string;
 10: }
 11: 
 12: interface SoilMixture {
 13:   id: string;
 14:   name: string;
 15:   description: string;
 16:   category?: PlantCategory;
 17:   components: SoilComponent[];
 18:   amendments?: { name: string; amount: string }[];
 19:   suitable: string[];
 20:   notes?: string[];
 21: }
 22: 
 23: interface SoilMixtureSelectorProps {
 24:   selectedMixture?: string;
 25:   onMixtureChange: (mixture: string) => void;
 26:   plantCategory?: PlantCategory;
 27: }
 28: 
 29: const PRESET_MIXTURES: SoilMixture[] = [
 30:   {
 31:     id: "leafy-greens-standard",
 32:     name: "Leafy Greens Mix",
 33:     description:
 34:       "Nutrient-rich blend perfect for arugula, spinach, and lettuce",
 35:     category: "leafy-greens",
 36:     components: [
 37:       { name: "Coco Coir", percentage: 40 },
 38:       { name: "Perlite", percentage: 25 },
 39:       { name: "Vermiculite", percentage: 25 },
 40:       { name: "Worm Castings", percentage: 10 },
 41:     ],
 42:     amendments: [{ name: "Compost", amount: "½–1 cup per cubic foot" }],
 43:     suitable: ["Arugula", "Spinach", "Lettuce", "Kale"],
 44:     notes: ["Retains moisture well", "High in organic matter"],
 45:   },
 46:   {
 47:     id: "root-vegetables-standard",
 48:     name: "Root Vegetables Mix",
 49:     description: "Well-draining mix for carrots, beets, and onions",
 50:     category: "root-vegetables",
 51:     components: [
 52:       { name: "Coco Coir", percentage: 40 },
 53:       { name: "Perlite", percentage: 30 },
 54:       { name: "Vermiculite", percentage: 25 },
 55:       { name: "Worm Castings", percentage: 5 },
 56:     ],
 57:     amendments: [
 58:       { name: "Compost", amount: "2 tbsp per gallon" },
 59:       { name: "Bone Meal", amount: "1 tsp per gallon" },
 60:     ],
 61:     suitable: ["Carrots", "Beets", "Onions", "Radishes"],
 62:     notes: ["Excellent drainage", "Prevents root rot"],
 63:   },
 64:   {
 65:     id: "herbs-standard",
 66:     name: "Mediterranean Herbs Mix",
 67:     description: "Well-draining, lean mix for oregano, thyme, and rosemary",
 68:     category: "herbs",
 69:     components: [
 70:       { name: "Coco Coir", percentage: 40 },
 71:       { name: "Perlite", percentage: 30 },
 72:       { name: "Coarse Sand", percentage: 20 },
 73:       { name: "Vermiculite", percentage: 10 },
 74:     ],
 75:     amendments: [
 76:       { name: "Compost", amount: "0.5 tbsp per container" },
 77:       { name: "Crushed Oyster Shell", amount: "0.5 tsp per container" },
 78:     ],
 79:     suitable: ["Oregano", "Thyme", "Rosemary", "Basil"],
 80:     notes: ["Lean conditions concentrate flavors", "Excellent drainage"],
 81:   },
 82:   {
 83:     id: "berries-standard",
 84:     name: "Berry & Fruit Mix",
 85:     description: "Acid-loving plants blend with excellent drainage",
 86:     category: "berries",
 87:     components: [
 88:       { name: "Coco Coir", percentage: 35 },
 89:       { name: "Perlite", percentage: 25 },
 90:       { name: "Compost", percentage: 20 },
 91:       { name: "Worm Castings", percentage: 15 },
 92:       { name: "Vermiculite", percentage: 5 },
 93:     ],
 94:     amendments: [
 95:       { name: "Bone Meal", amount: "1 tbsp per gallon" },
 96:       { name: "Rock Dust", amount: "¼ cup per 5-gal bag" },
 97:     ],
 98:     suitable: ["Strawberries", "Blueberries", "Raspberries"],
 99:     notes: ["Slightly acidic pH", "Rich in organic matter"],
100:   },
101:   {
102:     id: "fruiting-plants-standard",
103:     name: "Fruiting Plants Mix",
104:     description:
105:       "Nutrient-dense mix for tomatoes, peppers, and climbing plants",
106:     category: "fruiting-plants",
107:     components: [
108:       { name: "Coco Coir", percentage: 35 },
109:       { name: "Perlite", percentage: 20 },
110:       { name: "Vermiculite", percentage: 20 },
111:       { name: "Compost", percentage: 15 },
112:       { name: "Worm Castings", percentage: 5 },
113:       { name: "Biochar", percentage: 5 },
114:     ],
115:     amendments: [
116:       { name: "Gypsum", amount: "½ cup per 15-gal bag" },
117:       { name: "Bone Meal", amount: "2-3 tbsp per container" },
118:       { name: "Kelp Meal", amount: "2 tbsp per container" },
119:     ],
120:     suitable: ["Tomatoes", "Peppers", "Peas", "Beans"],
121:     notes: ["Heavy feeder support", "Calcium-rich for fruit development"],
122:   },
123:   {
124:     id: "universal-standard",
125:     name: "Universal Garden Mix",
126:     description: "Balanced all-purpose mix suitable for most plants",
127:     components: [
128:       { name: "Coco Coir", percentage: 40 },
129:       { name: "Perlite", percentage: 25 },
130:       { name: "Vermiculite", percentage: 20 },
131:       { name: "Compost", percentage: 10 },
132:       { name: "Worm Castings", percentage: 5 },
133:     ],
134:     amendments: [{ name: "Bone Meal", amount: "1 tbsp per gallon" }],
135:     suitable: ["Most vegetables", "Herbs", "Annual flowers"],
136:     notes: ["Good drainage", "Balanced nutrition", "Easy to work with"],
137:   },
138: ];
139: 
140: export const SoilMixtureSelector = ({
141:   selectedMixture,
142:   onMixtureChange,
143:   plantCategory,
144: }: SoilMixtureSelectorProps) => {
145:   const [showCustom, setShowCustom] = useState(false);
146:   const [customMixture, setCustomMixture] = useState("");
147: 
148:   // In SoilMixtureSelector.tsx - fix the getRelevantMixtures function
149:   const getRelevantMixtures = () => {
150:     if (!plantCategory) {
151:       // When no category is provided, return all mixtures without duplicates
152:       return PRESET_MIXTURES;
153:     }
154: 
155:     const categoryMixtures = PRESET_MIXTURES.filter(
156:       (mix) => mix.category === plantCategory
157:     );
158:     const otherMixtures = PRESET_MIXTURES.filter(
159:       (mix) => mix.category !== plantCategory
160:     );
161: 
162:     return [...categoryMixtures, ...otherMixtures];
163:   };
164: 
165:   const formatComponents = (components: SoilComponent[]) => {
166:     return components
167:       .map((comp) => `${comp.percentage}% ${comp.name}`)
168:       .join(", ");
169:   };
170: 
171:   const handlePresetSelect = (mixtureId: string) => {
172:     const mixture = PRESET_MIXTURES.find((m) => m.id === mixtureId);
173:     if (mixture) {
174:       const mixtureText = `${mixture.name}: ${formatComponents(
175:         mixture.components
176:       )}`;
177:       onMixtureChange(mixtureText);
178:       setShowCustom(false);
179:     }
180:   };
181: 
182:   const handleCustomSubmit = () => {
183:     if (customMixture.trim()) {
184:       onMixtureChange(customMixture);
185:       setShowCustom(false);
186:     }
187:   };
188: 
189:   return (
190:     <div className="space-y-4">
191:       <div>
192:         <label className="block text-sm font-medium text-foreground mb-2">
193:           Soil Mixture
194:         </label>
195:         <p className="text-xs text-muted-foreground mb-3">
196:           Choose a preset mixture or create your own custom blend
197:         </p>
198:       </div>
199: 
200:       {!showCustom ? (
201:         <>
202:           {}
203:           <div className="grid gap-3">
204:             {getRelevantMixtures().map((mixture) => (
205:               <div
206:                 key={mixture.id}
207:                 data-testid={`mixture-card-${mixture.id}`}
208:                 className={`cursor-pointer transition-all border rounded-lg shadow-sm ${
209:                   selectedMixture?.includes(mixture.name)
210:                     ? "ring-4 ring-green-500 bg-green-100 border-green-300 shadow-lg"
211:                     : "bg-card border-border hover:bg-background hover:shadow-md"
212:                 }`}
213:                 onClick={() => handlePresetSelect(mixture.id)}
214:               >
215:                 <div className="p-4">
216:                   <div className="flex items-start justify-between">
217:                     <div className="flex-1">
218:                       <div className="font-medium text-foreground mb-1 flex items-center">
219:                         {selectedMixture?.includes(mixture.name) && (
220:                           <span className="mr-2 text-green-600 text-lg">✓</span>
221:                         )}
222:                         {mixture.name}
223:                         {mixture.category === plantCategory && (
224:                           <span className="ml-2 text-xs bg-green-100 text-green-700 px-2 py-1 rounded-full">
225:                             Recommended
226:                           </span>
227:                         )}
228:                       </div>
229:                       <p className="text-sm text-muted-foreground mb-2">
230:                         {mixture.description}
231:                       </p>
232:                       <div className="text-xs text-muted-foreground space-y-1">
233:                         <div>
234:                           <strong>Components:</strong>{" "}
235:                           {formatComponents(mixture.components)}
236:                         </div>
237:                         {mixture.amendments && (
238:                           <div>
239:                             <strong>Amendments:</strong>{" "}
240:                             {mixture.amendments
241:                               .map((a) => `${a.name} (${a.amount})`)
242:                               .join(", ")}
243:                           </div>
244:                         )}
245:                         <div>
246:                           <strong>Best for:</strong>{" "}
247:                           {mixture.suitable.join(", ")}
248:                         </div>
249:                       </div>
250:                     </div>
251:                   </div>
252:                 </div>
253:               </div>
254:             ))}
255:           </div>
256: 
257:           {}
258:           <Button
259:             type="button"
260:             variant="primary"
261:             onClick={() => setShowCustom(true)}
262:             className="w-full"
263:           >
264:             🧪 Create Custom Mixture
265:           </Button>
266:         </>
267:       ) : (
268: 
269:         <Card>
270:           <CardHeader>
271:             <CardTitle className="text-lg">Custom Soil Mixture</CardTitle>
272:             <p className="text-sm text-muted-foreground">
273:               Describe your custom soil mixture with components and percentages
274:             </p>
275:           </CardHeader>
276:           <CardContent className="space-y-4">
277:             <div>
278:               <label
279:                 htmlFor="mixtureDescription"
280:                 className="block text-sm font-medium text-foreground mb-2"
281:               >
282:                 Mixture Description
283:               </label>
284:               <textarea
285:                 id="mixtureDescription"
286:                 value={customMixture}
287:                 onChange={(e) => setCustomMixture(e.target.value)}
288:                 placeholder="e.g., 40% coco coir, 30% perlite, 25% vermiculite, 5% compost"
289:                 className="w-full p-3 border border-border rounded-md w-full p-3 bg-card text-card-foreground border border-border rounded-md focus:ring-2 focus:ring-ring focus:border-ring placeholder:text-muted-foreground"
290:                 rows={3}
291:               />
292:             </div>
293:             <div className="flex gap-2">
294:               <Button
295:                 type="button"
296:                 onClick={handleCustomSubmit}
297:                 disabled={!customMixture.trim()}
298:                 className="flex-1"
299:               >
300:                 Use This Mixture
301:               </Button>
302:               <Button
303:                 type="button"
304:                 variant="outline"
305:                 onClick={() => setShowCustom(false)}
306:               >
307:                 Back to Presets
308:               </Button>
309:             </div>
310:           </CardContent>
311:         </Card>
312:       )}
313: 
314:       {}
315:       {selectedMixture && (
316:         <div className="p-3 bg-green-50 border border-green-200 rounded-md">
317:           <div className="text-sm font-medium text-green-800 mb-1">
318:             Selected Mixture:
319:           </div>
320:           <div className="text-sm text-green-700">{selectedMixture}</div>
321:         </div>
322:       )}
323:     </div>
324:   );
325: };
326: 
327: export default SoilMixtureSelector;

================
File: src/components/Navigation.tsx
================
 1: import React from "react";
 2: import { Link, useLocation } from "react-router-dom";
 3: import { cn } from "@/utils/cn";
 4: import { DarkModeToggle } from "@/components/ui/DarkModeToggle";
 5: 
 6: const Navigation: React.FC = () => {
 7:   const location = useLocation();
 8: 
 9:   const navItems = [
10:     { path: "/", label: "Dashboard", icon: "🏠" },
11:     { path: "/plants", label: "Plants", icon: "🌱" },
12:     { path: "/add-plant", label: "Add Plant", icon: "➕" },
13:   ];
14: 
15:   return (
16:     <nav className="fixed bottom-0 left-0 right-0 bg-card dark:bg-background border-t border-border z-50">
17:       <div className="flex justify-around items-center h-16 px-4">
18:         {navItems.map((item) => (
19:           <Link
20:             key={item.path}
21:             to={item.path}
22:             className={cn(
23:               "flex flex-col items-center justify-center min-w-touch h-full px-2",
24:               "text-xs font-medium transition-colors",
25:               location.pathname === item.path
26:                 ? "text-garden-600 dark:text-emerald-500 bg-garden-50 dark:bg-card"
27:                 : "text-muted-foreground dark:text-muted-foreground hover:text-garden-500 dark:hover:text-emerald-500"
28:             )}
29:           >
30:             <span className="text-xl mb-1">{item.icon}</span>
31:             <span className="text-xs">{item.label}</span>
32:           </Link>
33:         ))}
34: 
35:         {}
36:         <div className="flex flex-col items-center justify-center h-full px-2">
37:           <DarkModeToggle size="sm" />
38:           <span className="text-xs text-muted-foreground dark:text-muted-foreground mt-1">
39:             Theme
40:           </span>
41:         </div>
42:       </div>
43:     </nav>
44:   );
45: };
46: 
47: export default Navigation;

================
File: src/pages/care/LogCare.tsx
================
 1: import React from "react";
 2: import { CareLogForm } from "@/pages/care/CareLogForm";
 3: import { useNavigate, useSearchParams } from "react-router-dom";
 4: 
 5: const LogCare: React.FC = () => {
 6:   const navigate = useNavigate();
 7:   const [searchParams] = useSearchParams();
 8:   const preSelectedPlantId = searchParams.get("plantId");
 9: 
10:   const handleSuccess = () => {
11:     navigate("/");
12:   };
13: 
14:   const handleCancel = () => {
15:     navigate(-1);
16:   };
17: 
18:   return (
19:     <div className="p-4">
20:       <h1 className="text-2xl font-bold text-foreground mb-6 text-center">
21:         Log Care Activity
22:       </h1>
23:       <CareLogForm
24:         onSuccess={handleSuccess}
25:         onCancel={handleCancel}
26:         preselectedPlantId={preSelectedPlantId || undefined}
27:       />
28:     </div>
29:   );
30: };
31: 
32: export default LogCare;

================
File: src/pages/care/QuickCompletionButtons.tsx
================
 1: import { useState, useEffect } from "react";
 2: import { Button } from "@/components/ui/Button";
 3: import {
 4:   SmartDefaultsService,
 5:   QuickCompletionValues,
 6: } from "@/services/smartDefaultsService";
 7: import { PlantRecord } from "@/types/database";
 8: 
 9: interface QuickCompletionButtonsProps {
10:   plant: PlantRecord;
11:   activityType: "water" | "fertilize";
12:   onQuickComplete: (values: QuickCompletionValues) => void;
13:   className?: string;
14: }
15: 
16: const QuickCompletionButtons = ({
17:   plant,
18:   activityType,
19:   onQuickComplete,
20:   className = "",
21: }: QuickCompletionButtonsProps) => {
22:   const [options, setOptions] = useState<Array<{
23:     label: string;
24:     values: QuickCompletionValues;
25:   }> | null>(null);
26:   const [isLoading, setIsLoading] = useState(false);
27: 
28:   useEffect(() => {
29:     const loadOptions = async () => {
30:       try {
31:         setIsLoading(true);
32:         const completionOptions =
33:           await SmartDefaultsService.getQuickCompletionOptions(
34:             plant,
35:             activityType
36:           );
37:         setOptions(completionOptions);
38:       } catch (error) {
39:         console.error("Error loading quick completion options:", error);
40:         setOptions(null);
41:       } finally {
42:         setIsLoading(false);
43:       }
44:     };
45: 
46:     if (plant) {
47:       loadOptions();
48:     }
49:   }, [plant, activityType]);
50: 
51:   if (isLoading) {
52:     return (
53:       <div className={`flex gap-2 ${className}`}>
54:         <div className="animate-pulse bg-gray-200 rounded-full h-8 w-20"></div>
55:         <div className="animate-pulse bg-gray-200 rounded-full h-8 w-20"></div>
56:       </div>
57:     );
58:   }
59: 
60:   if (!options || options.length === 0) {
61:     return null;
62:   }
63: 
64:   return (
65:     <div className={`flex gap-2 flex-wrap ${className}`}>
66:       <span className="text-xs text-muted-foreground self-center">
67:         Quick actions:
68:       </span>
69:       {options.map((option, index) => (
70:         <Button
71:           key={index}
72:           type="button"
73:           variant="outline"
74:           size="sm"
75:           onClick={() => onQuickComplete(option.values)}
76:         >
77:           {option.label}
78:         </Button>
79:       ))}
80:     </div>
81:   );
82: };
83: 
84: export default QuickCompletionButtons;

================
File: src/pages/dashboard/TaskItem.tsx
================
  1: import React, { useState } from "react";
  2: import { useNavigate } from "react-router-dom";
  3: import { Button } from "@/components/ui/Button";
  4: import { StatusBadge } from "@/components/ui/StatusBadge";
  5: import {
  6:   UpcomingTask,
  7:   QuickCompleteOption,
  8:   QuickCompletionValues,
  9: } from "@/types/scheduling";
 10: 
 11: interface TaskItemProps {
 12:   task: UpcomingTask;
 13:   onQuickComplete?: (
 14:     taskId: string,
 15:     values: QuickCompletionValues
 16:   ) => Promise<void>;
 17:   onBypass?: (taskId: string, reason: string) => Promise<void>;
 18:   className?: string;
 19: }
 20: 
 21: const TaskItem: React.FC<TaskItemProps> = ({
 22:   task,
 23:   onQuickComplete,
 24:   onBypass,
 25:   className = "",
 26: }) => {
 27:   const navigate = useNavigate();
 28:   const [isLoading, setIsLoading] = useState(false);
 29:   const [showBypassDialog, setShowBypassDialog] = useState(false);
 30:   const [bypassReason, setBypassReason] = useState("");
 31: 
 32:   const handleTaskClick = () => {
 33:     navigate(`/plants/${task.plantId}`);
 34:   };
 35: 
 36:   const handleQuickComplete = async (option: QuickCompleteOption) => {
 37:     if (!onQuickComplete) return;
 38: 
 39:     setIsLoading(true);
 40:     try {
 41:       await onQuickComplete(task.id, option.values);
 42:     } catch (error) {
 43:       console.error("Failed to quick complete task:", error);
 44:     } finally {
 45:       setIsLoading(false);
 46:     }
 47:   };
 48: 
 49:   const handleBypass = async () => {
 50:     if (!onBypass || !bypassReason.trim()) return;
 51: 
 52:     setIsLoading(true);
 53:     try {
 54:       await onBypass(task.id, bypassReason);
 55:       setShowBypassDialog(false);
 56:       setBypassReason("");
 57:     } catch (error) {
 58:       console.error("Failed to bypass task:", error);
 59:     } finally {
 60:       setIsLoading(false);
 61:     }
 62:   };
 63: 
 64:   const getTaskIcon = (taskName: string) => {
 65:     const name = taskName.toLowerCase();
 66:     if (name.includes("water")) return "💧";
 67:     if (name.includes("fertiliz")) return "🌱";
 68:     if (name.includes("observe") || name.includes("health")) return "👁";
 69:     if (name.includes("prune") || name.includes("trim")) return "✂️";
 70:     return "📋";
 71:   };
 72: 
 73:   const getStatusFromPriority = (priority: "low" | "medium" | "high") => {
 74:     switch (priority) {
 75:       case "high":
 76:         return "critical";
 77:       case "medium":
 78:         return "attention";
 79:       case "low":
 80:         return "healthy";
 81:       default:
 82:         return "healthy";
 83:     }
 84:   };
 85: 
 86:   return (
 87:     <>
 88:       <div
 89:         className={`bg-card border border-border rounded-lg p-4 ${className}`}
 90:       >
 91:         {}
 92:         <div className="cursor-pointer" onClick={handleTaskClick}>
 93:           <div className="flex items-start justify-between mb-3">
 94:             <div className="flex-1">
 95:               <div className="flex items-center gap-2 mb-1">
 96:                 <span className="text-lg">{getTaskIcon(task.task)}</span>
 97:                 <span className="font-semibold text-foreground">
 98:                   {task.name}
 99:                 </span>
100:               </div>
101:               <div className="text-sm text-muted-foreground mb-2">
102:                 {task.task} • {task.dueIn}
103:               </div>
104:               <StatusBadge
105:                 status={getStatusFromPriority(task.priority)}
106:                 size="sm"
107:               />
108:             </div>
109:           </div>
110:         </div>
111: 
112:         {}
113:         <div className="flex gap-2 flex-wrap">
114:           {}
115:           {task.quickCompleteOptions?.map((option, ind) => (
116:             <Button
117:               key={ind}
118:               variant="outline"
119:               size="sm"
120:               onClick={() => handleQuickComplete(option)}
121:               disabled={isLoading}
122:               className="bg-green-50 border-green-200 text-green-700 hover:bg-green-100"
123:             >
124:               {option.label}
125:             </Button>
126:           ))}
127: 
128:           {}
129:           {task.canBypass && (
130:             <Button
131:               variant="outline"
132:               size="sm"
133:               onClick={() => setShowBypassDialog(true)}
134:               disabled={isLoading}
135:               className="bg-yellow-50 border-yellow-200 text-yellow-700 hover:bg-yellow-100"
136:             >
137:               Bypass
138:             </Button>
139:           )}
140: 
141:           {}
142:           <Button
143:             variant="outline"
144:             size="sm"
145:             onClick={() =>
146:               navigate(
147:                 `/care/log?plantId=${task.plantId}&activityType=${
148:                   task.task.toLowerCase().includes("water")
149:                     ? "water"
150:                     : "fertilize"
151:                 }`
152:               )
153:             }
154:             disabled={isLoading}
155:           >
156:             Log Manually
157:           </Button>
158:         </div>
159:       </div>
160: 
161:       {}
162:       {showBypassDialog && (
163:         <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
164:           <div className="bg-background rounded-lg p-6 w-full max-w-md">
165:             <h3 className="text-lg font-semibold mb-4">
166:               Bypass Task: {task.task}
167:             </h3>
168:             <p className="text-sm text-muted-foreground mb-4">
169:               Why are you skipping this task? This helps improve future
170:               recommendations.
171:             </p>
172: 
173:             <div className="space-y-3 mb-4">
174:               {[
175:                 "Plant looks healthy, doesn't need it yet",
176:                 "Soil still moist from recent rain/watering",
177:                 "Weather conditions not suitable",
178:                 "Plant dormant/not growing actively",
179:                 "Other reason",
180:               ].map((reason) => (
181:                 <label
182:                   key={reason}
183:                   className="flex items-center space-x-2 cursor-pointer"
184:                 >
185:                   <input
186:                     type="radio"
187:                     name="bypassReason"
188:                     value={reason}
189:                     checked={bypassReason === reason}
190:                     onChange={(e) => setBypassReason(e.target.value)}
191:                     className="text-primary"
192:                   />
193:                   <span className="text-sm">{reason}</span>
194:                 </label>
195:               ))}
196:             </div>
197: 
198:             {bypassReason === "Other reason" && (
199:               <textarea
200:                 placeholder="Please specify..."
201:                 value={bypassReason === "Other reason" ? "" : bypassReason}
202:                 onChange={(e) => setBypassReason(e.target.value)}
203:                 className="w-full p-3 border border-border rounded-md text-sm mb-4"
204:                 rows={3}
205:               />
206:             )}
207: 
208:             <div className="flex gap-2">
209:               <Button
210:                 variant="outline"
211:                 onClick={() => {
212:                   setShowBypassDialog(false);
213:                   setBypassReason("");
214:                 }}
215:                 className="flex-1"
216:               >
217:                 Cancel
218:               </Button>
219:               <Button
220:                 onClick={handleBypass}
221:                 disabled={!bypassReason.trim() || isLoading}
222:                 className="flex-1"
223:               >
224:                 {isLoading ? "Bypassing..." : "Bypass Task"}
225:               </Button>
226:             </div>
227:           </div>
228:         </div>
229:       )}
230:     </>
231:   );
232: };
233: 
234: export default TaskItem;

================
File: src/types/scheduling.ts
================
 1: export interface UpcomingTask {
 2:   id: string;
 3:   plantId: string;
 4:   name: string;
 5:   task: string;
 6:   dueIn: string;
 7:   plantStage: string;
 8:   dueDate: Date;
 9:   priority: "low" | "medium" | "high";
10:   quickCompleteOptions?: QuickCompleteOption[];
11:   canBypass: boolean;
12: }
13: 
14: export interface TaskBypassReason {
15:   id: string;
16:   taskId: string;
17:   plantId: string;
18:   reason: string;
19:   timestamp: Date;
20:   userId?: string;
21: }
22: 
23: export interface TaskGroup {
24:   type: "watering" | "fertilizing" | "observation" | "maintenance";
25:   title: string;
26:   emoji: string;
27:   tasks: UpcomingTask[];
28:   isExpanded: boolean;
29: }
30: 
31: export interface QuickCompleteOption {
32:   label: string;
33:   values: QuickCompletionValues;
34: }
35: 
36: export interface QuickCompletionValues {
37:   waterValue?: number;
38:   waterUnit?: string;
39:   product?: string;
40:   dilution?: string;
41:   amount?: string;
42: }
43: 
44: export interface TaskRecommendation {
45:   task: UpcomingTask;
46:   protocol: {
47:     expectedMoisture?: [number, number];
48:     lastReading?: number;
49:     daysSinceLastCare?: number;
50:   };
51: }

================
File: src/App.css
================
 1: #root {
 2:   max-width: 1280px;
 3:   margin: 0 auto;
 4:   padding: 2rem;
 5:   text-align: center;
 6:   @apply bg-background;
 7: }
 8: 
 9: .logo {
10:   height: 6em;
11:   padding: 1.5em;
12:   will-change: filter;
13:   transition: filter 300ms;
14: }
15: .logo:hover {
16:   filter: drop-shadow(0 0 2em #646cffaa);
17: }
18: .logo.react:hover {
19:   filter: drop-shadow(0 0 2em #61dafbaa);
20: }
21: 
22: @keyframes logo-spin {
23:   from {
24:     transform: rotate(0deg);
25:   }
26:   to {
27:     transform: rotate(360deg);
28:   }
29: }
30: 
31: @media (prefers-reduced-motion: no-preference) {
32:   a:nth-of-type(2) .logo {
33:     animation: logo-spin infinite 20s linear;
34:   }
35: }
36: 
37: .card {
38:   padding: 2em;
39: }
40: 
41: .read-the-docs {
42:   color: #888;
43: }

================
File: .gitignore
================
 1: # Logs
 2: logs
 3: *.log
 4: npm-debug.log*
 5: yarn-debug.log*
 6: yarn-error.log*
 7: pnpm-debug.log*
 8: lerna-debug.log*
 9: 
10: # Cache directories
11: .cache/
12: .parcel-cache/
13: 
14: node_modules
15: dist
16: dist-ssr
17: *.local
18: 
19: # Editor directories and files
20: .vscode/*
21: !.vscode/extensions.json
22: .idea
23: .DS_Store
24: *.suo
25: *.ntvs*
26: *.njsproj
27: *.sln
28: *.sw?
29: # Testing
30: coverage/.DS_Store
31: .DS_Store?
32: **/.DS_Store
33: # macOS
34: .DS_Store
35: .DS_Store?
36: ._*
37: .Spotlight-V100
38: .Trashes
39: ehthumbs.db
40: Thumbs.db
41: 
42: # IDE
43: .vscode/
44: .idea/
45: 
46: # Environment
47: .env.local
48: .env.development.local
49: .env.test.local
50: .env.production.local
51: 
52: # Temporary files
53: *.tmp
54: *.temp

================
File: package.json
================
 1: {
 2:   "name": "smartgarden-app",
 3:   "private": true,
 4:   "version": "0.0.0",
 5:   "type": "module",
 6:   "scripts": {
 7:     "dev": "vite",
 8:     "dev:watch": "concurrently \"npm run dev\" \"npm run test:watch\"",
 9:     "build": "tsc -b && vite build",
10:     "lint": "eslint .",
11:     "preview": "vite preview",
12:     "test": "jest",
13:     "test:watch": "jest --watchAll",
14:     "test:coverage": "jest --coverage",
15:     "test:ci": "jest --ci --coverage --watchAll=false --passWithNoTests",
16:     "test:e2e": "playwright test",
17:     "test:e2e:ui": "playwright test --ui",
18:     "test:lighthouse": "node scripts/lighthouse-ci.js",
19:     "test:all": "npm run test:ci && npm run test:e2e && npm run test:lighthouse"
20:   },
21:   "dependencies": {
22:     "@hookform/resolvers": "^5.1.1",
23:     "@radix-ui/react-dialog": "^1.1.14",
24:     "@radix-ui/react-slot": "^1.2.3",
25:     "@radix-ui/react-tabs": "^1.1.12",
26:     "@tanstack/react-query": "^5.80.7",
27:     "clsx": "^2.1.1",
28:     "date-fns": "^4.1.0",
29:     "dexie": "^4.0.11",
30:     "dexie-react-hooks": "^1.1.7",
31:     "react": "^19.1.0",
32:     "react-dom": "^19.1.0",
33:     "react-hook-form": "^7.57.0",
34:     "react-hot-toast": "^2.5.2",
35:     "react-router-dom": "^7.6.2",
36:     "tailwind-merge": "^3.3.1",
37:     "ts-node": "^10.9.2",
38:     "util": "^0.12.5",
39:     "uuid": "^11.1.0",
40:     "vite-plugin-pwa": "^1.0.0",
41:     "workbox-window": "^7.3.0",
42:     "zod": "^3.25.64"
43:   },
44:   "devDependencies": {
45:     "@eslint/js": "^9.25.0",
46:     "@playwright/test": "^1.53.0",
47:     "@testing-library/jest-dom": "^6.6.3",
48:     "@testing-library/react": "^16.3.0",
49:     "@testing-library/user-event": "^14.6.1",
50:     "@types/jest": "^29.5.14",
51:     "@types/react": "^19.1.2",
52:     "@types/react-dom": "^19.1.2",
53:     "@types/testing-library__jest-dom": "^5.14.9",
54:     "@types/uuid": "^10.0.0",
55:     "@vitejs/plugin-react": "^4.4.1",
56:     "autoprefixer": "^10.4.21",
57:     "concurrently": "^9.1.2",
58:     "eslint": "^9.25.0",
59:     "eslint-plugin-react-hooks": "^5.2.0",
60:     "eslint-plugin-react-refresh": "^0.4.19",
61:     "fake-indexeddb": "^6.0.1",
62:     "globals": "^16.0.0",
63:     "identity-obj-proxy": "^3.0.0",
64:     "jest": "^29.7.0",
65:     "jest-axe": "^10.0.0",
66:     "jest-environment-jsdom": "^29.7.0",
67:     "postcss": "^8.5.5",
68:     "tailwindcss": "^3.4.17",
69:     "ts-jest": "^29.4.0",
70:     "typescript": "~5.8.3",
71:     "typescript-eslint": "^8.30.1",
72:     "vite": "^6.3.5"
73:   }
74: }

================
File: tsconfig.json
================
 1: {
 2:   "compilerOptions": {
 3:     "target": "ES2020",
 4:     "useDefineForClassFields": true,
 5:     "lib": ["ES2020", "DOM", "DOM.Iterable"],
 6:     "module": "ESNext",
 7:     "skipLibCheck": true,
 8:     "moduleResolution": "bundler",
 9:     "allowImportingTsExtensions": true,
10:     "resolveJsonModule": true,
11:     "isolatedModules": true,
12:     "noEmit": true,
13:     "jsx": "react-jsx",
14:     "strict": true,
15:     "noUnusedLocals": true,
16:     "noUnusedParameters": true,
17:     "noFallthroughCasesInSwitch": true,
18:     "baseUrl": ".",
19:     "paths": {
20:       "@/*": ["./src/*"],
21:       "@/components/*": ["./src/components/*"],
22:       "@/pages/*": ["./src/pages/*"],
23:       "@/hooks/*": ["./src/hooks/*"],
24:       "@/services/*": ["./src/services/*"],
25:       "@/types/*": ["./src/types/*"],
26:       "@/utils/*": ["./src/utils/*"]
27:     },
28:     "types": ["node", "jest", "@testing-library/jest-dom"]
29:   },
30:   "include": ["src", "vite.config.ts"],
31:   "setupFilesAfterEnv": ["<rootDir>/support/setupTests.js"]
32: }

================
File: src/__tests__/components/Dashboard.test.tsx
================
  1: import { screen, waitFor } from "@testing-library/react";
  2: import userEvent from "@testing-library/user-event";
  3: import Dashboard from "../../pages/dashboard";
  4: import { plantService } from "../../types/database";
  5: import { CareSchedulingService } from "@/services/careSchedulingService";
  6: import { SmartDefaultsService } from "@/services/smartDefaultsService";
  7: import { TaskGroupingService } from "@/services/taskGroupingService";
  8: import { renderWithProviders, mockPlantData } from "../utils/testHelpers";
  9: 
 10: const mockNavigate = jest.fn();
 11: jest.mock("react-router-dom", () => ({
 12:   ...jest.requireActual("react-router-dom"),
 13:   useNavigate: () => mockNavigate,
 14: }));
 15: 
 16: jest.mock("@/services/smartDefaultsService", () => ({
 17:   SmartDefaultsService: {
 18:     getQuickCompletionOptions: jest.fn(),
 19:   },
 20: }));
 21: 
 22: jest.mock("@/services/taskGroupingService", () => ({
 23:   TaskGroupingService: {
 24:     groupTasksByActivity: jest.fn(),
 25:   },
 26: }));
 27: 
 28: jest.mock("../../types/database", () => ({
 29:   plantService: {
 30:     getActivePlants: jest.fn(),
 31:     addPlant: jest.fn(),
 32:     getPlant: jest.fn(),
 33:     updatePlant: jest.fn(),
 34:     deletePlant: jest.fn(),
 35:   },
 36: }));
 37: 
 38: jest.mock("@/services/careSchedulingService", () => ({
 39:   CareSchedulingService: {
 40:     getUpcomingTasks: jest.fn(),
 41:   },
 42: }));
 43: 
 44: const mockUseFirstTimeUser = jest.fn();
 45: jest.mock("../../hooks/useFirstTimeUser", () => ({
 46:   useFirstTimeUser: () => mockUseFirstTimeUser(),
 47: }));
 48: 
 49: const mockSmartDefaultsService = SmartDefaultsService as jest.Mocked<
 50:   typeof SmartDefaultsService
 51: >;
 52: const mockTaskGroupingService = TaskGroupingService as jest.Mocked<
 53:   typeof TaskGroupingService
 54: >;
 55: const mockPlantService = plantService as jest.Mocked<typeof plantService>;
 56: const mockCareSchedulingService = CareSchedulingService as jest.Mocked<
 57:   typeof CareSchedulingService
 58: >;
 59: 
 60: describe("Dashboard", () => {
 61:   beforeEach(() => {
 62:     jest.clearAllMocks();
 63: 
 64: 
 65:     mockUseFirstTimeUser.mockReturnValue({
 66:       isFirstTime: false,
 67:       isLoading: false,
 68:       markOnboardingComplete: jest.fn(),
 69:     });
 70: 
 71: 
 72:     mockSmartDefaultsService.getQuickCompletionOptions.mockResolvedValue([
 73:       {
 74:         label: "Quick: 28oz",
 75:         values: {
 76:           waterValue: 28,
 77:           waterUnit: "oz",
 78:         },
 79:       },
 80:     ]);
 81: 
 82:     mockTaskGroupingService.groupTasksByActivity.mockImplementation((tasks) => [
 83:       {
 84:         type: "watering",
 85:         title: "Watering",
 86:         emoji: "💧",
 87:         tasks: tasks.filter((task) =>
 88:           task.task.toLowerCase().includes("water")
 89:         ),
 90:         isExpanded: true,
 91:       },
 92:     ]);
 93: 
 94: 
 95:     mockPlantService.getActivePlants.mockResolvedValue([]);
 96:     mockCareSchedulingService.getUpcomingTasks.mockResolvedValue([]);
 97:   });
 98: 
 99:   describe("Loading States", () => {
100:     it("shows loading state initially", () => {
101:       mockPlantService.getActivePlants.mockImplementation(
102:         () => new Promise(() => {})
103:       );
104: 
105:       renderWithProviders(<Dashboard />);
106: 
107:       expect(screen.getByText("Loading your garden...")).toBeInTheDocument();
108:     });
109:   });
110: 
111:   describe("Empty States", () => {
112:     it("displays empty state when no plants exist", async () => {
113:       mockPlantService.getActivePlants.mockResolvedValue([]);
114:       mockCareSchedulingService.getUpcomingTasks.mockResolvedValue([]);
115: 
116:       renderWithProviders(<Dashboard />);
117: 
118:       await waitFor(() => {
119:         expect(screen.getByText("Welcome to SmartGarden!")).toBeInTheDocument();
120:         expect(
121:           screen.getByText("You don't have any plants yet. Let's get started!")
122:         ).toBeInTheDocument();
123:         expect(screen.getByText("Add Your First Plant")).toBeInTheDocument();
124:       });
125:     });
126: 
127:     it("shows welcome component for first-time users", async () => {
128: 
129:       mockUseFirstTimeUser.mockReturnValue({
130:         isFirstTime: true,
131:         isLoading: false,
132:         markOnboardingComplete: jest.fn(),
133:       });
134: 
135: 
136:       mockPlantService.getActivePlants.mockResolvedValue([]);
137:       mockCareSchedulingService.getUpcomingTasks.mockResolvedValue([]);
138: 
139:       renderWithProviders(<Dashboard />);
140: 
141:       await waitFor(() => {
142:         expect(screen.getByText(/Welcome to SmartGarden/)).toBeInTheDocument();
143:       });
144:     });
145:   });
146: 
147:   describe("Data Display", () => {
148:     it("displays plants and tasks when data exists", async () => {
149:       const testPlant = {
150:         ...mockPlantData[0],
151:         id: "test-plant-1",
152:         name: "My Arugula",
153:       };
154: 
155:       const testTask = {
156:         id: "task-1",
157:         plantId: "test-plant-1",
158:         name: "My Arugula",
159:         task: "Check water level",
160:         dueIn: "overdue by 1 day",
161:         priority: "high" as const,
162:         canBypass: true,
163:       };
164: 
165:       mockPlantService.getActivePlants.mockResolvedValue([testPlant]);
166:       mockCareSchedulingService.getUpcomingTasks.mockResolvedValue([testTask]);
167: 
168:       renderWithProviders(<Dashboard />);
169: 
170:       await waitFor(() => {
171:         expect(screen.getByText("Your Garden Dashboard")).toBeInTheDocument();
172:       });
173: 
174:       await waitFor(() => {
175:         expect(screen.getByText("My Arugula")).toBeInTheDocument();
176:         expect(screen.getByText(/Check water level/)).toBeInTheDocument();
177:         expect(screen.getByText("Watering")).toBeInTheDocument();
178:         expect(screen.getByText("1 task")).toBeInTheDocument();
179:       });
180:     });
181: 
182:     it("displays dashboard with no pending tasks", async () => {
183:       mockPlantService.getActivePlants.mockResolvedValue([mockPlantData[0]]);
184:       mockCareSchedulingService.getUpcomingTasks.mockResolvedValue([]);
185: 
186:       renderWithProviders(<Dashboard />);
187: 
188:       await waitFor(() => {
189:         expect(screen.getByText("Your Garden Dashboard")).toBeInTheDocument();
190:         expect(screen.getByText("1 active plant growing")).toBeInTheDocument();
191:         expect(screen.queryByText(/tasks pending/)).not.toBeInTheDocument();
192:       });
193:     });
194: 
195:     it("displays multiple plants and tasks correctly", async () => {
196:       const twoPlantsData = [
197:         { ...mockPlantData[0], id: "plant-1", name: "My Arugula" },
198:         {
199:           id: "plant-2",
200:           varietyId: "variety-2",
201:           varietyName: "Spinach",
202:           name: "Spinach Plant",
203:           plantedDate: new Date("2024-01-15"),
204:           currentStage: "seedling" as const,
205:           location: "Balcony",
206:           container: "6 inch pot",
207:           isActive: true,
208:           notes: [],
209:           createdAt: new Date(),
210:           updatedAt: new Date(),
211:         },
212:       ];
213: 
214:       const twoTasksData = [
215:         {
216:           id: "task-1",
217:           plantId: "plant-1",
218:           name: "My Arugula",
219:           task: "Check water level",
220:           dueIn: "overdue by 1 day",
221:           priority: "high" as const,
222:           canBypass: true,
223:         },
224:         {
225:           id: "task-2",
226:           plantId: "plant-2",
227:           name: "Spinach Plant",
228:           task: "Check water level",
229:           dueIn: "1 day",
230:           priority: "medium" as const,
231:           canBypass: true,
232:         },
233:       ];
234: 
235:       mockPlantService.getActivePlants.mockResolvedValue(twoPlantsData);
236:       mockCareSchedulingService.getUpcomingTasks.mockResolvedValue(
237:         twoTasksData
238:       );
239: 
240:       mockTaskGroupingService.groupTasksByActivity.mockImplementation(
241:         (tasks) => [
242:           {
243:             type: "watering" as const,
244:             title: "Watering",
245:             emoji: "💧",
246:             tasks: tasks,
247:             isExpanded: true,
248:           },
249:         ]
250:       );
251: 
252:       renderWithProviders(<Dashboard />);
253: 
254:       await waitFor(() => {
255:         expect(screen.getByText("Your Garden Dashboard")).toBeInTheDocument();
256:       });
257: 
258:       await waitFor(() => {
259:         expect(screen.getByText("My Arugula")).toBeInTheDocument();
260:         expect(screen.getByText("Spinach Plant")).toBeInTheDocument();
261:       });
262: 
263:       await waitFor(() => {
264:         const description = screen.getByTestId("active-plants-count");
265:         expect(description.textContent).toContain("2 active plants growing");
266:         expect(description.textContent).toContain("2 tasks pending");
267:       });
268:     });
269:   });
270: 
271:   describe("User Interactions", () => {
272:     it("navigates to log care when quick action is clicked", async () => {
273:       mockPlantService.getActivePlants.mockResolvedValue([mockPlantData[0]]);
274:       mockCareSchedulingService.getUpcomingTasks.mockResolvedValue([]);
275: 
276:       renderWithProviders(<Dashboard />);
277: 
278:       await waitFor(() => {
279:         expect(screen.getByText("Log Care")).toBeInTheDocument();
280:       });
281: 
282:       const logCareButton = screen.getByText("Log Care");
283:       await userEvent.click(logCareButton);
284: 
285:       expect(mockNavigate).toHaveBeenCalledWith("/log-care");
286:     });
287: 
288:     it("renders contextual quick actions for urgent tasks", async () => {
289:       const urgentTask = {
290:         id: "task-1",
291:         plantId: "test-plant-1",
292:         name: "My Arugula",
293:         task: "Check water level",
294:         dueIn: "overdue by 1 day",
295:         priority: "high" as const,
296:         canBypass: true,
297:       };
298: 
299:       const testPlant = {
300:         ...mockPlantData[0],
301:         id: "test-plant-1",
302:         name: "My Arugula",
303:       };
304: 
305:       mockPlantService.getActivePlants.mockResolvedValue([testPlant]);
306:       mockCareSchedulingService.getUpcomingTasks.mockResolvedValue([
307:         urgentTask,
308:       ]);
309: 
310:       renderWithProviders(<Dashboard />);
311: 
312:       await waitFor(() => {
313:         expect(screen.getByText("Your Garden Dashboard")).toBeInTheDocument();
314:       });
315: 
316:       await waitFor(() => {
317:         expect(screen.getByText("Quick Actions")).toBeInTheDocument();
318:       });
319:     });
320:   });
321: 
322:   describe("Error Handling", () => {
323:     it("displays error state when service fails", async () => {
324:       mockPlantService.getActivePlants.mockRejectedValue(
325:         new Error("Database error")
326:       );
327: 
328:       renderWithProviders(<Dashboard />);
329: 
330:       await waitFor(() => {
331:         expect(
332:           screen.getByText("Failed to load dashboard data")
333:         ).toBeInTheDocument();
334:         expect(screen.getByText("Try Again")).toBeInTheDocument();
335:       });
336:     });
337: 
338:     it("retries when error state try again button is clicked", async () => {
339:       mockPlantService.getActivePlants
340:         .mockRejectedValueOnce(new Error("Database error"))
341:         .mockResolvedValueOnce([mockPlantData[0]]);
342:       mockCareSchedulingService.getUpcomingTasks.mockResolvedValue([]);
343: 
344:       renderWithProviders(<Dashboard />);
345: 
346:       await waitFor(() => {
347:         expect(
348:           screen.getByText("Failed to load dashboard data")
349:         ).toBeInTheDocument();
350:       });
351: 
352:       const tryAgainButton = screen.getByText("Try Again");
353:       await userEvent.click(tryAgainButton);
354: 
355:       await waitFor(() => {
356:         expect(screen.getByText("Your Garden Dashboard")).toBeInTheDocument();
357:       });
358:     });
359: 
360:     it("handles errors gracefully when task enhancement fails", async () => {
361:       const testPlant = {
362:         ...mockPlantData[0],
363:         id: "test-plant-1",
364:         name: "My Arugula",
365:       };
366: 
367:       const testTask = {
368:         id: "task-1",
369:         plantId: "test-plant-1",
370:         name: "My Arugula",
371:         task: "Check water level",
372:         dueIn: "overdue by 1 day",
373:         priority: "high" as const,
374:         canBypass: true,
375:       };
376: 
377:       mockPlantService.getActivePlants.mockResolvedValue([testPlant]);
378:       mockCareSchedulingService.getUpcomingTasks.mockResolvedValue([testTask]);
379: 
380: 
381:       mockSmartDefaultsService.getQuickCompletionOptions.mockRejectedValue(
382:         new Error("Smart defaults error")
383:       );
384: 
385:       renderWithProviders(<Dashboard />);
386: 
387: 
388:       await waitFor(() => {
389:         expect(screen.getByText("Your Garden Dashboard")).toBeInTheDocument();
390:       });
391:     });
392:   });
393: });

================
File: src/components/plant/CareHistory.tsx
================
  1: import React, { useState } from "react";
  2: import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/Card";
  3: import { Button } from "@/components/ui/Button";
  4: import { CareRecord } from "@/types/database";
  5: import CareActivityItem from "./CareActivityItem";
  6: 
  7: interface CareHistoryProps {
  8:   careHistory: CareRecord[];
  9: }
 10: 
 11: const CareHistory: React.FC<CareHistoryProps> = ({ careHistory }) => {
 12:   const [showAll, setShowAll] = useState(false);
 13:   const [filter, setFilter] = useState<string>("all");
 14: 
 15: 
 16:   const filteredHistory = careHistory.filter((activity) => {
 17:     if (filter === "all") return true;
 18:     return activity.type === filter;
 19:   });
 20: 
 21: 
 22:   const displayedHistory = showAll
 23:     ? filteredHistory
 24:     : filteredHistory.slice(0, 5);
 25: 
 26:   const activityTypeFilters = [
 27:     { value: "all", label: "All Activities", icon: "📋" },
 28:     { value: "water", label: "Watering", icon: "💧" },
 29:     { value: "fertilize", label: "Fertilizing", icon: "🌱" },
 30:     { value: "observe", label: "Observations", icon: "👁️" },
 31:     { value: "harvest", label: "Harvest", icon: "🌾" },
 32:     { value: "transplant", label: "Transplant", icon: "🏺" },
 33:   ];
 34: 
 35:   return (
 36:     <Card>
 37:       <CardHeader>
 38:         <CardTitle className="flex items-center gap-2">
 39:           <span className="text-2xl">📊</span>
 40:           Care History
 41:           <span className="text-sm font-normal text-muted-foreground">
 42:             ({careHistory.length} activities)
 43:           </span>
 44:         </CardTitle>
 45:       </CardHeader>
 46:       <CardContent>
 47:         {careHistory.length === 0 ? (
 48:           <div className="text-center py-8">
 49:             <div className="text-4xl mb-2">📝</div>
 50:             <h3 className="text-lg font-medium text-foreground mb-2">
 51:               No care activities yet
 52:             </h3>
 53:             <p className="text-muted-foreground mb-4">
 54:               Start logging care activities to track your plant's progress
 55:             </p>
 56:             <Button variant="primary">Log First Activity</Button>
 57:           </div>
 58:         ) : (
 59:           <div className="space-y-4">
 60:             {}
 61:             <div className="flex gap-1 overflow-x-auto pb-2">
 62:               {activityTypeFilters.map((filterOption) => (
 63:                 <Button
 64:                   key={filterOption.value}
 65:                   variant={
 66:                     filter === filterOption.value ? "primary" : "outline"
 67:                   }
 68:                   size="sm"
 69:                   onClick={() => setFilter(filterOption.value)}
 70:                   className="whitespace-nowrap"
 71:                 >
 72:                   <span className="mr-1">{filterOption.icon}</span>
 73:                   {filterOption.label}
 74:                 </Button>
 75:               ))}
 76:             </div>
 77: 
 78:             {}
 79:             <div className="space-y-3">
 80:               {displayedHistory.map((activity) => (
 81:                 <CareActivityItem key={activity.id} activity={activity} />
 82:               ))}
 83:             </div>
 84: 
 85:             {}
 86:             {filteredHistory.length > 5 && (
 87:               <div className="text-center pt-4">
 88:                 <Button variant="outline" onClick={() => setShowAll(!showAll)}>
 89:                   {showAll
 90:                     ? "Show Less"
 91:                     : `Show All ${filteredHistory.length} Activities`}
 92:                 </Button>
 93:               </div>
 94:             )}
 95:           </div>
 96:         )}
 97:       </CardContent>
 98:     </Card>
 99:   );
100: };
101: 
102: export default CareHistory;

================
File: src/components/plant/PlantRegistrationForm.tsx
================
  1: import { useState, useEffect } from "react";
  2: import { Controller, useForm } from "react-hook-form";
  3: import { zodResolver } from "@hookform/resolvers/zod";
  4: import { z } from "zod";
  5: import { Button } from "../ui/Button";
  6: import { Card, CardContent, CardHeader, CardTitle } from "../ui/Card";
  7: import { plantService, varietyService, VarietyRecord } from "@/types/database";
  8: import { CustomVarietyForm } from "./CustomVarietyForm";
  9: import toast from "react-hot-toast";
 10: import SoilMixtureSelector from "./SoilMixtureSelector";
 11: import { Switch } from "@/components/ui/Switch";
 12: import ReminderPreferencesSection from "@/components/plant/ReminderPreferencesSection";
 13: import { cn } from "@/utils/cn";
 14: 
 15: const plantSchema = z.object({
 16:   varietyId: z.string().min(1, "Please select a variety"),
 17:   name: z.string().optional(),
 18:   plantedDate: z.string().min(1, "Please select a planting date"),
 19:   location: z.boolean(),
 20:   containerType: z.string().min(1, "Please select a container type"),
 21:   containerSize: z.string().min(1, "Please specify container size"),
 22:   customBagShape: z.string().optional(),
 23:   customDiameter: z.string().optional(),
 24:   customBagHeight: z.string().optional(),
 25:   customBagWidth: z.string().optional(),
 26:   customBagLength: z.string().optional(),
 27:   customWidth: z.string().optional(),
 28:   customLength: z.string().optional(),
 29:   customDepth: z.string().optional(),
 30:   soilMix: z.string().min(1, "Please select a soil mixture"),
 31:   notes: z.string().optional(),
 32: });
 33: 
 34: type PlantFormData = z.infer<typeof plantSchema>;
 35: 
 36: interface PlantRegistrationFormProps {
 37:   onSuccess?: () => void;
 38:   onCancel?: () => void;
 39: }
 40: 
 41: interface FormErrors {
 42:   [key: string]: { message?: string } | undefined;
 43: }
 44: 
 45: 
 46: const containerOptions = {
 47:   "grow-bag": {
 48:     label: "Grow Bag",
 49:     icon: "🎒",
 50:     sizes: [
 51:       { value: "1-gallon", label: "1 Gallon" },
 52:       { value: "2-gallon", label: "2 Gallon" },
 53:       { value: "3-gallon", label: "3 Gallon" },
 54:       { value: "5-gallon", label: "5 Gallon" },
 55:       { value: "7-gallon", label: "7 Gallon" },
 56:       { value: "10-gallon", label: "10 Gallon" },
 57:       { value: "15-gallon", label: "15 Gallon" },
 58:       { value: "30-gallon", label: "30 Gallon" },
 59:       { value: "custom", label: "Custom Size" },
 60:     ],
 61:   },
 62:   pot: {
 63:     label: "Pot",
 64:     icon: "🪴",
 65:     sizes: [
 66:       { value: "4-inch", label: "4 inch" },
 67:       { value: "5-inch", label: "5 inch" },
 68:       { value: "6-inch", label: "6 inch" },
 69:     ],
 70:   },
 71:   "cell-tray": {
 72:     label: "Seed Starting Cell Tray",
 73:     icon: "📱",
 74:     sizes: [{ value: "standard", label: "Standard Cell Tray" }],
 75:   },
 76:   "raised-bed": {
 77:     label: "Raised Bed",
 78:     icon: "🏗️",
 79:     sizes: [{ value: "custom-dimensions", label: "Custom Dimensions" }],
 80:   },
 81: };
 82: 
 83: export function PlantRegistrationForm({
 84:   onSuccess,
 85:   onCancel,
 86: }: PlantRegistrationFormProps) {
 87:   const [varieties, setVarieties] = useState<VarietyRecord[]>([]);
 88:   const [isLoading, setIsLoading] = useState(false);
 89:   const [submitError, setSubmitError] = useState<string | null>(null);
 90:   const [showCustomVarietyForm, setShowCustomVarietyForm] = useState(false);
 91:   const [reminderPreferences, setReminderPreferences] = useState({
 92:     watering: true,
 93:     fertilizing: true,
 94:     observation: true,
 95:     lighting: true,
 96:     pruning: true,
 97:   });
 98: 
 99:   const {
100:     register,
101:     handleSubmit,
102:     formState: { errors, isValid, isSubmitting },
103:     reset,
104:     setValue,
105:     watch,
106:     control,
107:   } = useForm<PlantFormData>({
108:     resolver: zodResolver(plantSchema),
109:     mode: "onChange",
110:     defaultValues: {
111:       name: "",
112:       plantedDate: new Date().toISOString().split("T")[0],
113:       containerType: "",
114:       containerSize: "",
115:       soilMix: "",
116:       notes: "",
117:       location: false,
118:     },
119:   });
120: 
121:   const selectedContainerType = watch("containerType");
122:   const selectedContainerSize = watch("containerSize");
123: 
124:   useEffect(() => {
125:     loadVarieties();
126:   }, []);
127: 
128:   useEffect(() => {
129:     if (selectedContainerType) {
130:       setValue("containerSize", "");
131:       setValue("customBagShape", "");
132:       setValue("customDiameter", "");
133:       setValue("customBagHeight", "");
134:       setValue("customBagWidth", "");
135:       setValue("customBagLength", "");
136:       setValue("customWidth", "");
137:       setValue("customLength", "");
138:       setValue("customDepth", "");
139:     }
140:   }, [selectedContainerType, setValue]);
141: 
142:   async function loadVarieties() {
143:     try {
144:       const allVarieties = await varietyService.getAllVarieties();
145:       const sortedVarieties = allVarieties.sort((a, b) => {
146:         if (a.isCustom !== b.isCustom) {
147:           return a.isCustom ? 1 : -1;
148:         }
149:         return a.name.localeCompare(b.name);
150:       });
151:       setVarieties(sortedVarieties);
152:     } catch (error) {
153:       console.error("Failed to load varieties:", error);
154:       setSubmitError(
155:         "Failed to load plant varieties. Please refresh the page."
156:       );
157:     }
158:   }
159: 
160:   async function onSubmit(data: PlantFormData) {
161:     setIsLoading(true);
162:     setSubmitError(null);
163: 
164:     try {
165:       const selectedVariety = varieties.find((v) => v.id === data.varietyId);
166:       const varietyName = selectedVariety?.name || "Unknown Variety";
167: 
168:       const locationString = data.location ? "Outdoor" : "Indoor";
169: 
170: 
171:       let containerDescription = "";
172:       const containerConfig =
173:         containerOptions[data.containerType as keyof typeof containerOptions];
174: 
175:       if (data.containerSize === "custom") {
176: 
177:         if (data.customBagShape === "circular") {
178:           containerDescription = `${containerConfig.label} - ${data.customDiameter}"⌀ x ${data.customBagHeight}"H (Circular)`;
179:         } else if (data.customBagShape === "rectangular") {
180:           containerDescription = `${containerConfig.label} - ${data.customBagWidth}"W x ${data.customBagLength}"L x ${data.customBagHeight}"H (Rectangular)`;
181:         }
182:       } else if (data.containerSize === "custom-dimensions") {
183: 
184:         containerDescription = `${containerConfig.label} - ${data.customWidth}"W x ${data.customLength}"L x ${data.customDepth}"D`;
185:       } else {
186: 
187:         const sizeConfig = containerConfig.sizes.find(
188:           (size) => size.value === data.containerSize
189:         );
190:         containerDescription = `${containerConfig.label} - ${sizeConfig?.label}`;
191:       }
192: 
193:       await plantService.addPlant({
194:         varietyId: data.varietyId,
195:         varietyName,
196:         name: data.name?.trim() || undefined,
197:         plantedDate: new Date(data.plantedDate),
198:         currentStage: "germination",
199:         location: locationString,
200:         container: containerDescription,
201:         soilMix: data.soilMix || undefined,
202:         isActive: true,
203:         notes: data.notes ? [data.notes] : [],
204:         reminderPreferences,
205:       });
206: 
207:       toast.success(`${data.name || varietyName} registered successfully! 🌱`);
208: 
209:       reset();
210:       onSuccess?.();
211:     } catch (error) {
212:       console.error("Failed to register plant:", error);
213:       setSubmitError("Failed to register plant. Please try again.");
214:       toast.error("Failed to register plant. Please try again.");
215:     } finally {
216:       setIsLoading(false);
217:     }
218:   }
219: 
220:   function renderFormField(
221:     id: keyof PlantFormData,
222:     label: string,
223:     type: "text" | "date" | "select" | "textarea" = "text",
224:     placeholder?: string,
225:     required: boolean = false
226:   ) {
227:     const error = (errors as FormErrors)[id];
228: 
229:     return (
230:       <div>
231:         <label
232:           htmlFor={id}
233:           className="block text-sm font-medium text-foreground mb-2"
234:         >
235:           {label} {required && "*"}
236:         </label>
237: 
238:         {type === "select" && id === "varietyId" ? (
239:           <div className="space-y-2">
240:             <select
241:               id={id}
242:               {...register(id)}
243:               className="w-full p-3 bg-card text-card-foreground border border-border rounded-md focus:ring-2 focus:ring-ring focus:border-ring"
244:             >
245:               <option value="">Select a variety...</option>
246: 
247:               {varieties.filter((v) => !v.isCustom).length > 0 && (
248:                 <optgroup label="Built-in Varieties">
249:                   {varieties
250:                     .filter((variety) => !variety.isCustom)
251:                     .map((variety) => (
252:                       <option key={variety.id} value={variety.id}>
253:                         {variety.name} ({variety.category})
254:                       </option>
255:                     ))}
256:                 </optgroup>
257:               )}
258: 
259:               {varieties.filter((v) => v.isCustom).length > 0 && (
260:                 <optgroup label="Your Custom Varieties">
261:                   {varieties
262:                     .filter((variety) => variety.isCustom)
263:                     .map((variety) => (
264:                       <option key={variety.id} value={variety.id}>
265:                         🌱 {variety.name} ({variety.category})
266:                       </option>
267:                     ))}
268:                 </optgroup>
269:               )}
270:             </select>
271: 
272:             <Button
273:               type="button"
274:               variant="primary"
275:               onClick={() => setShowCustomVarietyForm(true)}
276:               className="w-full"
277:             >
278:               ➕ Create Custom Variety
279:             </Button>
280:           </div>
281:         ) : type === "textarea" ? (
282:           <textarea
283:             id={id}
284:             {...register(id)}
285:             placeholder={placeholder}
286:             rows={3}
287:             className="w-full p-3 bg-card text-card-foreground border border-border rounded-md focus:ring-2 focus:ring-ring focus:border-ring"
288:           />
289:         ) : (
290:           <input
291:             id={id}
292:             type={type}
293:             {...register(id)}
294:             placeholder={placeholder}
295:             className="w-full p-3 bg-card text-card-foreground border border-border rounded-md focus:ring-2 focus:ring-ring focus:border-ring"
296:           />
297:         )}
298: 
299:         {error?.message && (
300:           <p className="mt-1 text-sm text-red-600">{error.message}</p>
301:         )}
302:       </div>
303:     );
304:   }
305: 
306:   function renderContainerFields() {
307:     const selectedBagShape = watch("customBagShape");
308: 
309:     return (
310:       <div className="space-y-4">
311:         {}
312:         <div>
313:           <label className="block text-sm font-medium text-foreground mb-3">
314:             Container Type *
315:           </label>
316:           <div className="grid grid-cols-2 gap-3">
317:             {Object.entries(containerOptions).map(([key, option]) => (
318:               <label
319:                 key={key}
320:                 className={`relative flex items-center p-4 border-2 rounded-lg cursor-pointer transition-all active:scale-95 ${
321:                   selectedContainerType === key
322:                     ? "border-emerald-500 bg-emerald-50"
323:                     : "border-border active:border-gray-400"
324:                 }`}
325:               >
326:                 <input
327:                   type="radio"
328:                   value={key}
329:                   {...register("containerType")}
330:                   className="sr-only"
331:                 />
332:                 <span className="text-2xl mr-3">{option.icon}</span>
333:                 <span className="font-medium text-card-foreground text-sm">
334:                   {option.label}
335:                 </span>
336:                 {selectedContainerType === key && (
337:                   <span className="absolute top-2 right-2 text-emerald-500">
338:                     ✓
339:                   </span>
340:                 )}
341:               </label>
342:             ))}
343:           </div>
344:           {errors.containerType && (
345:             <p className="mt-1 text-sm text-red-600">
346:               {errors.containerType.message}
347:             </p>
348:           )}
349:         </div>
350: 
351:         {}
352:         {selectedContainerType && (
353:           <div>
354:             <label className="block text-sm font-medium text-foreground mb-3">
355:               {
356:                 containerOptions[
357:                   selectedContainerType as keyof typeof containerOptions
358:                 ].label
359:               }{" "}
360:               Size *
361:             </label>
362:             <div className="grid grid-cols-2 gap-3">
363:               {containerOptions[
364:                 selectedContainerType as keyof typeof containerOptions
365:               ].sizes.map((size) => (
366:                 <label
367:                   key={size.value}
368:                   className={`relative flex items-center p-3 border-2 rounded-lg cursor-pointer transition-all active:scale-95 ${
369:                     selectedContainerSize === size.value
370:                       ? "border-emerald-500 bg-emerald-50"
371:                       : "border-border active:border-gray-400"
372:                   }`}
373:                 >
374:                   <input
375:                     type="radio"
376:                     value={size.value}
377:                     {...register("containerSize")}
378:                     className="sr-only"
379:                   />
380:                   <span className="font-medium text-card-foreground text-sm">
381:                     {size.label}
382:                   </span>
383:                   {selectedContainerSize === size.value && (
384:                     <span className="absolute top-2 right-2 text-emerald-500">
385:                       ✓
386:                     </span>
387:                   )}
388:                 </label>
389:               ))}
390:             </div>
391:             {errors.containerSize && (
392:               <p className="mt-1 text-sm text-red-600">
393:                 {errors.containerSize.message}
394:               </p>
395:             )}
396:           </div>
397:         )}
398: 
399:         {}
400:         {selectedContainerType === "grow-bag" &&
401:           selectedContainerSize === "custom" && (
402:             <div className="p-4 bg-blue-50 border border-blue-200 rounded-md space-y-4">
403:               <div>
404:                 <label className="block text-sm font-medium text-foreground mb-3">
405:                   Grow Bag Shape *
406:                 </label>
407:                 <div className="grid grid-cols-2 gap-3">
408:                   <label
409:                     className={`relative flex flex-col items-center p-3 border-2 rounded-lg cursor-pointer transition-all active:scale-95 ${
410:                       selectedBagShape === "circular"
411:                         ? "border-blue-500 bg-blue-100"
412:                         : "border-border active:border-gray-400"
413:                     }`}
414:                   >
415:                     <input
416:                       type="radio"
417:                       value="circular"
418:                       {...register("customBagShape")}
419:                       className="sr-only"
420:                     />
421:                     <span className="text-3xl mb-1">⭕</span>
422:                     <span className="font-medium text-card-foreground text-sm">
423:                       Circle
424:                     </span>
425:                     {selectedBagShape === "circular" && (
426:                       <span className="absolute top-2 right-2 text-blue-500">
427:                         ✓
428:                       </span>
429:                     )}
430:                   </label>
431: 
432:                   <label
433:                     className={`relative flex flex-col items-center p-3 border-2 rounded-lg cursor-pointer transition-all active:scale-95 ${
434:                       selectedBagShape === "rectangular"
435:                         ? "border-blue-500 bg-blue-100"
436:                         : "border-border active:border-gray-400"
437:                     }`}
438:                   >
439:                     <input
440:                       type="radio"
441:                       value="rectangular"
442:                       {...register("customBagShape")}
443:                       className="sr-only"
444:                     />
445:                     <span className="text-3xl mb-1">⬜</span>
446:                     <span className="font-medium text-card-foreground text-sm">
447:                       Rectangle
448:                     </span>
449:                     {selectedBagShape === "rectangular" && (
450:                       <span className="absolute top-2 right-2 text-blue-500">
451:                         ✓
452:                       </span>
453:                     )}
454:                   </label>
455:                 </div>
456:                 {errors.customBagShape && (
457:                   <p className="mt-1 text-sm text-red-600">
458:                     {errors.customBagShape.message}
459:                   </p>
460:                 )}
461:               </div>
462: 
463:               {}
464:               {selectedBagShape === "circular" && (
465:                 <div>
466:                   <label className="block text-sm font-medium text-foreground mb-3">
467:                     Circular Grow Bag Dimensions (inches) *
468:                   </label>
469:                   <div className="grid grid-cols-2 gap-3">
470:                     <div>
471:                       <label
472:                         htmlFor="customDiameter"
473:                         className="block text-xs font-medium text-muted-foreground mb-1"
474:                       >
475:                         Diameter
476:                       </label>
477:                       <input
478:                         id="customDiameter"
479:                         type="number"
480:                         step="0.5"
481:                         min="1"
482:                         {...register("customDiameter")}
483:                         placeholder="24"
484:                         className="w-full p-3 border border-border rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent text-center"
485:                       />
486:                       {errors.customDiameter && (
487:                         <p className="mt-1 text-xs text-red-600">
488:                           {errors.customDiameter.message}
489:                         </p>
490:                       )}
491:                     </div>
492: 
493:                     <div>
494:                       <label
495:                         htmlFor="customBagHeight"
496:                         className="block text-xs font-medium text-muted-foreground mb-1"
497:                       >
498:                         Height
499:                       </label>
500:                       <input
501:                         id="customBagHeight"
502:                         type="number"
503:                         step="0.5"
504:                         min="1"
505:                         {...register("customBagHeight")}
506:                         placeholder="18"
507:                         className="w-full p-3 border border-border rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent text-center"
508:                       />
509:                       {errors.customBagHeight && (
510:                         <p className="mt-1 text-xs text-red-600">
511:                           {errors.customBagHeight.message}
512:                         </p>
513:                       )}
514:                     </div>
515:                   </div>
516:                   <p className="mt-2 text-xs text-muted-foreground">
517:                     Example: 24" diameter × 18" height
518:                   </p>
519:                 </div>
520:               )}
521: 
522:               {}
523:               {selectedBagShape === "rectangular" && (
524:                 <div>
525:                   <label className="block text-sm font-medium text-foreground mb-3">
526:                     Rectangular Grow Bag Dimensions (inches) *
527:                   </label>
528:                   <div className="grid grid-cols-3 gap-3">
529:                     <div>
530:                       <label
531:                         htmlFor="customBagWidth"
532:                         className="block text-xs font-medium text-muted-foreground mb-1"
533:                       >
534:                         Width
535:                       </label>
536:                       <input
537:                         id="customBagWidth"
538:                         type="number"
539:                         step="0.5"
540:                         min="1"
541:                         {...register("customBagWidth")}
542:                         placeholder="24"
543:                         className="w-full p-3 border border-border rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent text-center"
544:                       />
545:                       {errors.customBagWidth && (
546:                         <p className="mt-1 text-xs text-red-600">
547:                           {errors.customBagWidth.message}
548:                         </p>
549:                       )}
550:                     </div>
551: 
552:                     <div>
553:                       <label
554:                         htmlFor="customBagLength"
555:                         className="block text-xs font-medium text-muted-foreground mb-1"
556:                       >
557:                         Length
558:                       </label>
559:                       <input
560:                         id="customBagLength"
561:                         type="number"
562:                         step="0.5"
563:                         min="1"
564:                         {...register("customBagLength")}
565:                         placeholder="48"
566:                         className="w-full p-3 border border-border rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent text-center"
567:                       />
568:                       {errors.customBagLength && (
569:                         <p className="mt-1 text-xs text-red-600">
570:                           {errors.customBagLength.message}
571:                         </p>
572:                       )}
573:                     </div>
574: 
575:                     <div>
576:                       <label
577:                         htmlFor="customBagHeight"
578:                         className="block text-xs font-medium text-muted-foreground mb-1"
579:                       >
580:                         Height
581:                       </label>
582:                       <input
583:                         id="customBagHeight"
584:                         type="number"
585:                         step="0.5"
586:                         min="1"
587:                         {...register("customBagHeight")}
588:                         placeholder="18"
589:                         className="w-full p-3 border border-border rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent text-center"
590:                       />
591:                       {errors.customBagHeight && (
592:                         <p className="mt-1 text-xs text-red-600">
593:                           {errors.customBagHeight.message}
594:                         </p>
595:                       )}
596:                     </div>
597:                   </div>
598:                   <p className="mt-2 text-xs text-muted-foreground">
599:                     Example: 24" wide × 48" long × 18" height
600:                   </p>
601:                 </div>
602:               )}
603:             </div>
604:           )}
605: 
606:         {}
607:         {selectedContainerType === "raised-bed" &&
608:           selectedContainerSize === "custom-dimensions" && (
609:             <div className="p-4 bg-green-50 border border-green-200 rounded-md">
610:               <label className="block text-sm font-medium text-foreground mb-3">
611:                 Raised Bed Dimensions (inches) *
612:               </label>
613:               <div className="grid grid-cols-3 gap-3">
614:                 <div>
615:                   <label
616:                     htmlFor="customWidth"
617:                     className="block text-xs font-medium text-muted-foreground mb-1"
618:                   >
619:                     Width
620:                   </label>
621:                   <input
622:                     id="customWidth"
623:                     type="number"
624:                     step="0.5"
625:                     min="1"
626:                     {...register("customWidth")}
627:                     placeholder="48"
628:                     className="w-full p-3 bg-card text-card-foreground border border-border rounded-md focus:ring-2 focus:ring-ring focus:border-ring placeholder:text-muted-foreground"
629:                   />
630:                   {errors.customWidth && (
631:                     <p className="mt-1 text-xs text-red-600">
632:                       {errors.customWidth.message}
633:                     </p>
634:                   )}
635:                 </div>
636: 
637:                 <div>
638:                   <label
639:                     htmlFor="customLength"
640:                     className="block text-xs font-medium text-muted-foreground mb-1"
641:                   >
642:                     Length
643:                   </label>
644:                   <input
645:                     id="customLength"
646:                     type="number"
647:                     step="0.5"
648:                     min="1"
649:                     {...register("customLength")}
650:                     placeholder="96"
651:                     className="w-full p-3 bg-card text-card-foreground border border-border rounded-md focus:ring-2 focus:ring-ring focus:border-ring placeholder:text-muted-foreground"
652:                   />
653:                   {errors.customLength && (
654:                     <p className="mt-1 text-xs text-red-600">
655:                       {errors.customLength.message}
656:                     </p>
657:                   )}
658:                 </div>
659: 
660:                 <div>
661:                   <label
662:                     htmlFor="customDepth"
663:                     className="block text-xs font-medium text-muted-foreground mb-1"
664:                   >
665:                     Soil Depth
666:                   </label>
667:                   <input
668:                     id="customDepth"
669:                     type="number"
670:                     step="0.5"
671:                     min="1"
672:                     {...register("customDepth")}
673:                     placeholder="12"
674:                     className="w-full p-3 bg-card text-card-foreground border border-border rounded-md focus:ring-2 focus:ring-ring focus:border-ring placeholder:text-muted-foreground"
675:                   />
676:                   {errors.customDepth && (
677:                     <p className="mt-1 text-xs text-red-600">
678:                       {errors.customDepth.message}
679:                     </p>
680:                   )}
681:                 </div>
682:               </div>
683:               <p className="mt-2 text-xs text-muted-foreground">
684:                 Example: 48" wide × 96" long × 12" deep
685:               </p>
686:             </div>
687:           )}
688:       </div>
689:     );
690:   }
691: 
692:   return (
693:     <>
694:       <Card className="max-w-2xl mx-auto">
695:         <CardHeader>
696:           <CardTitle>Register New Plant</CardTitle>
697:         </CardHeader>
698:         <CardContent>
699:           <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
700:             {submitError && (
701:               <div className="p-4 bg-red-50 border border-red-200 rounded-md">
702:                 <p className="text-sm text-red-600">{submitError}</p>
703:               </div>
704:             )}
705:             {renderFormField(
706:               "varietyId",
707:               "Plant Variety",
708:               "select",
709:               undefined,
710:               true
711:             )}
712:             {renderFormField(
713:               "name",
714:               "Plant Name (Optional)",
715:               "text",
716:               "e.g., Tomato #1, Kitchen Basil"
717:             )}
718:             {renderFormField(
719:               "plantedDate",
720:               "Planting Date",
721:               "date",
722:               undefined,
723:               true
724:             )}
725:             <div>
726:               <label
727:                 id="location-label"
728:                 className="block text-sm font-medium text-foreground mb-3"
729:               >
730:                 Location *
731:               </label>
732:               <Switch
733:                 id="location"
734:                 checked={watch("location") || false}
735:                 onCheckedChange={(checked) => setValue("location", checked)}
736:                 leftLabel="Indoor"
737:                 rightLabel="Outdoor"
738:                 leftIcon={<span className="text-lg">🏠</span>}
739:                 rightIcon={<span className="text-lg">🌞</span>}
740:                 size="lg"
741:                 className="justify-center"
742:                 aria-labelledby="location-label"
743:               />
744:               {errors.location && (
745:                 <p className="mt-2 text-sm text-red-600">
746:                   Please select a location
747:                 </p>
748:               )}
749:             </div>
750: 
751:             {}
752:             {renderContainerFields()}
753:             <div>
754:               <label className="block text-sm font-medium text-foreground mb-2">
755:                 Soil Mix *
756:               </label>
757: 
758:               <Controller
759:                 name="soilMix"
760:                 control={control}
761:                 render={({ field }) => (
762:                   <SoilMixtureSelector
763:                     selectedMixture={field.value}
764:                     onMixtureChange={field.onChange}
765:                     plantCategory={
766:                       varieties.find((v) => v.id === watch("varietyId"))
767:                         ?.category
768:                     }
769:                   />
770:                 )}
771:               />
772:               {errors.soilMix?.message && (
773:                 <p className="mt-1 text-sm text-red-600">
774:                   {errors.soilMix.message}
775:                 </p>
776:               )}
777:             </div>
778: 
779:             <ReminderPreferencesSection
780:               preferences={reminderPreferences}
781:               onChange={setReminderPreferences}
782:             />
783:             {}
784:             <div>
785:               <label
786:                 htmlFor="notes"
787:                 className="block text-sm font-medium text-foreground mb-2"
788:               >
789:                 Notes (Optional)
790:               </label>
791:               <textarea
792:                 id="notes"
793:                 {...register("notes")}
794:                 placeholder="Any additional notes about this plant..."
795:                 rows={3}
796:                 className="w-full p-3 bg-card text-card-foreground border border-border rounded-md focus:ring-2 focus:ring-ring focus:border-ring"
797:               />
798:               {errors.notes?.message && (
799:                 <p className="mt-1 text-sm text-red-600">
800:                   {errors.notes.message}
801:                 </p>
802:               )}
803:             </div>
804:             <div className="flex gap-4 pt-4">
805:               <Button
806:                 type="submit"
807:                 variant={isValid && !isSubmitting ? "primary" : "outline"}
808:                 disabled={isLoading || !isValid}
809:                 className={cn(
810:                   "flex-1 transition-all duration-300",
811:                   isValid && !isSubmitting && !isLoading
812:                     ? "shadow-lg shadow-emerald-500/25 hover:shadow-xl hover:shadow-emerald-500/30 transform hover:scale-[1.02]"
813:                     : "opacity-60 cursor-not-allowed shadow-sm"
814:                 )}
815:               >
816:                 {isLoading ? (
817:                   <div className="flex items-center gap-2">
818:                     <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />
819:                     Registering...
820:                   </div>
821:                 ) : (
822:                   <div className="flex items-center gap-2">
823:                     {isValid ? (
824:                       <>
825:                         <span className="text-lg">🌱</span>
826:                         Register Plant
827:                       </>
828:                     ) : (
829:                       <>
830:                         <span className="text-muted-foreground">📝</span>
831:                         Complete Required Fields
832:                       </>
833:                     )}
834:                   </div>
835:                 )}
836:               </Button>
837: 
838:               {onCancel && (
839:                 <Button
840:                   type="button"
841:                   variant="outline"
842:                   onClick={onCancel}
843:                   disabled={isLoading}
844:                   className="flex-1"
845:                 >
846:                   Cancel
847:                 </Button>
848:               )}
849:             </div>
850:           </form>
851:         </CardContent>
852:       </Card>
853: 
854:       {}
855:       {showCustomVarietyForm && (
856:         <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
857:           <div className="bg-card rounded-lg max-w-2xl w-full max-h-96 overflow-y-auto">
858:             <CustomVarietyForm
859:               onSuccess={async (varietyId) => {
860:                 setShowCustomVarietyForm(false);
861: 
862:                 await loadVarieties();
863:                 setValue("varietyId", varietyId);
864:               }}
865:               onCancel={() => setShowCustomVarietyForm(false)}
866:             />
867:           </div>
868:         </div>
869:       )}
870:     </>
871:   );
872: }

================
File: src/types/database.ts
================
  1: import Dexie, { Table } from "dexie";
  2: import { v4 as uuidv4 } from "uuid";
  3: import {
  4:   GrowthStage,
  5:   PlantCategory,
  6:   CareActivityType,
  7:   QualityRating,
  8:   HealthAssessment,
  9:   ApplicationMethod,
 10:   WateringMethod,
 11:   BaseRecord,
 12:   TimestampedRecord,
 13:   MoistureReading,
 14:   Volume,
 15:   GrowthTimeline,
 16: } from "./core";
 17: 
 18: 
 19: export interface StageSpecificWateringProtocol {
 20:   [stageName: string]: {
 21:     trigger: {
 22:       moistureLevel: string | number;
 23:       description?: string;
 24:     };
 25:     target: {
 26:       moistureLevel: string | number;
 27:       description?: string;
 28:     };
 29:     volume: {
 30:       amount: string;
 31:       frequency: string;
 32:       perPlant?: boolean;
 33:     };
 34:     notes?: string[];
 35:   };
 36: }
 37: 
 38: export interface StageSpecificLightingProtocol {
 39:   [stageName: string]: {
 40:     ppfd: {
 41:       min: number;
 42:       max: number;
 43:       optimal?: number;
 44:       unit: "µmol/m²/s";
 45:     };
 46:     photoperiod: {
 47:       hours: number;
 48:       maxHours?: number;
 49:       minHours?: number;
 50:       constraint?: string;
 51:     };
 52:     dli: {
 53:       min: number;
 54:       max: number;
 55:       unit: "mol/m²/day";
 56:     };
 57:     notes?: string[];
 58:   };
 59: }
 60: 
 61: export interface StageSpecificFertilizationProtocol {
 62:   [stageName: string]: {
 63:     products?: {
 64:       name: string;
 65:       dilution: string;
 66:       amount: string;
 67:       frequency: string;
 68:       method?: "soil-drench" | "foliar-spray" | "top-dress" | "mix-in-soil";
 69:     }[];
 70:     timing?: string;
 71:     specialInstructions?: string[];
 72:     notes?: string[];
 73:   };
 74: }
 75: 
 76: export interface EnvironmentalProtocol {
 77:   temperature?: {
 78:     min?: number;
 79:     max?: number;
 80:     optimal?: number;
 81:     unit: "F" | "C";
 82:     criticalMax?: number;
 83:     criticalMin?: number;
 84:     stage?: string;
 85:   };
 86:   humidity?: {
 87:     min?: number;
 88:     max?: number;
 89:     optimal?: number;
 90:     criticalForStage?: string;
 91:   };
 92:   pH: {
 93:     min: number;
 94:     max: number;
 95:     optimal: number;
 96:   };
 97:   specialConditions?: string[];
 98:   constraints?: {
 99:     description: string;
100:     parameter: "temperature" | "humidity" | "light" | "other";
101:     threshold: number;
102:     consequence: string;
103:   }[];
104: }
105: 
106: export interface SoilMixture {
107:   components: {
108:     [component: string]: number;
109:   };
110:   amendments?: {
111:     [amendment: string]: string;
112:   };
113: }
114: 
115: export interface ContainerRequirements {
116:   minSize?: string;
117:   depth: string;
118:   drainage?: string;
119:   staging?: {
120:     seedling?: string;
121:     intermediate?: string;
122:     final: string;
123:   };
124: }
125: 
126: export interface SuccessionProtocol {
127:   interval: number;
128:   method: "continuous" | "zoned" | "single";
129:   harvestMethod: "cut-and-come-again" | "single-harvest" | "selective";
130:   productiveWeeks?: number;
131:   notes?: string[];
132: }
133: 
134: 
135: export interface PlantProtocols {
136:   lighting?: StageSpecificLightingProtocol;
137:   watering?: StageSpecificWateringProtocol;
138:   fertilization?: StageSpecificFertilizationProtocol;
139:   environment?: EnvironmentalProtocol;
140:   soilMixture?: SoilMixture;
141:   container?: ContainerRequirements;
142:   succession?: SuccessionProtocol;
143:   specialRequirements?: string[];
144: }
145: 
146: 
147: export interface WateringProtocol {
148:   frequency: string;
149:   moistureTrigger: {
150:     triggerLevel: number;
151:     targetLevel: number;
152:     scale: "1-10" | "visual";
153:   };
154:   amount: Volume;
155:   method?: WateringMethod;
156:   notes: string[];
157: }
158: 
159: export interface LightingProtocol {
160:   ppfd: {
161:     min: number;
162:     max: number;
163:     optimal?: number;
164:   };
165:   photoperiod: {
166:     hours: number;
167:     maxHours?: number;
168:     minHours?: number;
169:   };
170:   dli: {
171:     min: number;
172:     max: number;
173:   };
174: }
175: 
176: export interface FertilizationProtocol {
177:   timing: {
178:     description: string;
179:     daysFromStart?: number;
180:     frequency?: string;
181:   };
182:   fertilizer: {
183:     product: string;
184:     type?: string;
185:     npkRatio?: string;
186:   };
187:   application: {
188:     dilution: string;
189:     amount: string;
190:     method: ApplicationMethod;
191:   };
192: }
193: export interface WaterAmount {
194:   value: number;
195:   unit: "oz" | "ml" | "cups" | "gallons" | "liters";
196: }
197: 
198: 
199: export interface WateringDetails {
200:   type: "water";
201:   amount: WaterAmount;
202:   moistureReading?: MoistureReading;
203:   method?: WateringMethod;
204:   runoffObserved?: boolean;
205:   notes?: string;
206: }
207: 
208: export interface FertilizingDetails {
209:   type: "fertilize";
210:   product: string;
211:   dilution: string;
212:   amount: string;
213:   method?: ApplicationMethod;
214:   notes?: string;
215: }
216: 
217: export interface ObservationDetails {
218:   type: "observe";
219:   healthAssessment: HealthAssessment;
220:   observations: string;
221:   photos?: string[];
222:   notes?: string;
223: }
224: 
225: export interface HarvestDetails {
226:   type: "harvest";
227:   amount: string;
228:   quality: QualityRating;
229:   method?: string;
230:   notes?: string;
231: }
232: 
233: export interface TransplantDetails {
234:   type: "transplant";
235:   fromContainer: string;
236:   toContainer: string;
237:   reason: string;
238:   notes?: string;
239: }
240: 
241: export type CareActivityDetails =
242:   | WateringDetails
243:   | FertilizingDetails
244:   | ObservationDetails
245:   | HarvestDetails
246:   | TransplantDetails;
247: 
248: 
249: export interface PlantRecord extends BaseRecord {
250:   varietyId: string;
251:   varietyName: string;
252:   name?: string;
253:   plantedDate: Date;
254:   currentStage: GrowthStage;
255:   location: string;
256:   container: string;
257:   soilMix?: string;
258:   isActive: boolean;
259:   notes?: string[];
260:   reminderPreferences?: {
261:     watering: boolean;
262:     fertilizing: boolean;
263:     observation: boolean;
264:     lighting: boolean;
265:     pruning: boolean;
266:   };
267: }
268: 
269: 
270: export interface VarietyRecord extends TimestampedRecord {
271:   name: string;
272:   category: PlantCategory;
273:   growthTimeline: GrowthTimeline;
274:   protocols?: PlantProtocols;
275:   moistureProtocols?: {
276:     [key in GrowthStage]?: {
277:       trigger: {
278:         min: number;
279:         max: number;
280:       };
281:       target: {
282:         min: number;
283:         max: number;
284:       };
285:     };
286:   };
287:   isCustom?: boolean;
288:   isEverbearing?: boolean;
289:   productiveLifespan?: number;
290: }
291: 
292: export interface CareRecord extends TimestampedRecord {
293:   plantId: string;
294:   type: CareActivityType;
295:   date: Date;
296:   details: CareActivityDetails;
297: }
298: 
299: export interface SyncQueueRecord {
300:   id: string;
301:   table: "plants" | "varieties" | "careActivities";
302:   operation: "create" | "update" | "delete";
303:   recordId: string;
304:   data?: string;
305:   timestamp: Date;
306:   synced: boolean;
307:   retryCount?: number;
308: }
309: 
310: class SmartGardenDatabase extends Dexie {
311:   plants!: Table<PlantRecord>;
312:   varieties!: Table<VarietyRecord>;
313:   careActivities!: Table<CareRecord>;
314:   syncQueue!: Table<SyncQueueRecord>;
315: 
316:   constructor() {
317:     super("SmartGardenDB");
318: 
319:     this.version(1).stores({
320:       plants: "id, varietyId, plantedDate, currentStage, isActive, location",
321:       varieties: "id, name, category",
322:       careActivities: "id, plantId, type, date",
323:       syncQueue: "id, table, timestamp, synced",
324:     });
325:   }
326: 
327:   async addToSyncQueue(
328:     table: SyncQueueRecord["table"],
329:     operation: SyncQueueRecord["operation"],
330:     recordId: string,
331:     data?: unknown
332:   ): Promise<void> {
333:     try {
334:       await this.syncQueue.add({
335:         id: uuidv4(),
336:         table,
337:         operation,
338:         recordId,
339:         data: data ? JSON.stringify(data) : undefined,
340:         timestamp: new Date(),
341:         synced: false,
342:       });
343:     } catch (error) {
344:       console.warn("Failed to add to sync queue:", error);
345:     }
346:   }
347: }
348: 
349: export const db = new SmartGardenDatabase();
350: 
351: 
352: export const plantService = {
353:   async addPlant(
354:     plant: Omit<PlantRecord, "id" | "createdAt" | "updatedAt">
355:   ): Promise<string> {
356:     const id = uuidv4();
357:     const now = new Date();
358:     const fullPlant: PlantRecord = {
359:       ...plant,
360:       id,
361:       createdAt: now,
362:       updatedAt: now,
363:     };
364: 
365:     await db.plants.add(fullPlant);
366:     await db.addToSyncQueue("plants", "create", id, fullPlant);
367:     return id;
368:   },
369: 
370:   async getActivePlants(): Promise<PlantRecord[]> {
371: 
372:     const allPlants = await db.plants.toArray();
373:     return allPlants.filter((plant) => plant.isActive === true);
374:   },
375: 
376:   async getPlant(id: string): Promise<PlantRecord | undefined> {
377:     return db.plants.get(id);
378:   },
379: 
380:   async updatePlant(
381:     id: string,
382:     updates: Partial<Omit<PlantRecord, "id" | "createdAt">>
383:   ): Promise<void> {
384:     const updateData = {
385:       ...updates,
386:       updatedAt: new Date(),
387:     };
388: 
389:     await db.plants.update(id, updateData);
390:     await db.addToSyncQueue("plants", "update", id, updateData);
391:   },
392: 
393:   async deletePlant(id: string): Promise<void> {
394:     const updateData = { isActive: false, updatedAt: new Date() };
395:     await db.plants.update(id, updateData);
396:     await db.addToSyncQueue("plants", "delete", id, updateData);
397:   },
398: };
399: 
400: export const varietyService = {
401:   async addVariety(
402:     variety: Omit<VarietyRecord, "id" | "createdAt">
403:   ): Promise<string> {
404:     const existingVariety = await db.varieties
405:       .where("name")
406:       .equals(variety.name)
407:       .first();
408: 
409:     if (existingVariety) {
410:       console.warn(
411:         `Variety "${variety.name}" already exists. Returning existing ID.`
412:       );
413:       return existingVariety.id;
414:     }
415: 
416:     const id = uuidv4();
417:     const fullVariety: VarietyRecord = {
418:       ...variety,
419:       id,
420:       createdAt: new Date(),
421:     };
422: 
423:     await db.varieties.add(fullVariety);
424:     await db.addToSyncQueue("varieties", "create", id, fullVariety);
425:     return id;
426:   },
427: 
428:   async getAllVarieties(): Promise<VarietyRecord[]> {
429:     return db.varieties.toArray();
430:   },
431: 
432:   async getVariety(id: string): Promise<VarietyRecord | undefined> {
433:     return db.varieties.get(id);
434:   },
435: 
436:   async getVarietyByName(name: string): Promise<VarietyRecord | undefined> {
437:     return db.varieties.where("name").equals(name).first();
438:   },
439: };
440: 
441: export const careService = {
442:   async addCareActivity(
443:     activity: Omit<CareRecord, "id" | "createdAt">
444:   ): Promise<string> {
445:     const id = uuidv4();
446:     const fullActivity: CareRecord = {
447:       ...activity,
448:       id,
449:       createdAt: new Date(),
450:     };
451: 
452:     await db.careActivities.add(fullActivity);
453:     await db.addToSyncQueue("careActivities", "create", id, fullActivity);
454:     return id;
455:   },
456: 
457:   async getLastCareActivityByType(
458:     plantId: string,
459:     type: CareActivityType
460:   ): Promise<CareRecord | null> {
461:     const activities = await db.careActivities
462:       .where("plantId")
463:       .equals(plantId)
464:       .and((activity) => activity.type === type)
465:       .reverse()
466:       .sortBy("date");
467: 
468:     return activities.length > 0 ? activities[0] : null;
469:   },
470: 
471:   async getPlantCareHistory(plantId: string): Promise<CareRecord[]> {
472:     return db.careActivities
473:       .where("plantId")
474:       .equals(plantId)
475:       .reverse()
476:       .sortBy("date");
477:   },
478: 
479:   async getRecentActivities(limit: number = 10): Promise<CareRecord[]> {
480:     return db.careActivities.orderBy("date").reverse().limit(limit).toArray();
481:   },
482: };

================
File: src/setupTests.ts
================
  1: import "@testing-library/jest-dom";
  2: import "fake-indexeddb/auto";
  3: 
  4: 
  5: import { TextEncoder, TextDecoder } from "util";
  6: 
  7: 
  8: global.TextEncoder = TextEncoder as typeof global.TextEncoder;
  9: global.TextDecoder = TextDecoder as typeof global.TextDecoder;
 10: 
 11: 
 12: if (!global.crypto) {
 13:   global.crypto = {
 14:     randomUUID: () =>
 15:       "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx" as `${string}-${string}-${string}-${string}-${string}`,
 16:     getRandomValues: <T extends ArrayBufferView | null>(array: T): T => array,
 17:     subtle: {} as SubtleCrypto,
 18:   } as unknown as Crypto;
 19: }
 20: 
 21: if (!global.crypto.randomUUID) {
 22:   global.crypto.randomUUID = () => {
 23:     return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
 24:       /[xy]/g,
 25:       function (c) {
 26:         const r = (Math.random() * 16) | 0;
 27:         const v = c === "x" ? r : (r & 0x3) | 0x8;
 28:         return v.toString(16);
 29:       }
 30:     ) as `${string}-${string}-${string}-${string}-${string}`;
 31:   };
 32: }
 33: 
 34: 
 35: global.IntersectionObserver = class IntersectionObserver {
 36:   root: Element | null = null;
 37:   rootMargin: string = "0px";
 38:   thresholds: ReadonlyArray<number> = [0];
 39: 
 40:   constructor() {}
 41:   observe() {
 42:     return null;
 43:   }
 44:   disconnect() {
 45:     return null;
 46:   }
 47:   unobserve() {
 48:     return null;
 49:   }
 50:   takeRecords(): IntersectionObserverEntry[] {
 51:     return [];
 52:   }
 53: } as any;
 54: 
 55: 
 56: Object.defineProperty(navigator, "onLine", {
 57:   writable: true,
 58:   value: true,
 59: });
 60: 
 61: Object.defineProperty(navigator, "serviceWorker", {
 62:   value: {
 63:     register: jest.fn(() =>
 64:       Promise.resolve({
 65:         installing: null,
 66:         waiting: null,
 67:         active: null,
 68:         addEventListener: jest.fn(),
 69:         removeEventListener: jest.fn(),
 70:       })
 71:     ),
 72:     ready: Promise.resolve({
 73:       update: jest.fn(),
 74:       unregister: jest.fn(),
 75:       addEventListener: jest.fn(),
 76:     }),
 77:     controller: null,
 78:     addEventListener: jest.fn(),
 79:   },
 80: });
 81: 
 82: 
 83: Object.defineProperty(navigator, "mediaDevices", {
 84:   value: {
 85:     getUserMedia: jest.fn(() =>
 86:       Promise.resolve({
 87:         getTracks: () => [{ stop: jest.fn() }],
 88:       })
 89:     ),
 90:   },
 91: });
 92: 
 93: 
 94: global.FileReader = class FileReader {
 95:   static readonly EMPTY = 0;
 96:   static readonly LOADING = 1;
 97:   static readonly DONE = 2;
 98: 
 99:   result: string | ArrayBuffer | null = null;
100:   readyState: number = 0;
101:   error: DOMException | null = null;
102: 
103:   readAsDataURL = jest.fn();
104:   readAsText = jest.fn();
105:   readAsArrayBuffer = jest.fn();
106:   readAsBinaryString = jest.fn();
107:   addEventListener = jest.fn();
108:   removeEventListener = jest.fn();
109:   dispatchEvent = jest.fn();
110:   abort = jest.fn();
111: 
112:   onload: ((this: FileReader, ev: ProgressEvent<FileReader>) => any) | null =
113:     null;
114:   onerror: ((this: FileReader, ev: ProgressEvent<FileReader>) => any) | null =
115:     null;
116:   onabort: ((this: FileReader, ev: ProgressEvent<FileReader>) => any) | null =
117:     null;
118:   onloadstart:
119:     | ((this: FileReader, ev: ProgressEvent<FileReader>) => any)
120:     | null = null;
121:   onloadend: ((this: FileReader, ev: ProgressEvent<FileReader>) => any) | null =
122:     null;
123:   onprogress:
124:     | ((this: FileReader, ev: ProgressEvent<FileReader>) => any)
125:     | null = null;
126: } as any;
127: 
128: if (!global.structuredClone) {
129:   global.structuredClone = <T>(obj: T): T => {
130: 
131:     if (obj === null || typeof obj !== "object") {
132:       return obj;
133:     }
134: 
135:     if (obj instanceof Date) {
136:       return new Date(obj.getTime()) as T;
137:     }
138: 
139:     if (obj instanceof Array) {
140:       return obj.map((item) => global.structuredClone(item)) as T;
141:     }
142: 
143:     if (typeof obj === "object") {
144:       const cloned: Record<string, unknown> = {};
145:       for (const key in obj) {
146:         if (Object.hasOwn(obj, key)) {
147:           cloned[key] = global.structuredClone(
148:             (obj as Record<string, unknown>)[key]
149:           );
150:         }
151:       }
152:       return cloned as T;
153:     }
154: 
155:     return obj;
156:   };
157: }
158: 
159: 
160: Object.defineProperty(navigator, "storage", {
161:   value: {
162:     estimate: jest.fn(() =>
163:       Promise.resolve({
164:         quota: 1000000000,
165:         usage: 100000,
166:       })
167:     ),
168:   },
169: });
170: 
171: 
172: export const mockDate = (date: string): void => {
173:   const mockNow = new Date(date);
174:   jest.spyOn(Date, "now").mockReturnValue(mockNow.getTime());
175:   jest.spyOn(global, "Date").mockImplementation(() => mockNow);
176: };
177: 
178: export const restoreDate = (): void => {
179:   jest.restoreAllMocks();
180: };

================
File: src/db/seedData.ts
================
 1: import { varietyService } from "@/types/database";
 2: import { seedVarieties } from "../data/seedVarieties";
 3: 
 4: 
 5: let isInitializing = false;
 6: 
 7: export async function initializeDatabase() {
 8: 
 9:   if (isInitializing) {
10:     console.log("Database initialization already in progress, skipping...");
11:     return;
12:   }
13: 
14:   try {
15:     isInitializing = true;
16: 
17: 
18:     const existingVarieties = await varietyService.getAllVarieties();
19: 
20: 
21:     const existingNames = new Set(existingVarieties.map((v) => v.name.trim()));
22: 
23: 
24: 
25: 
26:     const varietiesToAdd = seedVarieties.filter(
27:       (variety) => !existingNames.has(variety.name.trim())
28:     );
29: 
30:     if (varietiesToAdd.length > 0) {
31:       console.log(
32:         `Adding ${varietiesToAdd.length} new varieties:`,
33:         varietiesToAdd.map((v) => v.name)
34:       );
35: 
36:       for (const variety of varietiesToAdd) {
37: 
38:         const existing = await varietyService.getVarietyByName(
39:           variety.name.trim()
40:         );
41:         if (existing) {
42:           console.log(`Variety "${variety.name}" already exists, skipping...`);
43:           continue;
44:         }
45: 
46:         await varietyService.addVariety({
47:           name: variety.name.trim(),
48:           category: variety.category,
49:           growthTimeline: variety.growthTimeline,
50:           protocols: variety.protocols || {},
51:           isEverbearing: variety.isEverbearing,
52:           productiveLifespan: variety.productiveLifespan,
53:         });
54:       }
55:     } else {
56:       console.log("✅ All seed varieties already exist in database");
57:     }
58: 
59: 
60:     const finalVarieties = await varietyService.getAllVarieties();
61:     const finalNames = finalVarieties.map((v) => v.name);
62:     const uniqueFinalNames = new Set(finalNames);
63: 
64:     if (finalNames.length !== uniqueFinalNames.size) {
65:       console.error("🚨 Duplicates detected after initialization!");
66:       const duplicates = finalNames.filter(
67:         (name, index) => finalNames.indexOf(name) !== index
68:       );
69:       console.error("Duplicate names:", [...new Set(duplicates)]);
70:     }
71:   } catch (error) {
72:     console.error("Failed to initialize database:", error);
73:   } finally {
74:     isInitializing = false;
75:   }
76: }

================
File: src/pages/plants/Plants.tsx
================
  1: import React, { useState, useEffect } from "react";
  2: import { Card, CardContent } from "@/components/ui/Card";
  3: import { Button } from "@/components/ui/Button";
  4: import { plantService, PlantRecord } from "@/types/database";
  5: import { Link } from "react-router-dom";
  6: import PlantStageDisplay from "@/components/plant/PlantStageDisplay";
  7: import NextTaskDisplay from "@/components/plant/NextTaskDisplay";
  8: import { formatDate, getDaysSincePlanting } from "@/utils/dateUtils";
  9: 
 10: const Plants: React.FC = () => {
 11:   const [plants, setPlants] = useState<PlantRecord[]>([]);
 12:   const [isLoading, setIsLoading] = useState(true);
 13: 
 14:   useEffect(() => {
 15:     loadPlants();
 16:   }, []);
 17: 
 18:   async function loadPlants() {
 19:     try {
 20:       const activePlants = await plantService.getActivePlants();
 21:       setPlants(activePlants);
 22:     } catch (error) {
 23:       console.error("Failed to load plants:", error);
 24:     } finally {
 25:       setIsLoading(false);
 26:     }
 27:   }
 28: 
 29:   if (isLoading) {
 30:     return (
 31:       <div className="p-4 flex items-center justify-center min-h-screen">
 32:         <div className="text-muted-foreground">Loading plants...</div>
 33:       </div>
 34:     );
 35:   }
 36: 
 37:   return (
 38:     <div className="p-4 space-y-4">
 39:       {}
 40:       <div className="flex items-center justify-between">
 41:         <h1 className="text-2xl font-bold text-foreground">My Plants</h1>
 42:         <Link to="/add-plant">
 43:           <Button variant="primary" size="sm">
 44:             Add Plant
 45:           </Button>
 46:         </Link>
 47:       </div>
 48: 
 49:       {}
 50:       {plants.length === 0 ? (
 51:         <Card>
 52:           <div className="text-center py-12">
 53:             <div className="text-6xl mb-4">🌱</div>
 54:             <h2 className="text-xl font-semibold text-foreground mb-2">
 55:               No plants yet
 56:             </h2>
 57:             <p className="text-muted-foreground mb-6">
 58:               Start your digital garden by adding your first plant
 59:             </p>
 60:             <Link to="/add-plant">
 61:               <Button variant="primary">Add Your First Plant</Button>
 62:             </Link>
 63:           </div>
 64:         </Card>
 65:       ) : (
 66:         <div className="space-y-4">
 67:           {plants.map((plant) => (
 68:             <Link
 69:               key={plant.id}
 70:               to={`/plants/${plant.id}`}
 71:               className="block"
 72:             >
 73:               <Card className="cursor-pointer hover:shadow-md transition-shadow">
 74:                 <CardContent className="p-4">
 75:                   <div className="flex items-start justify-between">
 76:                     <div className="flex-1">
 77:                       <h3 className="font-semibold text-card-foreground mb-1">
 78:                         {plant.name || plant.varietyName}
 79:                       </h3>
 80:                       <div className="text-sm text-muted-foreground mb-2">
 81:                         <div>📍 {plant.location}</div>
 82:                         <div>📦 {plant.container}</div>
 83:                         <PlantStageDisplay
 84:                           plant={plant}
 85:                           showEmoji={true}
 86:                           className="text-sm text-muted-foreground mb-2"
 87:                         />
 88:                         <div>
 89:                           📅 Planted: {formatDate(plant.plantedDate)} (
 90:                           {getDaysSincePlanting(plant.plantedDate)} days ago)
 91:                         </div>
 92:                         <NextTaskDisplay
 93:                           plantId={plant.id}
 94:                           className="mt-2 font-medium"
 95:                         />
 96:                       </div>
 97:                       {plant.notes && plant.notes.length > 0 && (
 98:                         <div className="mt-2 text-sm text-muted-foreground">
 99:                           📝 {plant.notes[0]}
100:                         </div>
101:                       )}
102:                     </div>
103:                     <div className="text-3xl ml-4">🌿</div>
104:                   </div>
105:                 </CardContent>
106:               </Card>
107:             </Link>
108:           ))}
109:         </div>
110:       )}
111:     </div>
112:   );
113: };
114: 
115: export default Plants;

================
File: src/services/careSchedulingService.ts
================
  1: import {
  2:   plantService,
  3:   careService,
  4:   varietyService,
  5:   PlantRecord,
  6: } from "@/types/database";
  7: import { GrowthStage } from "@/types/core";
  8: import { calculateCurrentStage } from "@/utils/growthStage";
  9: import { getPlantDisplayName } from "@/utils/plantDisplay";
 10: import { UpcomingTask } from "@/types/scheduling";
 11: import { addDays, differenceInDays } from "date-fns";
 12: 
 13: export class CareSchedulingService {
 14:   static async getUpcomingTasks(): Promise<UpcomingTask[]> {
 15:     try {
 16:       const plants = await plantService.getActivePlants();
 17:       const allTasks: UpcomingTask[] = [];
 18: 
 19:       for (const plant of plants) {
 20:         const plantTasks = await this.getTasksForPlant(plant);
 21: 
 22: 
 23:         const filteredTasks = plantTasks.filter((task) => {
 24:           if (!plant.reminderPreferences) return true;
 25: 
 26: 
 27:           const taskTypeMap: Record<
 28:             string,
 29:             keyof typeof plant.reminderPreferences
 30:           > = {
 31:             "Check water level": "watering",
 32:             Water: "watering",
 33:             Fertilize: "fertilizing",
 34:             Observe: "observation",
 35:             "Check lighting": "lighting",
 36:             Prune: "pruning",
 37:             "Health check": "observation",
 38:           };
 39: 
 40:           const preferenceKey = taskTypeMap[task.task];
 41:           return preferenceKey
 42:             ? plant.reminderPreferences[preferenceKey]
 43:             : true;
 44:         });
 45: 
 46:         allTasks.push(...filteredTasks);
 47:       }
 48: 
 49:       return allTasks.sort((a, b) => a.dueDate.getTime() - b.dueDate.getTime());
 50:     } catch (error) {
 51:       console.error("Error getting upcoming tasks:", error);
 52:       return [];
 53:     }
 54:   }
 55: 
 56:   private static async getTasksForPlant(
 57:     plant: PlantRecord
 58:   ): Promise<UpcomingTask[]> {
 59:     try {
 60:       const variety = await varietyService.getVariety(plant.varietyId);
 61:       if (!variety) return [];
 62: 
 63: 
 64:       const currentStage = calculateCurrentStage(
 65:         plant.plantedDate,
 66:         variety.growthTimeline
 67:       );
 68: 
 69:       if (currentStage !== plant.currentStage) {
 70:         await plantService.updatePlant(plant.id, {
 71:           currentStage,
 72:           updatedAt: new Date(),
 73:         });
 74:       }
 75: 
 76:       const tasks: UpcomingTask[] = [];
 77: 
 78: 
 79:       const wateringTask = await this.createWateringTask(plant, currentStage);
 80:       if (wateringTask) tasks.push(wateringTask);
 81: 
 82: 
 83:       const observationTask = await this.createObservationTask(
 84:         plant,
 85:         currentStage
 86:       );
 87:       if (observationTask) tasks.push(observationTask);
 88: 
 89:       return tasks;
 90:     } catch (error) {
 91:       console.error(`Error processing tasks for plant ${plant.id}:`, error);
 92:       return [];
 93:     }
 94:   }
 95: 
 96:   private static async createWateringTask(
 97:     plant: PlantRecord,
 98:     currentStage: GrowthStage
 99:   ): Promise<UpcomingTask | null> {
100:     const lastWatering = await careService.getLastCareActivityByType(
101:       plant.id,
102:       "water"
103:     );
104: 
105: 
106:     const wateringIntervals: Record<GrowthStage, number> = {
107:       germination: 1,
108:       seedling: 2,
109:       vegetative: 3,
110:       flowering: 2,
111:       fruiting: 2,
112:       maturation: 3,
113:       harvest: 4,
114:       "ongoing-production": 2,
115:     };
116: 
117:     const intervalDays = wateringIntervals[currentStage] || 3;
118: 
119:     let nextDueDate: Date;
120: 
121:     if (lastWatering) {
122:       nextDueDate = addDays(lastWatering.date, intervalDays);
123:     } else {
124: 
125:       const daysSincePlanting = differenceInDays(new Date(), plant.plantedDate);
126:       nextDueDate =
127:         daysSincePlanting > 1 ? new Date() : addDays(plant.plantedDate, 1);
128:     }
129: 
130: 
131:     if (nextDueDate <= addDays(new Date(), 2)) {
132: 
133:       const daysOverdue = differenceInDays(new Date(), nextDueDate);
134: 
135:       return {
136:         id: `water-${plant.id}`,
137:         plantId: plant.id,
138:         name: getPlantDisplayName(plant),
139:         task: "Check water level",
140:         dueIn: this.formatDueIn(nextDueDate),
141:         priority: this.calculatePriority(daysOverdue),
142:         plantStage: currentStage,
143:         dueDate: nextDueDate,
144:         canBypass: true,
145:       };
146:     }
147: 
148:     return null;
149:   }
150: 
151:   private static async createObservationTask(
152:     plant: PlantRecord,
153:     currentStage: GrowthStage
154:   ): Promise<UpcomingTask | null> {
155:     const lastObservation = await careService.getLastCareActivityByType(
156:       plant.id,
157:       "observe"
158:     );
159: 
160: 
161:     const observationInterval = 7;
162: 
163:     let nextDueDate: Date;
164: 
165:     if (lastObservation) {
166:       nextDueDate = addDays(lastObservation.date, observationInterval);
167:     } else {
168: 
169:       nextDueDate = addDays(plant.plantedDate, 3);
170:     }
171: 
172: 
173:     if (nextDueDate <= addDays(new Date(), 1)) {
174: 
175:       const daysOverdue = differenceInDays(new Date(), nextDueDate);
176: 
177:       return {
178:         id: `observe-${plant.id}`,
179:         plantId: plant.id,
180:         name: getPlantDisplayName(plant),
181:         task: "Health check",
182:         dueIn: this.formatDueIn(nextDueDate),
183:         priority: this.calculatePriority(daysOverdue),
184:         plantStage: currentStage,
185:         dueDate: nextDueDate,
186:         canBypass: true,
187:       };
188:     }
189: 
190:     return null;
191:   }
192: 
193:   static async getNextTaskForPlant(
194:     plantId: string
195:   ): Promise<UpcomingTask | null> {
196:     const plants = await plantService.getActivePlants();
197:     const plant = plants.find((p) => p.id === plantId);
198: 
199:     if (!plant) return null;
200: 
201:     const tasks = await this.getTasksForPlant(plant);
202: 
203: 
204:     const filteredTasks = tasks.filter((task) => {
205:       if (!plant.reminderPreferences) return true;
206: 
207:       const taskTypeMap: Record<
208:         string,
209:         keyof typeof plant.reminderPreferences
210:       > = {
211:         "Check water level": "watering",
212:         Water: "watering",
213:         Fertilize: "fertilizing",
214:         Observe: "observation",
215:         "Check lighting": "lighting",
216:         Prune: "pruning",
217:         "Health check": "observation",
218:       };
219: 
220:       const preferenceKey = taskTypeMap[task.task];
221:       return preferenceKey ? plant.reminderPreferences[preferenceKey] : true;
222:     });
223: 
224: 
225:     if (filteredTasks.length === 0) return null;
226: 
227:     return filteredTasks.sort(
228:       (a, b) => a.dueDate.getTime() - b.dueDate.getTime()
229:     )[0];
230:   }
231: 
232:   private static formatDueIn(dueDate: Date): string {
233:     const now = new Date();
234:     const diffDays = differenceInDays(dueDate, now);
235: 
236:     if (diffDays < 0) {
237:       return `${Math.abs(diffDays)} days overdue`;
238:     } else if (diffDays === 0) {
239:       return "Due today";
240:     } else if (diffDays === 1) {
241:       return "Due tomorrow";
242:     } else {
243:       return `Due in ${diffDays} days`;
244:     }
245:   }
246: 
247:   private static calculatePriority(
248:     daysOverdue: number
249:   ): "low" | "medium" | "high" {
250:     if (daysOverdue >= 2) return "high";
251:     if (daysOverdue >= 0) return "medium";
252:     return "low";
253:   }
254: }

================
File: src/utils/growthStage.ts
================
  1: import { GrowthStage } from "../types";
  2: import { addDays, differenceInDays } from "date-fns";
  3: import { VarietyRecord } from "@/types/database";
  4: 
  5: export interface GrowthStageInfo {
  6:   stage: GrowthStage;
  7:   startDay: number;
  8:   endDay: number;
  9:   description: string;
 10: }
 11: 
 12: export interface VarietyTimeline {
 13:   germination: number;
 14:   seedling: number;
 15:   vegetative: number;
 16:   maturation: number;
 17: }
 18: 
 19: export function calculateCurrentStageWithVariety(
 20:   plantedDate: Date,
 21:   variety: VarietyRecord,
 22:   currentDate: Date = new Date()
 23: ): GrowthStage {
 24:   const daysSincePlanting = differenceInDays(currentDate, plantedDate);
 25:   const timeline = variety.growthTimeline;
 26: 
 27:   if (daysSincePlanting < 0) return "germination";
 28:   if (daysSincePlanting < timeline.germination) return "germination";
 29:   if (daysSincePlanting < timeline.germination + timeline.seedling)
 30:     return "seedling";
 31:   if (
 32:     daysSincePlanting <
 33:     timeline.germination + timeline.seedling + timeline.vegetative
 34:   ) {
 35:     return "vegetative";
 36:   }
 37:   if (daysSincePlanting < timeline.maturation) {
 38:     return "flowering";
 39:   }
 40: 
 41:   if (variety.isEverbearing) {
 42: 
 43: 
 44:     const effectiveLifespan = variety.productiveLifespan ?? 730;
 45: 
 46:     if (daysSincePlanting >= effectiveLifespan) {
 47:       return "harvest";
 48:     }
 49:     return "ongoing-production";
 50:   } else {
 51:     return "harvest";
 52:   }
 53: }
 54: 
 55: 
 56: export function calculateCurrentStage(
 57:   plantedDate: Date,
 58:   timeline: VarietyTimeline,
 59:   currentDate: Date = new Date()
 60: ): GrowthStage {
 61:   const daysSincePlanting = differenceInDays(currentDate, plantedDate);
 62: 
 63:   if (daysSincePlanting < 0) return "germination";
 64:   if (daysSincePlanting < timeline.germination) return "germination";
 65:   if (daysSincePlanting < timeline.germination + timeline.seedling)
 66:     return "seedling";
 67:   if (
 68:     daysSincePlanting <
 69:     timeline.germination + timeline.seedling + timeline.vegetative
 70:   )
 71:     return "vegetative";
 72:   if (daysSincePlanting < timeline.maturation) return "flowering";
 73: 
 74:   return "harvest";
 75: }
 76: 
 77: export function getStageProgress(
 78:   plantedDate: Date,
 79:   timeline: VarietyTimeline,
 80:   currentDate: Date = new Date()
 81: ): number {
 82:   const daysSincePlanting = differenceInDays(currentDate, plantedDate);
 83:   const currentStage = calculateCurrentStage(
 84:     plantedDate,
 85:     timeline,
 86:     currentDate
 87:   );
 88: 
 89:   let stageStart = 0;
 90:   let stageEnd = timeline.germination;
 91: 
 92:   switch (currentStage) {
 93:     case "seedling":
 94:       stageStart = timeline.germination;
 95:       stageEnd = timeline.germination + timeline.seedling;
 96:       break;
 97:     case "vegetative":
 98:       stageStart = timeline.germination + timeline.seedling;
 99:       stageEnd = timeline.germination + timeline.seedling + timeline.vegetative;
100:       break;
101:     case "flowering":
102:       stageStart =
103:         timeline.germination + timeline.seedling + timeline.vegetative;
104:       stageEnd = timeline.maturation;
105:       break;
106:     case "maturation":
107:     case "ongoing-production":
108:     case "harvest":
109:       return 100;
110:   }
111: 
112:   const stageProgress =
113:     ((daysSincePlanting - stageStart) / (stageEnd - stageStart)) * 100;
114:   return Math.min(Math.max(stageProgress, 0), 100);
115: }
116: 
117: export function getNextStage(currentStage: GrowthStage): GrowthStage | null {
118:   const stages: GrowthStage[] = [
119:     "germination",
120:     "seedling",
121:     "vegetative",
122:     "flowering",
123:     "maturation",
124:     "ongoing-production",
125:     "harvest",
126:   ];
127:   const currentIndex = stages.indexOf(currentStage);
128: 
129:   if (currentIndex === -1 || currentIndex === stages.length - 1) {
130:     return null;
131:   }
132: 
133:   return stages[currentIndex + 1];
134: }
135: 
136: export function estimateStageTransition(
137:   plantedDate: Date,
138:   timeline: VarietyTimeline,
139:   targetStage: GrowthStage
140: ): Date {
141:   let daysToTarget = 0;
142: 
143:   switch (targetStage) {
144:     case "seedling":
145:       daysToTarget = timeline.germination;
146:       break;
147:     case "vegetative":
148:       daysToTarget = timeline.germination + timeline.seedling;
149:       break;
150:     case "flowering":
151:       daysToTarget =
152:         timeline.germination + timeline.seedling + timeline.vegetative;
153:       break;
154:     case "maturation":
155:     case "ongoing-production":
156:     case "harvest":
157:       daysToTarget = timeline.maturation;
158:       break;
159:   }
160: 
161:   return addDays(plantedDate, daysToTarget);
162: }
163: 
164: export function formatStageProgress(progress: number): string {
165:   return `${Math.round(progress)}%`;
166: }

================
File: src/App.tsx
================
 1: import { useEffect } from "react";
 2: import { Routes, Route } from "react-router-dom";
 3: 
 4: import Dashboard from "./pages/dashboard";
 5: import Plants from "./pages/plants/Plants";
 6: import PlantDetail from "@/pages/plants/PlantDetail";
 7: import AddPlant from "./pages/plants/AddPlant";
 8: import LogCare from "./pages/care/LogCare";
 9: import Navigation from "./components/Navigation";
10: import { useAppInitialization } from "./hooks/useAppInitialization";
11: import { initializeDatabase } from "./db/seedData";
12: import "./App.css";
13: 
14: function App() {
15:   useAppInitialization();
16: 
17:   useEffect(() => {
18:     initializeDatabase();
19:   }, []);
20: 
21:   return (
22:     <div className="min-h-screen bg-background">
23:       <main className="pb-20">
24:         <Routes>
25:           <Route path="/" element={<Dashboard />} />
26:           <Route path="/plants" element={<Plants />} />
27:           <Route path="/plants/:plantId" element={<PlantDetail />} />{" "}
28:           {}
29:           <Route path="/log-care" element={<LogCare />} />
30:           <Route path="/add-plant" element={<AddPlant />} />
31:         </Routes>
32:       </main>
33: 
34:       <Navigation />
35:     </div>
36:   );
37: }
38: 
39: export default App;

================
File: src/pages/plants/PlantDetail.tsx
================
  1: import React, { useState, useEffect } from "react";
  2: import { useParams, useNavigate, Link } from "react-router-dom";
  3: import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/Card";
  4: import { Button } from "@/components/ui/Button";
  5: import { LoadingSpinner } from "@/components/ui/LoadingSpinner";
  6: import {
  7:   plantService,
  8:   careService,
  9:   varietyService,
 10:   PlantRecord,
 11:   CareRecord,
 12:   VarietyRecord,
 13: } from "@/types/database";
 14: import PlantStageDisplay from "@/components/plant/PlantStageDisplay";
 15: import NextTaskDisplay from "@/components/plant/NextTaskDisplay";
 16: import CareHistory from "@/components/plant/CareHistory";
 17: import PlantReminderSettings from "@/components/plant/PlantReminderSettings";
 18: import { formatDate, getDaysSincePlanting } from "@/utils/dateUtils";
 19: import { getPlantDisplayName } from "@/utils/plantDisplay";
 20: 
 21: const PlantDetail: React.FC = () => {
 22:   const { plantId } = useParams<{ plantId: string }>();
 23:   const navigate = useNavigate();
 24: 
 25:   const [plant, setPlant] = useState<PlantRecord | null>(null);
 26:   const [variety, setVariety] = useState<VarietyRecord | null>(null);
 27:   const [careHistory, setCareHistory] = useState<CareRecord[]>([]);
 28:   const [isLoading, setIsLoading] = useState(true);
 29:   const [error, setError] = useState<string | null>(null);
 30:   const [showReminderSettings, setShowReminderSettings] = useState(false);
 31: 
 32:   useEffect(() => {
 33:     if (!plantId) {
 34:       setError("No plant ID provided");
 35:       setIsLoading(false);
 36:       return;
 37:     }
 38: 
 39:     async function loadPlantDetails() {
 40:       try {
 41:         setIsLoading(true);
 42:         setError(null);
 43: 
 44:         const [plantData, careHistoryData] = await Promise.all([
 45:           plantService.getPlant(plantId as string),
 46:           careService.getPlantCareHistory(plantId as string),
 47:         ]);
 48: 
 49:         if (!plantData) {
 50:           setError("Plant not found");
 51:           return;
 52:         }
 53: 
 54:         setPlant(plantData);
 55:         setCareHistory(careHistoryData);
 56: 
 57:         if (plantData.varietyId) {
 58:           const varietyData = await varietyService.getVariety(
 59:             plantData.varietyId
 60:           );
 61:           setVariety(varietyData || null);
 62:         }
 63:       } catch (error) {
 64:         console.error("Failed to load plant details:", error);
 65:         setError("Failed to load plant details");
 66:       } finally {
 67:         setIsLoading(false);
 68:       }
 69:     }
 70: 
 71:     loadPlantDetails();
 72:   }, [plantId]);
 73: 
 74:   const handlePlantUpdate = (updatedPlant: PlantRecord) => {
 75:     setPlant(updatedPlant);
 76:   };
 77: 
 78:   const handleLogCare = (activityType?: string) => {
 79:     const params = new URLSearchParams();
 80:     if (plantId) params.set("plantId", plantId);
 81:     if (activityType) params.set("type", activityType);
 82: 
 83:     navigate(`/log-care?${params.toString()}`);
 84:   };
 85: 
 86:   if (isLoading) {
 87:     return (
 88:       <div className="min-h-screen flex items-center justify-center">
 89:         <LoadingSpinner />
 90:       </div>
 91:     );
 92:   }
 93: 
 94:   if (error || !plant) {
 95:     return (
 96:       <div className="min-h-screen flex flex-col items-center justify-center p-4">
 97:         <div className="text-center max-w-md">
 98:           <span className="text-6xl mb-4 block">🌱</span>
 99:           <h2 className="text-xl font-semibold text-foreground mb-2">
100:             {error || "Plant not found"}
101:           </h2>
102:           <p className="text-muted-foreground mb-4">
103:             We couldn't load the details for this plant.
104:           </p>
105:           <Button onClick={() => navigate(-1)} variant="outline">
106:             Go Back
107:           </Button>
108:         </div>
109:       </div>
110:     );
111:   }
112: 
113:   return (
114:     <div className="min-h-screen bg-background">
115:       {}
116:       <div className="bg-card border-b border-border">
117:         <div className="p-4">
118:           <div className="flex items-center justify-between mb-4">
119:             <Button
120:               variant="outline"
121:               onClick={() => navigate(-1)}
122:               className="flex items-center gap-2"
123:             >
124:               <span>←</span>
125:               Back
126:             </Button>
127:             <Button
128:               variant="outline"
129:               onClick={() => setShowReminderSettings(!showReminderSettings)}
130:               className="flex items-center gap-2"
131:             >
132:               <span>⚙️</span>
133:               {showReminderSettings ? "Hide" : "Settings"}
134:             </Button>
135:           </div>
136: 
137:           <h1 className="text-2xl font-bold text-foreground mb-2">
138:             {getPlantDisplayName(plant)}
139:           </h1>
140: 
141:           <div className="flex gap-3">
142:             {}
143:             <Button
144:               onClick={() => handleLogCare()}
145:               className="flex-1"
146:               variant="primary"
147:             >
148:               <span className="mr-2">💧</span>
149:               Log Care
150:             </Button>
151:             <Button variant="outline" className="flex-1">
152:               <span className="mr-2">📷</span>
153:               Add Photo
154:             </Button>
155:           </div>
156:         </div>
157:       </div>
158: 
159:       <div className="p-4 space-y-4 bg-background">
160:         {}
161:         {showReminderSettings && plant && (
162:           <Card className="border-border bg-muted/30">
163:             <CardHeader>
164:               <CardTitle className="text-lg flex items-center gap-2">
165:                 <span>🔔</span>
166:                 Notification Settings
167:               </CardTitle>
168:             </CardHeader>
169:             <CardContent>
170:               <PlantReminderSettings
171:                 plant={plant}
172:                 onUpdate={handlePlantUpdate}
173:               />
174:             </CardContent>
175:           </Card>
176:         )}
177: 
178:         {}
179:         <Card>
180:           <CardHeader>
181:             <CardTitle className="flex items-center gap-2">
182:               <span className="text-2xl">🌿</span>
183:               Plant Details
184:             </CardTitle>
185:           </CardHeader>
186:           <CardContent className="space-y-4">
187:             {}
188:             <div>
189:               <span className="font-medium text-muted-foreground">
190:                 Next Task:
191:               </span>
192:               <div className="mt-1">
193:                 <NextTaskDisplay
194:                   plantId={plantId!}
195:                   className="text-base"
196:                   onClick={(taskType) => handleLogCare(taskType)}
197:                 />
198:               </div>
199:             </div>
200:             {}
201:             <div className="grid grid-cols-2 gap-4 text-sm">
202:               <div>
203:                 <span className="font-medium text-muted-foreground">
204:                   Variety:
205:                 </span>
206:                 <div className="text-card-foreground">
207:                   {variety?.name || "Unknown"}
208:                 </div>
209:               </div>
210:               <div>
211:                 <span className="font-medium text-muted-foreground">
212:                   Location:
213:                 </span>
214:                 <div className="text-card-foreground">
215:                   {plant.location ? "Outdoor" : "Indoor"}
216:                 </div>{" "}
217:               </div>
218:               <div>
219:                 <span className="font-medium text-muted-foreground">
220:                   Container:
221:                 </span>
222:                 <div className="text-card-foreground">📦 {plant.container}</div>
223:               </div>
224:               <div>
225:                 <span className="font-medium text-muted-foreground">
226:                   Planted:
227:                 </span>
228:                 <div className="text-card-foreground">
229:                   📅 {formatDate(plant.plantedDate)} (
230:                   {getDaysSincePlanting(plant.plantedDate)} days ago)
231:                 </div>
232:               </div>
233:             </div>
234: 
235:             {}
236:             {plant.soilMix && (
237:               <div>
238:                 <span className="font-medium text-muted-foreground">
239:                   Soil Mix:
240:                 </span>
241:                 <div className="text-card-foreground">🌱 {plant.soilMix}</div>
242:               </div>
243:             )}
244: 
245:             {}
246:             {variety && variety.category && (
247:               <div>
248:                 <span className="font-medium text-muted-foreground">
249:                   Category:
250:                 </span>
251:                 <div className="text-card-foreground capitalize">
252:                   {variety.category.replace("-", " ")}
253:                 </div>
254:               </div>
255:             )}
256: 
257:             {}
258:             <div>
259:               <span className="font-medium text-muted-foreground">
260:                 Growth Stage:
261:               </span>
262:               <div className="mt-1">
263:                 <PlantStageDisplay
264:                   plant={plant}
265:                   showEmoji={true}
266:                   className="text-base"
267:                 />
268:               </div>
269:             </div>
270: 
271:             {}
272:             {variety && variety.growthTimeline && (
273:               <div>
274:                 <span className="font-medium text-muted-foreground">
275:                   Expected Timeline:
276:                 </span>
277:                 <div className="text-foreground text-sm mt-1 grid grid-cols-2 gap-2">
278:                   <div>
279:                     Germination: {variety.growthTimeline.germination} days
280:                   </div>
281:                   <div>Seedling: {variety.growthTimeline.seedling} days</div>
282:                   <div>
283:                     Vegetative: {variety.growthTimeline.vegetative} days
284:                   </div>
285:                   <div>
286:                     Maturation: {variety.growthTimeline.maturation} days
287:                   </div>
288:                 </div>
289:               </div>
290:             )}
291: 
292:             {}
293:             {plant.reminderPreferences && (
294:               <div>
295:                 <span className="font-medium text-muted-foreground">
296:                   Active Reminders:
297:                 </span>
298:                 <div className="text-foreground text-sm mt-1 flex flex-wrap justify-center gap-2">
299:                   {Object.entries(plant.reminderPreferences)
300:                     .filter(([, enabled]) => enabled)
301:                     .map(([type]) => (
302:                       <span
303:                         key={type}
304:                         className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-emerald-100 text-emerald-800 capitalize"
305:                       >
306:                         {type === "observation" ? "Health Checks" : type}
307:                       </span>
308:                     ))}
309:                   {Object.values(plant.reminderPreferences).every(
310:                     (enabled) => !enabled
311:                   ) && (
312:                     <span className="text-muted-foreground text-xs">
313:                       All reminders disabled
314:                     </span>
315:                   )}
316:                 </div>
317:               </div>
318:             )}
319: 
320:             {}
321:             {plant.notes && plant.notes.length > 0 && (
322:               <div>
323:                 <span className="font-medium text-muted-foreground">
324:                   Notes:
325:                 </span>
326:                 <div className="text-foreground text-sm mt-1 space-y-1">
327:                   {plant.notes.map((note, index) => (
328:                     <div key={index} className="bg-background p-2 rounded">
329:                       📝 {note}
330:                     </div>
331:                   ))}
332:                 </div>
333:               </div>
334:             )}
335:           </CardContent>
336:         </Card>
337: 
338:         {}
339:         <CareHistory careHistory={careHistory} />
340:       </div>
341:     </div>
342:   );
343: };
344: 
345: export default PlantDetail;

================
File: jest.config.ts
================
 1: import type { Config } from "jest";
 2: 
 3: const config: Config = {
 4:   preset: "ts-jest",
 5:   testEnvironment: "jsdom",
 6:   setupFilesAfterEnv: ["<rootDir>/src/setupTests.ts"],
 7:   moduleNameMapper: {
 8:     "^@/(.*)$": "<rootDir>/src/$1",
 9:     "^@/components/(.*)$": "<rootDir>/src/components/$1",
10:     "^@/pages/(.*)$": "<rootDir>/src/pages/$1",
11:     "^@/hooks/(.*)$": "<rootDir>/src/hooks/$1",
12:     "^@/services/(.*)$": "<rootDir>/src/services/$1",
13:     "^@/types/(.*)$": "<rootDir>/src/types/$1",
14:     "^@/utils/(.*)$": "<rootDir>/src/utils/$1",
15:     "^@/data/(.*)$": "<rootDir>/src/data/$1",
16:     "^@/db/(.*)$": "<rootDir>/src/db/$1",
17:   },
18:   collectCoverageFrom: [
19:     "src/**/*.{ts,tsx}",
20:     "!src/**/*.d.ts",
21:     "!src/main.tsx",
22:     "!src/vite-env.d.ts",
23:     "!src/setupTests.ts",
24:   ],
25: 
26:   testMatch: [
27:     "<rootDir>/src/**/__tests__/**/*.{js,jsx,ts,tsx}",
28:     "<rootDir>/src/**/*.(test|spec).{js,jsx,ts,tsx}",
29:   ],
30:   transform: {
31:     "^.+\\.(ts|tsx)$": "ts-jest",
32:   },
33:   moduleFileExtensions: ["ts", "tsx", "js", "jsx", "json"],
34:   testPathIgnorePatterns: [
35:     "/__tests__/utils/testHelpers.tsx",
36:     "/__tests__/utils/plantFactory.ts",
37:   ],
38: 
39:   coverageThreshold: {
40:     global: {
41:       branches: 85,
42:       functions: 85,
43:       lines: 85,
44:       statements: 85,
45:     },
46: 
47:     "./src/services/": {
48:       branches: 90,
49:       functions: 90,
50:       lines: 90,
51:       statements: 90,
52:     },
53:   },
54: };
55: 
56: export default config;

================
File: src/pages/care/CareLogForm.tsx
================
   1: import { useState, useEffect, useCallback } from "react";
   2: import { useForm } from "react-hook-form";
   3: import { useSearchParams } from "react-router-dom";
   4: import { zodResolver } from "@hookform/resolvers/zod";
   5: import { z } from "zod";
   6: import {
   7:   plantService,
   8:   careService,
   9:   varietyService,
  10:   PlantRecord,
  11:   VarietyRecord,
  12:   CareActivityDetails,
  13:   WateringDetails,
  14:   FertilizingDetails,
  15:   ObservationDetails,
  16: } from "@/types/database";
  17: import { Button } from "@/components/ui/Button";
  18: import { PhotoCapture } from "./PhotoCapture";
  19: import { calculateCurrentStage } from "@/utils/growthStage";
  20: import { GrowthStage } from "@/types/core";
  21: import toast from "react-hot-toast";
  22: import {
  23:   SmartDefaultsService,
  24:   SmartDefaults,
  25:   QuickCompletionValues,
  26: } from "@/services/smartDefaultsService";
  27: import QuickCompletionButtons from "@/pages/care/QuickCompletionButtons";
  28: 
  29: 
  30: interface MoistureValidationMessage {
  31:   field: "before" | "after" | "source";
  32:   message: string;
  33:   color: string;
  34: }
  35: 
  36: interface MoistureValidationResult {
  37:   validations: MoistureValidationMessage[];
  38:   isValid: boolean;
  39: }
  40: 
  41: interface CategoryMoistureDefaults {
  42:   trigger: [number, number];
  43:   target: [number, number];
  44: }
  45: 
  46: interface PlantMoistureProtocol {
  47:   trigger: [number, number];
  48:   target: [number, number];
  49:   varietyName: string;
  50:   currentStage: GrowthStage;
  51:   isDefault: boolean;
  52:   source: "protocol" | "category" | "universal";
  53: }
  54: 
  55: 
  56: function extractMoistureRangesForStage(
  57:   variety: VarietyRecord,
  58:   stage: GrowthStage
  59: ): PlantMoistureProtocol | null {
  60: 
  61:   const stageProtocol = variety.protocols?.watering?.[stage] as {
  62:     trigger?: { moistureLevel?: string | number };
  63:     target?: { moistureLevel?: string | number };
  64:   };
  65: 
  66:   if (
  67:     stageProtocol?.trigger?.moistureLevel &&
  68:     stageProtocol?.target?.moistureLevel
  69:   ) {
  70:     const triggerRange = parseMoistureRange(
  71:       stageProtocol.trigger.moistureLevel
  72:     );
  73:     const targetRange = parseMoistureRange(stageProtocol.target.moistureLevel);
  74: 
  75:     if (triggerRange && targetRange) {
  76:       return {
  77:         trigger: triggerRange,
  78:         target: targetRange,
  79:         varietyName: variety.name || "Unknown",
  80:         currentStage: stage,
  81:         isDefault: false,
  82:         source: "protocol",
  83:       };
  84:     }
  85:   }
  86: 
  87: 
  88:   const categoryDefaults = getCategoryBasedDefaults(variety.category, stage);
  89:   if (categoryDefaults) {
  90:     return {
  91:       ...categoryDefaults,
  92:       varietyName: variety.name || "Unknown",
  93:       currentStage: stage,
  94:       isDefault: false,
  95:       source: "category",
  96:     };
  97:   }
  98: 
  99: 
 100:   return {
 101:     trigger: [3, 4] as [number, number],
 102:     target: [6, 7] as [number, number],
 103:     varietyName: variety.name || "Unknown",
 104:     currentStage: stage,
 105:     isDefault: true,
 106:     source: "universal",
 107:   };
 108: }
 109: 
 110: function parseMoistureRange(value: string | number): [number, number] | null {
 111:   if (typeof value === "number") {
 112:     return [value, value];
 113:   }
 114: 
 115:   if (typeof value === "string") {
 116: 
 117:     const rangeMatch = value.match(/(\d+(?:\.\d+)?)-(\d+(?:\.\d+)?)/);
 118:     if (rangeMatch) {
 119:       return [parseFloat(rangeMatch[1]), parseFloat(rangeMatch[2])];
 120:     }
 121: 
 122: 
 123:     const singleMatch = value.match(/(\d+(?:\.\d+)?)/);
 124:     if (singleMatch) {
 125:       const num = parseFloat(singleMatch[1]);
 126:       return [num, num];
 127:     }
 128:   }
 129: 
 130:   return null;
 131: }
 132: 
 133: function getCategoryBasedDefaults(
 134:   category: string,
 135:   stage: GrowthStage
 136: ): CategoryMoistureDefaults | null {
 137: 
 138:   const categoryProtocols: Record<
 139:     string,
 140:     Record<GrowthStage, CategoryMoistureDefaults>
 141:   > = {
 142:     "root-vegetables": {
 143:       germination: { trigger: [4, 5], target: [6, 7] },
 144:       seedling: { trigger: [4, 5], target: [6, 7] },
 145:       vegetative: { trigger: [3, 4], target: [6, 7] },
 146:       flowering: { trigger: [3, 4], target: [6, 7] },
 147:       fruiting: { trigger: [3, 4], target: [6, 7] },
 148:       maturation: { trigger: [3, 4], target: [6, 7] },
 149:       harvest: { trigger: [3, 4], target: [6, 7] },
 150:       "ongoing-production": { trigger: [3, 4], target: [6, 7] },
 151:     },
 152:     "leafy-greens": {
 153:       germination: { trigger: [3, 4], target: [6, 7] },
 154:       seedling: { trigger: [3, 4], target: [6, 7] },
 155:       vegetative: { trigger: [3, 4], target: [6, 7] },
 156:       flowering: { trigger: [3, 4], target: [6, 7] },
 157:       fruiting: { trigger: [3, 4], target: [6, 7] },
 158:       maturation: { trigger: [3, 4], target: [6, 7] },
 159:       harvest: { trigger: [3, 4], target: [6, 7] },
 160:       "ongoing-production": { trigger: [3, 4], target: [6, 7] },
 161:     },
 162:     "fruiting-plants": {
 163:       germination: { trigger: [4, 5], target: [7, 8] },
 164:       seedling: { trigger: [4, 5], target: [7, 8] },
 165:       vegetative: { trigger: [3, 4], target: [6, 7] },
 166:       flowering: { trigger: [3, 4], target: [6, 7] },
 167:       fruiting: { trigger: [3, 4], target: [6, 8] },
 168:       maturation: { trigger: [3, 4], target: [6, 8] },
 169:       harvest: { trigger: [3, 4], target: [6, 8] },
 170:       "ongoing-production": { trigger: [3, 4], target: [6, 8] },
 171:     },
 172:     herbs: {
 173:       germination: { trigger: [3, 4], target: [6, 7] },
 174:       seedling: { trigger: [3, 4], target: [6, 7] },
 175:       vegetative: { trigger: [3, 4], target: [6, 7] },
 176:       flowering: { trigger: [3, 4], target: [6, 7] },
 177:       fruiting: { trigger: [3, 4], target: [6, 7] },
 178:       maturation: { trigger: [3, 4], target: [6, 7] },
 179:       harvest: { trigger: [3, 4], target: [6, 7] },
 180:       "ongoing-production": { trigger: [3, 4], target: [6, 7] },
 181:     },
 182:     berries: {
 183:       germination: { trigger: [3, 4], target: [6, 7] },
 184:       seedling: { trigger: [3, 4], target: [6, 7] },
 185:       vegetative: { trigger: [3, 4], target: [6, 7] },
 186:       flowering: { trigger: [3, 4], target: [6, 7] },
 187:       fruiting: { trigger: [3, 4], target: [6, 7] },
 188:       maturation: { trigger: [3, 4], target: [6, 7] },
 189:       harvest: { trigger: [3, 4], target: [6, 7] },
 190:       "ongoing-production": { trigger: [3, 4], target: [6, 7] },
 191:     },
 192:   };
 193: 
 194:   return categoryProtocols[category]?.[stage] || null;
 195: }
 196: 
 197: 
 198: const baseCareSchema = z.object({
 199:   plantId: z.string().min(1, "Please select a plant"),
 200:   type: z.enum(["water", "fertilize", "observe", "harvest", "transplant"]),
 201:   date: z.string(),
 202:   notes: z.string().optional(),
 203: });
 204: 
 205: const wateringSchema = baseCareSchema.extend({
 206:   type: z.literal("water"),
 207:   waterValue: z.number().min(0.1, "Water amount must be greater than 0"),
 208:   waterUnit: z.enum(["oz", "ml", "cups", "liters", "gallons"]),
 209:   moistureBefore: z.number().min(1).max(10).optional(),
 210:   moistureAfter: z.number().min(1).max(10).optional(),
 211:   applicationMethod: z
 212:     .enum(["top-watering", "bottom-watering", "drip", "misting"])
 213:     .optional(),
 214:   runoffObserved: z.boolean().optional(),
 215: });
 216: 
 217: const fertilizingSchema = baseCareSchema.extend({
 218:   type: z.literal("fertilize"),
 219:   product: z.string().min(1, "Fertilizer product is required"),
 220:   dilution: z.string().min(1, "Dilution ratio is required"),
 221:   amount: z.string().min(1, "Application amount is required"),
 222: });
 223: 
 224: const observationSchema = baseCareSchema.extend({
 225:   type: z.literal("observe"),
 226:   healthAssessment: z.enum([
 227:     "excellent",
 228:     "good",
 229:     "fair",
 230:     "concerning",
 231:     "critical",
 232:   ]),
 233:   observations: z.string().min(1, "Observations are required"),
 234:   photos: z.array(z.string()).optional(),
 235: });
 236: 
 237: const careFormSchema = z.discriminatedUnion("type", [
 238:   wateringSchema,
 239:   fertilizingSchema,
 240:   observationSchema,
 241: ]);
 242: 
 243: type CareFormData = z.infer<typeof careFormSchema>;
 244: 
 245: interface CareLogFormProps {
 246:   onSuccess?: () => void;
 247:   onCancel?: () => void;
 248:   preselectedPlantId?: string;
 249:   preselectedActivityType?: "water" | "fertilize" | "observe";
 250: }
 251: 
 252: export function CareLogForm({
 253:   onSuccess,
 254:   onCancel,
 255:   preselectedPlantId,
 256:   preselectedActivityType,
 257: }: CareLogFormProps) {
 258:   const [plants, setPlants] = useState<PlantRecord[]>([]);
 259:   const [isLoading, setIsLoading] = useState(false);
 260:   const [submitError, setSubmitError] = useState<string | null>(null);
 261:   const [capturedPhotos, setCapturedPhotos] = useState<string[]>([]);
 262:   const [showDetailedTracking, setShowDetailedTracking] = useState(false);
 263:   const [searchParams] = useSearchParams();
 264: 
 265: 
 266:   const [moistureValidation, setMoistureValidation] =
 267:     useState<MoistureValidationResult | null>(null);
 268: 
 269: 
 270:   const [smartDefaults, setSmartDefaults] = useState<SmartDefaults | null>(
 271:     null
 272:   );
 273:   const [isLoadingDefaults, setIsLoadingDefaults] = useState(false);
 274: 
 275:   const {
 276:     register,
 277:     handleSubmit,
 278:     watch,
 279:     formState: { errors },
 280:     reset,
 281:     setValue,
 282:   } = useForm<CareFormData>({
 283:     resolver: zodResolver(careFormSchema),
 284:     defaultValues: {
 285:       plantId: preselectedPlantId || searchParams.get("plantId") || "",
 286:       type:
 287:         preselectedActivityType ||
 288:         (searchParams.get("type") as "water" | "fertilize" | "observe") ||
 289:         "water",
 290:       date: new Date().toISOString().split("T")[0],
 291:       waterValue: undefined,
 292:       waterUnit: "oz",
 293:     },
 294:   });
 295: 
 296:   const activityType = watch("type");
 297:   const selectedPlantId = watch("plantId");
 298:   const moistureBefore = watch("moistureBefore");
 299:   const moistureAfter = watch("moistureAfter");
 300: 
 301: 
 302:   useEffect(() => {
 303:     const loadPlants = async () => {
 304:       try {
 305:         const plantList = await plantService.getActivePlants();
 306:         setPlants(plantList);
 307:       } catch (error) {
 308:         console.error("Failed to load plants:", error);
 309:         toast.error("Failed to load plants");
 310:       }
 311:     };
 312: 
 313:     loadPlants();
 314:   }, []);
 315: 
 316:   useEffect(() => {
 317:     const plantIdToSet = preselectedPlantId || searchParams.get("plantId");
 318:     if (plantIdToSet && plants.length > 0) {
 319:       const plant = plants.find((p) => p.id === plantIdToSet);
 320:       if (plant) {
 321:         setValue("plantId", plantIdToSet);
 322:       }
 323:     }
 324:   }, [plants, preselectedPlantId, searchParams, setValue]);
 325: 
 326:   useEffect(() => {
 327:     const activityTypeToSet =
 328:       preselectedActivityType || searchParams.get("type");
 329:     if (
 330:       activityTypeToSet &&
 331:       ["water", "fertilize", "observe"].includes(activityTypeToSet)
 332:     ) {
 333:       setValue("type", activityTypeToSet as "water" | "fertilize" | "observe");
 334:     }
 335:   }, [searchParams, preselectedActivityType, setValue]);
 336: 
 337: 
 338:   useEffect(() => {
 339:     const loadSmartDefaults = async () => {
 340:       if (!selectedPlantId || !plants.length) {
 341:         setSmartDefaults(null);
 342:         return;
 343:       }
 344: 
 345:       const plant = plants.find((p) => p.id === selectedPlantId);
 346:       if (!plant) return;
 347: 
 348:       try {
 349:         setIsLoadingDefaults(true);
 350:         const defaults = await SmartDefaultsService.getDefaultsForPlant(plant);
 351:         setSmartDefaults(defaults);
 352: 
 353: 
 354:         if (activityType === "water" && defaults?.watering) {
 355:           setValue("waterValue", defaults.watering.suggestedAmount);
 356:           setValue("waterUnit", defaults.watering.unit);
 357:         }
 358:       } catch (error) {
 359:         console.error("Error loading smart defaults:", error);
 360:       } finally {
 361:         setIsLoadingDefaults(false);
 362:       }
 363:     };
 364: 
 365:     loadSmartDefaults();
 366:   }, [selectedPlantId, plants, activityType, setValue]);
 367: 
 368: 
 369:   const handleQuickComplete = (values: QuickCompletionValues) => {
 370:     Object.entries(values).forEach(([key, value]) => {
 371:       if (value !== undefined) {
 372:         setValue(key as keyof CareFormData, value);
 373:       }
 374:     });
 375:   };
 376: 
 377: 
 378:   const getPlantMoistureProtocol = useCallback(
 379:     async (plantId: string) => {
 380:       const plant = plants.find((p) => p.id === plantId);
 381:       if (!plant) return null;
 382: 
 383:       try {
 384:         const variety = await varietyService.getVariety(plant.varietyId);
 385:         if (!variety) return null;
 386: 
 387: 
 388:         const currentStage = calculateCurrentStage(
 389:           plant.plantedDate,
 390:           variety.growthTimeline
 391:         );
 392: 
 393: 
 394:         return extractMoistureRangesForStage(variety, currentStage);
 395:       } catch (error) {
 396:         console.error("Error fetching plant moisture protocol:", error);
 397:         return null;
 398:       }
 399:     },
 400:     [plants]
 401:   );
 402: 
 403: 
 404:   const getMoistureValidationForPlant = useCallback(
 405:     async (
 406:       plantId: string,
 407:       moistureBefore?: number,
 408:       moistureAfter?: number
 409:     ): Promise<MoistureValidationResult | null> => {
 410:       const protocol = await getPlantMoistureProtocol(plantId);
 411:       if (!protocol) return null;
 412: 
 413:       const validations: MoistureValidationMessage[] = [];
 414: 
 415: 
 416:       if (moistureBefore !== undefined) {
 417:         const [triggerMin, triggerMax] = protocol.trigger;
 418:         if (moistureBefore >= triggerMin && moistureBefore <= triggerMax) {
 419:           validations.push({
 420:             field: "before",
 421:             message: `✓ Perfect timing! ${triggerMin}-${triggerMax} is ideal for watering.`,
 422:             color: "text-green-600",
 423:           });
 424:         } else if (moistureBefore > triggerMax) {
 425:           validations.push({
 426:             field: "before",
 427:             message: `ℹ️ Plant still moist (${triggerMin}-${triggerMax} recommended for watering).`,
 428:             color: "text-blue-600",
 429:           });
 430:         } else {
 431:           validations.push({
 432:             field: "before",
 433:             message: `⚠️ Very dry! Watering at ${triggerMin}-${triggerMax} prevents stress.`,
 434:             color: "text-orange-600",
 435:           });
 436:         }
 437:       }
 438: 
 439: 
 440:       if (moistureAfter !== undefined) {
 441:         const [targetMin, targetMax] = protocol.target;
 442:         if (moistureAfter >= targetMin && moistureAfter <= targetMax) {
 443:           validations.push({
 444:             field: "after",
 445:             message: `✓ Perfect! Target range ${targetMin}-${targetMax} achieved.`,
 446:             color: "text-green-600",
 447:           });
 448:         } else if (moistureAfter > targetMax) {
 449:           validations.push({
 450:             field: "after",
 451:             message: `⚠️ Over-watered. Target is ${targetMin}-${targetMax}. Allow drying time.`,
 452:             color: "text-orange-600",
 453:           });
 454:         } else {
 455:           validations.push({
 456:             field: "after",
 457:             message: `ℹ️ Could use more water. Target: ${targetMin}-${targetMax}.`,
 458:             color: "text-blue-600",
 459:           });
 460:         }
 461:       }
 462: 
 463: 
 464:       const sourceMessages = {
 465:         protocol: `Using ${protocol.varietyName} ${protocol.currentStage} stage protocol`,
 466:         category: `Using category-based guidance for ${protocol.currentStage} stage`,
 467:         universal: `Using universal defaults (variety protocol incomplete)`,
 468:       };
 469: 
 470:       validations.push({
 471:         field: "source",
 472:         message: sourceMessages[protocol.source],
 473:         color: protocol.isDefault ? "text-muted-foreground" : "text-foreground",
 474:       });
 475: 
 476:       return {
 477:         validations,
 478:         isValid: true,
 479:       };
 480:     },
 481:     [getPlantMoistureProtocol]
 482:   );
 483: 
 484: 
 485:   useEffect(() => {
 486:     if (selectedPlantId && (moistureBefore || moistureAfter)) {
 487:       getMoistureValidationForPlant(
 488:         selectedPlantId,
 489:         moistureBefore,
 490:         moistureAfter
 491:       ).then(setMoistureValidation);
 492:     } else {
 493:       setMoistureValidation(null);
 494:     }
 495:   }, [
 496:     selectedPlantId,
 497:     moistureBefore,
 498:     moistureAfter,
 499:     getMoistureValidationForPlant,
 500:   ]);
 501: 
 502:   const onSubmit = async (data: CareFormData) => {
 503:     try {
 504:       setIsLoading(true);
 505:       setSubmitError(null);
 506: 
 507: 
 508:       let careDetails: CareActivityDetails;
 509: 
 510:       switch (data.type) {
 511:         case "water": {
 512:           const wateringDetails: WateringDetails = {
 513:             type: "water" as const,
 514:             amount: {
 515:               value: data.waterValue,
 516:               unit: data.waterUnit,
 517:             },
 518:             moistureReading:
 519:               showDetailedTracking && data.moistureBefore && data.moistureAfter
 520:                 ? {
 521:                     before: data.moistureBefore,
 522:                     after: data.moistureAfter,
 523:                     scale: "1-10" as const,
 524:                   }
 525:                 : undefined,
 526:             method: data.applicationMethod,
 527:             runoffObserved: data.runoffObserved,
 528:             notes: data.notes,
 529:           };
 530:           careDetails = wateringDetails;
 531:           break;
 532:         }
 533: 
 534:         case "fertilize": {
 535:           const fertilizingDetails: FertilizingDetails = {
 536:             type: "fertilize" as const,
 537:             product: data.product,
 538:             dilution: data.dilution,
 539:             amount: data.amount,
 540:             notes: data.notes,
 541:           };
 542:           careDetails = fertilizingDetails;
 543:           break;
 544:         }
 545: 
 546:         case "observe": {
 547:           const observationDetails: ObservationDetails = {
 548:             type: "observe" as const,
 549:             healthAssessment: data.healthAssessment,
 550:             observations: data.observations,
 551:             photos: capturedPhotos,
 552:             notes: data.notes,
 553:           };
 554:           careDetails = observationDetails;
 555:           break;
 556:         }
 557: 
 558:         default: {
 559:           throw new Error(`Unsupported activity type`);
 560:         }
 561:       }
 562: 
 563:       await careService.addCareActivity({
 564:         plantId: data.plantId,
 565:         type: data.type,
 566:         date: new Date(data.date),
 567:         details: careDetails,
 568:       });
 569: 
 570:       toast.success("Care activity logged successfully!");
 571:       reset();
 572:       setCapturedPhotos([]);
 573:       onSuccess?.();
 574:     } catch (error) {
 575:       console.error("Failed to log care activity:", error);
 576:       setSubmitError("Failed to log care activity. Please try again.");
 577:       toast.error("Failed to log care activity");
 578:     } finally {
 579:       setIsLoading(false);
 580:     }
 581:   };
 582: 
 583:   function renderWateringFields() {
 584:     const selectedPlant = plants.find((p) => p.id === selectedPlantId);
 585: 
 586:     return (
 587:       <>
 588:         {}
 589:         {smartDefaults?.watering && (
 590:           <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
 591:             <div className="flex items-start justify-between">
 592:               <div>
 593:                 <h4 className="text-sm font-medium text-blue-900 mb-1">
 594:                   💡 Smart Suggestion
 595:                 </h4>
 596:                 <p className="text-sm text-blue-700">
 597:                   {smartDefaults.watering.reasoning}
 598:                 </p>
 599:                 <div className="flex items-center mt-2 text-xs text-blue-600">
 600:                   <span
 601:                     className={`inline-block w-2 h-2 rounded-full mr-1 ${
 602:                       smartDefaults.watering.confidence === "high"
 603:                         ? "bg-green-500"
 604:                         : smartDefaults.watering.confidence === "medium"
 605:                         ? "bg-yellow-500"
 606:                         : "bg-red-500"
 607:                     }`}
 608:                   />
 609:                   {smartDefaults.watering.confidence} confidence
 610:                 </div>
 611:               </div>
 612:               <div className="text-right">
 613:                 <div className="text-lg font-semibold text-blue-900">
 614:                   {smartDefaults.watering.suggestedAmount}{" "}
 615:                   {smartDefaults.watering.unit}
 616:                 </div>
 617:                 <button
 618:                   type="button"
 619:                   onClick={() =>
 620:                     handleQuickComplete({
 621:                       waterValue: smartDefaults.watering!.suggestedAmount,
 622:                       waterUnit: smartDefaults.watering!.unit,
 623:                     })
 624:                   }
 625:                   className="text-xs text-blue-600 hover:text-blue-800 underline"
 626:                 >
 627:                   Use this amount
 628:                 </button>
 629:               </div>
 630:             </div>
 631:           </div>
 632:         )}
 633: 
 634:         {}
 635:         {selectedPlant && (
 636:           <QuickCompletionButtons
 637:             plant={selectedPlant}
 638:             activityType="water"
 639:             onQuickComplete={handleQuickComplete}
 640:             className="mb-4"
 641:           />
 642:         )}
 643: 
 644:         <div className="grid grid-cols-3 gap-4">
 645:           <div className="col-span-2">
 646:             <label
 647:               htmlFor="waterValue"
 648:               className="block text-sm font-medium text-foreground mb-2"
 649:             >
 650:               Water Amount *
 651:             </label>
 652:             <input
 653:               id="waterValue"
 654:               type="number"
 655:               step="0.1"
 656:               min="0.1"
 657:               {...register("waterValue", { valueAsNumber: true })}
 658:               className="w-full p-3 bg-card text-card-foreground border border-border rounded-md focus:ring-2 focus:ring-ring focus:border-ring"
 659:               placeholder="Amount"
 660:             />
 661:             {"waterValue" in errors && errors.waterValue && (
 662:               <p className="mt-1 text-sm text-red-600">
 663:                 {errors.waterValue.message}
 664:               </p>
 665:             )}
 666:           </div>
 667: 
 668:           <div>
 669:             <label
 670:               htmlFor="waterUnit"
 671:               className="block text-sm font-medium text-foreground mb-2"
 672:             >
 673:               Unit *
 674:             </label>
 675:             <select
 676:               id="waterUnit"
 677:               {...register("waterUnit")}
 678:               className="w-full p-3 bg-card text-card-foreground border border-border rounded-md focus:ring-2 focus:ring-ring focus:border-ring"
 679:             >
 680:               <option value="oz">oz</option>
 681:               <option value="ml">ml</option>
 682:               <option value="cups">cups</option>
 683:               <option value="liters">liters</option>
 684:               <option value="gallons">gallons</option>
 685:             </select>
 686:           </div>
 687:         </div>
 688: 
 689:         {}
 690:         <div className="flex items-center">
 691:           <input
 692:             id="showDetailedTracking"
 693:             type="checkbox"
 694:             checked={showDetailedTracking}
 695:             onChange={(e) => setShowDetailedTracking(e.target.checked)}
 696:             className="h-4 w-4 text-garden-600 border-border rounded focus:ring-garden-500"
 697:           />
 698:           <label
 699:             htmlFor="showDetailedTracking"
 700:             className="ml-2 text-sm text-foreground"
 701:           >
 702:             📊 Track moisture readings & method
 703:           </label>
 704:         </div>
 705: 
 706:         {}
 707:         {showDetailedTracking && (
 708:           <div className="space-y-4 p-4 bg-background rounded-lg border border-border">
 709:             <h4 className="text-sm font-medium text-foreground">
 710:               Detailed Tracking
 711:             </h4>
 712: 
 713:             <div className="grid grid-cols-2 gap-4">
 714:               <div>
 715:                 <label
 716:                   htmlFor="moistureBefore"
 717:                   className="block text-sm font-medium text-foreground mb-2"
 718:                 >
 719:                   Moisture Before (1-10 scale)
 720:                 </label>
 721:                 <input
 722:                   id="moistureBefore"
 723:                   type="number"
 724:                   min="1"
 725:                   max="10"
 726:                   step="0.5"
 727:                   {...register("moistureBefore", { valueAsNumber: true })}
 728:                   className="w-full p-3 border border-border rounded-md focus:ring-2 focus:ring-garden-500"
 729:                   placeholder="e.g., 3"
 730:                 />
 731:                 <p className="mt-1 text-xs text-muted-foreground">
 732:                   1 = bone dry, 10 = waterlogged
 733:                 </p>
 734: 
 735:                 {}
 736:                 {moistureValidation?.validations
 737:                   ?.filter((v) => v.field === "before")
 738:                   .map((validation, idx) => (
 739:                     <p
 740:                       key={idx}
 741:                       className={`mt-1 text-xs ${validation.color} flex items-start`}
 742:                     >
 743:                       <span className="flex-shrink-0 mr-1">
 744:                         {validation.message.split(" ")[0]}
 745:                       </span>
 746:                       <span>
 747:                         {validation.message.substring(
 748:                           validation.message.indexOf(" ") + 1
 749:                         )}
 750:                       </span>
 751:                     </p>
 752:                   ))}
 753: 
 754:                 {"moistureBefore" in errors && errors.moistureBefore && (
 755:                   <p className="mt-1 text-sm text-red-600">
 756:                     {errors.moistureBefore.message}
 757:                   </p>
 758:                 )}
 759:               </div>
 760: 
 761:               <div>
 762:                 <label
 763:                   htmlFor="moistureAfter"
 764:                   className="block text-sm font-medium text-foreground mb-2"
 765:                 >
 766:                   Moisture After (1-10 scale)
 767:                 </label>
 768:                 <input
 769:                   id="moistureAfter"
 770:                   type="number"
 771:                   min="1"
 772:                   max="10"
 773:                   step="0.5"
 774:                   {...register("moistureAfter", { valueAsNumber: true })}
 775:                   className="w-full p-3 border border-border rounded-md focus:ring-2 focus:ring-garden-500"
 776:                   placeholder="e.g., 7"
 777:                 />
 778:                 <p className="mt-1 text-xs text-muted-foreground">
 779:                   Target range varies by plant - see protocol above
 780:                 </p>
 781: 
 782:                 {}
 783:                 {moistureValidation?.validations
 784:                   ?.filter((v) => v.field === "after")
 785:                   .map((validation, idx) => (
 786:                     <p
 787:                       key={idx}
 788:                       className={`mt-1 text-xs ${validation.color} flex items-start`}
 789:                     >
 790:                       <span className="flex-shrink-0 mr-1">
 791:                         {validation.message.split(" ")[0]}
 792:                       </span>
 793:                       <span>
 794:                         {validation.message.substring(
 795:                           validation.message.indexOf(" ") + 1
 796:                         )}
 797:                       </span>
 798:                     </p>
 799:                   ))}
 800: 
 801:                 {"moistureAfter" in errors && errors.moistureAfter && (
 802:                   <p className="mt-1 text-sm text-red-600">
 803:                     {errors.moistureAfter.message}
 804:                   </p>
 805:                 )}
 806:               </div>
 807:             </div>
 808: 
 809:             <div className="flex items-start">
 810:               <input
 811:                 id="runoffObserved"
 812:                 type="checkbox"
 813:                 {...register("runoffObserved")}
 814:                 className="mt-1 h-4 w-4 text-garden-600 border-border rounded focus:ring-garden-500"
 815:               />
 816:               <div className="ml-3">
 817:                 <label
 818:                   htmlFor="runoffObserved"
 819:                   className="text-sm font-medium text-foreground"
 820:                 >
 821:                   Observed water runoff from drainage holes
 822:                 </label>
 823:                 <p className="text-xs text-muted-foreground mt-1">
 824:                   Runoff indicates thorough watering and good drainage
 825:                 </p>
 826:               </div>
 827:             </div>
 828: 
 829:             {}
 830:             {moistureValidation?.validations
 831:               ?.filter((v) => v.field === "source")
 832:               .map((validation, idx) => (
 833:                 <div
 834:                   key={idx}
 835:                   className="mt-3 p-2 bg-background border border-border rounded-md"
 836:                 >
 837:                   <p className={`text-xs ${validation.color}`}>
 838:                     {validation.message}
 839:                   </p>
 840:                 </div>
 841:               ))}
 842:           </div>
 843:         )}
 844:       </>
 845:     );
 846:   }
 847: 
 848:   function renderFertilizingFields() {
 849:     const selectedPlant = plants.find((p) => p.id === selectedPlantId);
 850: 
 851:     return (
 852:       <>
 853:         {}
 854:         {smartDefaults?.fertilizer && (
 855:           <div className="bg-green-50 border border-green-200 rounded-lg p-4 mb-4">
 856:             <h4 className="text-sm font-medium text-green-900 mb-2">
 857:               💡 Smart Suggestion
 858:             </h4>
 859:             <p className="text-sm text-green-700 mb-3">
 860:               {smartDefaults.fertilizer.reasoning}
 861:             </p>
 862:             <div className="space-y-2">
 863:               {smartDefaults.fertilizer.products.map((product, index) => (
 864:                 <button
 865:                   key={index}
 866:                   type="button"
 867:                   onClick={() =>
 868:                     handleQuickComplete({
 869:                       product: product.name,
 870:                       dilution: product.dilution,
 871:                       amount: product.amount,
 872:                     })
 873:                   }
 874:                   className="block w-full text-left p-2 bg-card border border-green-200 rounded hover:bg-green-50 transition-colors"
 875:                 >
 876:                   <div className="font-medium text-green-900">
 877:                     {product.name}
 878:                   </div>
 879:                   <div className="text-xs text-green-600">
 880:                     {product.dilution} • {product.amount}
 881:                   </div>
 882:                 </button>
 883:               ))}
 884:             </div>
 885:           </div>
 886:         )}
 887: 
 888:         {}
 889:         {selectedPlant && (
 890:           <QuickCompletionButtons
 891:             plant={selectedPlant}
 892:             activityType="fertilize"
 893:             onQuickComplete={handleQuickComplete}
 894:             className="mb-4"
 895:           />
 896:         )}
 897: 
 898:         <div>
 899:           <label
 900:             htmlFor="product"
 901:             className="block text-sm font-medium text-foreground mb-2"
 902:           >
 903:             Fertilizer Product *
 904:           </label>
 905:           <input
 906:             id="product"
 907:             type="text"
 908:             {...register("product")}
 909:             className="w-full p-3 bg-card text-card-foreground border border-border rounded-md focus:ring-2 focus:ring-ring focus:border-ring"
 910:             placeholder="e.g., Neptune's Harvest Fish & Seaweed"
 911:           />
 912:           {"product" in errors && errors.product && (
 913:             <p className="mt-1 text-sm text-red-600">
 914:               {errors.product.message}
 915:             </p>
 916:           )}
 917:         </div>
 918: 
 919:         <div className="grid grid-cols-2 gap-4">
 920:           <div>
 921:             <label
 922:               htmlFor="dilution"
 923:               className="block text-sm font-medium text-foreground mb-2"
 924:             >
 925:               Dilution Ratio *
 926:             </label>
 927:             <input
 928:               id="dilution"
 929:               type="text"
 930:               {...register("dilution")}
 931:               className="w-full p-3 bg-card text-card-foreground border border-border rounded-md focus:ring-2 focus:ring-ring focus:border-ring"
 932:               placeholder="e.g., 1 tbsp/gal, half strength"
 933:             />
 934:             {"dilution" in errors && errors.dilution && (
 935:               <p className="mt-1 text-sm text-red-600">
 936:                 {errors.dilution.message}
 937:               </p>
 938:             )}
 939:           </div>
 940: 
 941:           <div>
 942:             <label
 943:               htmlFor="amount"
 944:               className="block text-sm font-medium text-foreground mb-2"
 945:             >
 946:               Application Amount *
 947:             </label>
 948:             <input
 949:               id="amount"
 950:               type="text"
 951:               {...register("amount")}
 952:               className="w-full p-3 bg-card text-card-foreground border border-border rounded-md focus:ring-2 focus:ring-ring focus:border-ring"
 953:               placeholder="e.g., 16 oz, apply until runoff"
 954:             />
 955:             {"amount" in errors && errors.amount && (
 956:               <p className="mt-1 text-sm text-red-600">
 957:                 {errors.amount.message}
 958:               </p>
 959:             )}
 960:           </div>
 961:         </div>
 962:       </>
 963:     );
 964:   }
 965: 
 966:   function renderObservationFields() {
 967:     return (
 968:       <>
 969:         <div>
 970:           <label
 971:             htmlFor="healthAssessment"
 972:             className="block text-sm font-medium text-foreground mb-2"
 973:           >
 974:             Health Assessment *
 975:           </label>
 976:           <select
 977:             id="healthAssessment"
 978:             {...register("healthAssessment")}
 979:             className="w-full p-3 bg-card text-card-foreground border border-border rounded-md focus:ring-2 focus:ring-ring focus:border-ring"
 980:           >
 981:             <option value="">Select assessment...</option>
 982:             <option value="excellent">🌟 Excellent</option>
 983:             <option value="good">😊 Good</option>
 984:             <option value="fair">😐 Fair</option>
 985:             <option value="concerning">😟 Concerning</option>
 986:             <option value="critical">🚨 Critical</option>
 987:           </select>
 988:           {"healthAssessment" in errors && errors.healthAssessment && (
 989:             <p className="mt-1 text-sm text-red-600">
 990:               {errors.healthAssessment.message}
 991:             </p>
 992:           )}
 993:         </div>
 994: 
 995:         <div>
 996:           <label
 997:             htmlFor="observations"
 998:             className="block text-sm font-medium text-foreground mb-2"
 999:           >
1000:             Observations *
1001:           </label>
1002:           <textarea
1003:             id="observations"
1004:             rows={4}
1005:             {...register("observations")}
1006:             className="w-full p-3 bg-card text-card-foreground border border-border rounded-md focus:ring-2 focus:ring-ring focus:border-ring"
1007:             placeholder="Describe what you observed (growth, color, pests, diseases, etc.)"
1008:           />
1009:           {"observations" in errors && errors.observations && (
1010:             <p className="mt-1 text-sm text-red-600">
1011:               {errors.observations.message}
1012:             </p>
1013:           )}
1014:         </div>
1015: 
1016:         <PhotoCapture
1017:           photos={capturedPhotos}
1018:           onPhotosChange={setCapturedPhotos}
1019:           maxPhotos={5}
1020:         />
1021:       </>
1022:     );
1023:   }
1024: 
1025:   function renderActivitySpecificFields() {
1026:     switch (activityType) {
1027:       case "water":
1028:         return renderWateringFields();
1029:       case "fertilize":
1030:         return renderFertilizingFields();
1031:       case "observe":
1032:         return renderObservationFields();
1033:       default:
1034:         return null;
1035:     }
1036:   }
1037: 
1038:   return (
1039:     <div className="max-w-2xl mx-auto p-6 bg-card rounded-lg shadow-sm">
1040:       <div className="mb-6">
1041:         <h2 className="text-2xl font-bold text-foreground mb-2">
1042:           Log Care Activity
1043:         </h2>
1044:         <p className="text-muted-foreground">
1045:           Record care activities to track your plants' progress and optimize
1046:           their health.
1047:         </p>
1048:       </div>
1049: 
1050:       <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
1051:         {submitError && (
1052:           <div className="bg-red-50 border border-red-200 rounded-md p-4">
1053:             <p className="text-sm text-red-600">{submitError}</p>
1054:           </div>
1055:         )}
1056: 
1057:         {}
1058:         <div>
1059:           <label
1060:             htmlFor="plantId"
1061:             className="block text-sm font-medium text-foreground mb-2"
1062:           >
1063:             Plant *
1064:           </label>
1065:           <select
1066:             id="plantId"
1067:             {...register("plantId")}
1068:             className="w-full p-3 bg-card text-card-foreground border border-border rounded-md focus:ring-2 focus:ring-ring focus:border-ring"
1069:           >
1070:             <option value="">Select a plant...</option>
1071:             {plants.map((plant) => (
1072:               <option key={plant.id} value={plant.id}>
1073:                 {plant.name || plant.varietyName} - {plant.location}
1074:               </option>
1075:             ))}
1076:           </select>
1077:           {errors.plantId && (
1078:             <p className="mt-1 text-sm text-red-600">
1079:               {errors.plantId.message}
1080:             </p>
1081:           )}
1082:         </div>
1083: 
1084:         {}
1085:         <div>
1086:           <label
1087:             htmlFor="type"
1088:             className="block text-sm font-medium text-foreground mb-2"
1089:           >
1090:             Activity Type *
1091:           </label>
1092:           <select
1093:             id="type"
1094:             {...register("type")}
1095:             className="w-full p-3 bg-card text-card-foreground border border-border rounded-md focus:ring-2 focus:ring-ring focus:border-ring"
1096:           >
1097:             <option value="water">💧 Watering</option>
1098:             <option value="fertilize">🌱 Fertilizing</option>
1099:             <option value="observe">👁️ Observation</option>
1100:             {
1101: }
1102:           </select>
1103:         </div>
1104: 
1105:         {}
1106:         <div>
1107:           <label
1108:             htmlFor="date"
1109:             className="block text-sm font-medium text-foreground mb-2"
1110:           >
1111:             Date *
1112:           </label>
1113:           <input
1114:             id="date"
1115:             type="date"
1116:             {...register("date")}
1117:             className="w-full p-3 bg-card text-card-foreground border border-border rounded-md focus:ring-2 focus:ring-ring focus:border-ring"
1118:           />
1119:           {errors.date && (
1120:             <p className="mt-1 text-sm text-red-600">{errors.date.message}</p>
1121:           )}
1122:         </div>
1123: 
1124:         {}
1125:         {renderActivitySpecificFields()}
1126: 
1127:         {}
1128:         <div>
1129:           <label
1130:             htmlFor="notes"
1131:             className="block text-sm font-medium text-foreground mb-2"
1132:           >
1133:             Notes (optional)
1134:           </label>
1135:           <textarea
1136:             id="notes"
1137:             rows={3}
1138:             {...register("notes")}
1139:             className="w-full p-3 bg-card text-card-foreground border border-border rounded-md focus:ring-2 focus:ring-ring focus:border-ring"
1140:             placeholder="Any additional observations or notes..."
1141:           />
1142:         </div>
1143: 
1144:         {}
1145:         <div className="flex gap-4">
1146:           <Button
1147:             type="submit"
1148:             variant="primary"
1149:             disabled={isLoading || isLoadingDefaults}
1150:             className="flex-1"
1151:           >
1152:             {isLoading ? "Logging..." : "Log Activity"}
1153:           </Button>
1154:           {onCancel && (
1155:             <Button type="button" variant="outline" onClick={onCancel}>
1156:               Cancel
1157:             </Button>
1158:           )}
1159:         </div>
1160:       </form>
1161:     </div>
1162:   );
1163: }

================
File: src/pages/dashboard/index.tsx
================
  1: import { useState, useEffect, useCallback } from "react";
  2: import { Link, useNavigate } from "react-router-dom";
  3: import { Button } from "@/components/ui/Button";
  4: import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/Card";
  5: import { plantService, PlantRecord, careService } from "@/types/database";
  6: import { CareSchedulingService } from "@/services/careSchedulingService";
  7: import { TaskGroupingService } from "@/services/taskGroupingService";
  8: import { SmartDefaultsService } from "@/services/smartDefaultsService";
  9: import {
 10:   QuickCompleteOption,
 11:   QuickCompletionValues,
 12:   TaskGroup as TaskGroupType,
 13:   UpcomingTask,
 14: } from "@/types/scheduling";
 15: import { getPlantDisplayName } from "@/utils/plantDisplay";
 16: import TaskGroup from "@/pages/dashboard/TaskGroup";
 17: import { useFirstTimeUser } from "@/hooks/useFirstTimeUser";
 18: import Welcome from "@/components/layouts/Welcome";
 19: import { WateringDetails, FertilizingDetails } from "@/types/database";
 20: 
 21: interface QuickAction {
 22:   id: string;
 23:   label: string;
 24:   emoji: string;
 25:   action: () => void;
 26:   variant?: "primary" | "outline" | "destructive" | "secondary" | "ghost";
 27:   isContextual?: boolean;
 28: }
 29: 
 30: const Dashboard = () => {
 31:   const navigate = useNavigate();
 32:   const { isFirstTime, isLoading: isCheckingFirstTime } = useFirstTimeUser();
 33: 
 34:   const [plants, setPlants] = useState<PlantRecord[]>([]);
 35:   const [taskGroups, setTaskGroups] = useState<TaskGroupType[]>([]);
 36:   const [allTasks, setAllTasks] = useState<UpcomingTask[]>([]);
 37:   const [isLoading, setIsLoading] = useState(true);
 38:   const [error, setError] = useState<string | null>(null);
 39: 
 40:   const loadDashboardData = useCallback(async () => {
 41:     try {
 42:       setIsLoading(true);
 43:       setError(null);
 44: 
 45:       const [plantsData, rawTasks] = await Promise.all([
 46:         plantService.getActivePlants(),
 47:         CareSchedulingService.getUpcomingTasks(),
 48:       ]);
 49: 
 50:       const enhancedTasks = await Promise.all(
 51:         rawTasks.map(async (task) => {
 52:           const plant = plantsData.find((p) => p.id === task.plantId);
 53:           if (!plant) {
 54:             return { ...task, quickCompleteOptions: [], canBypass: true };
 55:           }
 56: 
 57:           const taskType = getTaskTypeFromName(task.task);
 58:           let quickOptions: QuickCompleteOption[] = [];
 59: 
 60:           try {
 61:             const options =
 62:               await SmartDefaultsService.getQuickCompletionOptions(
 63:                 plant,
 64:                 taskType
 65:               );
 66:             quickOptions = options || [];
 67:           } catch (error) {
 68:             console.error("Failed to get quick completion options:", error);
 69:             quickOptions = [];
 70:           }
 71: 
 72:           return {
 73:             ...task,
 74:             quickCompleteOptions: quickOptions,
 75:             canBypass: true,
 76:           };
 77:         })
 78:       );
 79: 
 80:       const grouped = TaskGroupingService.groupTasksByActivity(enhancedTasks);
 81: 
 82:       setPlants(plantsData);
 83:       setTaskGroups(grouped);
 84:       setAllTasks(enhancedTasks);
 85:     } catch (error) {
 86:       console.error("Failed to load dashboard data:", error);
 87:       setError("Failed to load dashboard data");
 88:     } finally {
 89:       setIsLoading(false);
 90:     }
 91:   }, []);
 92: 
 93:   useEffect(() => {
 94:     loadDashboardData();
 95:   }, [loadDashboardData]);
 96: 
 97:   const getTaskTypeFromName = (taskName: string): "water" | "fertilize" => {
 98:     const name = taskName.toLowerCase();
 99:     if (name.includes("water") || name.includes("moisture")) return "water";
100:     return "fertilize";
101:   };
102: 
103: 
104:   const getQuickActions = (): QuickAction[] => {
105:     const actions: QuickAction[] = [];
106: 
107: 
108:     const urgentTasks = allTasks.filter(
109:       (task) => task.priority === "high" || task.dueIn.includes("overdue")
110:     );
111: 
112: 
113:     const wateringTasks = urgentTasks.filter((task) =>
114:       task.task.toLowerCase().includes("water")
115:     );
116:     if (wateringTasks.length > 0) {
117:       const firstWateringTask = wateringTasks[0];
118:       const plant = plants.find((p) => p.id === firstWateringTask.plantId);
119:       if (plant) {
120:         actions.push({
121:           id: "water-urgent",
122:           label: `Water ${getPlantDisplayName(plant)}`,
123:           emoji: "💧",
124:           action: () => navigate(`/log-care?plantId=${plant.id}&type=water`),
125:           variant: "primary",
126:           isContextual: true,
127:         });
128:       }
129:     }
130: 
131: 
132:     const fertilizingTasks = urgentTasks.filter((task) =>
133:       task.task.toLowerCase().includes("fertiliz")
134:     );
135:     if (fertilizingTasks.length > 0 && actions.length < 2) {
136:       const firstFertilizingTask = fertilizingTasks[0];
137:       const plant = plants.find((p) => p.id === firstFertilizingTask.plantId);
138:       if (plant) {
139:         actions.push({
140:           id: "fertilize-urgent",
141:           label: `Fertilize ${getPlantDisplayName(plant)}`,
142:           emoji: "🌱",
143:           action: () =>
144:             navigate(`/log-care?plantId=${plant.id}&type=fertilize`),
145:           variant: "primary",
146:           isContextual: true,
147:         });
148:       }
149:     }
150: 
151: 
152:     const standardActions: QuickAction[] = [
153:       {
154:         id: "log-care",
155:         label: "Log Care",
156:         emoji: "💧",
157:         action: () => navigate("/log-care"),
158:         variant: "outline",
159:       },
160:       {
161:         id: "take-photo",
162:         label: "Take Photo",
163:         emoji: "📸",
164:         action: () => navigate("/log-care?type=observe"),
165:         variant: "outline",
166:       },
167:       {
168:         id: "analytics",
169:         label: "Analytics",
170:         emoji: "📊",
171:         action: () => navigate("/analytics"),
172:         variant: "outline",
173:       },
174:     ];
175: 
176:     return [...actions, ...standardActions];
177:   };
178: 
179:   const handleQuickComplete = async (
180:     taskId: string,
181:     values: QuickCompletionValues
182:   ) => {
183:     try {
184:       const task = taskGroups
185:         .flatMap((group) => group.tasks)
186:         .find((t) => t.id === taskId);
187: 
188:       if (!task) throw new Error("Task not found");
189: 
190:       const taskType = getTaskTypeFromName(task.task);
191: 
192:       let careDetails: WateringDetails | FertilizingDetails;
193: 
194:       if (taskType === "water") {
195:         careDetails = {
196:           type: "water" as const,
197:           amount: {
198:             value: values.waterValue || 0,
199:             unit:
200:               (values.waterUnit as
201:                 | "oz"
202:                 | "ml"
203:                 | "cups"
204:                 | "liters"
205:                 | "gallons") || "oz",
206:           },
207:           notes: `Quick completion: ${values.waterValue}${values.waterUnit}`,
208:         };
209:       } else {
210:         careDetails = {
211:           type: "fertilize" as const,
212:           product: values.product || "",
213:           dilution: values.dilution || "",
214:           amount: values.amount || "",
215:           notes: `Quick completion: ${values.product}`,
216:         };
217:       }
218: 
219:       const careData = {
220:         plantId: task.plantId,
221:         type: taskType,
222:         date: new Date(),
223:         details: careDetails,
224:       };
225: 
226:       await careService.addCareActivity(careData);
227:       await loadDashboardData();
228: 
229:       console.log("Task completed successfully!");
230:     } catch (error) {
231:       console.error("Failed to complete task:", error);
232:       throw error;
233:     }
234:   };
235: 
236:   const handleBypass = async (taskId: string, reason: string) => {
237:     try {
238:       console.log(`Task ${taskId} bypassed with reason: ${reason}`);
239:       await loadDashboardData();
240:     } catch (error) {
241:       console.error("Failed to bypass task:", error);
242:       throw error;
243:     }
244:   };
245: 
246:   if (isCheckingFirstTime) {
247:     return <div>Loading...</div>;
248:   }
249: 
250:   if (isFirstTime) {
251:     return <Welcome />;
252:   }
253: 
254:   if (isLoading) {
255:     return (
256:       <div className="flex items-center justify-center min-h-screen">
257:         <div className="text-center">
258:           <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-green-600 mx-auto mb-4"></div>
259:           <p>Loading your garden...</p>
260:         </div>
261:       </div>
262:     );
263:   }
264: 
265:   if (error) {
266:     return (
267:       <div className="p-4">
268:         <div className="bg-red-50 border border-red-200 rounded-lg p-4">
269:           <p className="text-red-800">{error}</p>
270:           <Button onClick={() => loadDashboardData()} className="mt-2">
271:             Try Again
272:           </Button>
273:         </div>
274:       </div>
275:     );
276:   }
277: 
278:   if (plants.length === 0) {
279:     return (
280:       <div className="p-4 text-center">
281:         <h2 className="text-xl font-semibold mb-4">Welcome to SmartGarden!</h2>
282:         <p className="text-muted-foreground mb-6">
283:           You don't have any plants yet. Let's get started!
284:         </p>
285:         <Link to="/add-plant">
286:           <Button>Add Your First Plant</Button>
287:         </Link>
288:       </div>
289:     );
290:   }
291: 
292:   const quickActions = getQuickActions();
293: 
294:   return (
295:     <div className="p-4 space-y-6">
296:       <div className="text-center">
297:         <h1 className="text-2xl font-bold text-foreground mb-2">
298:           Your Garden Dashboard
299:         </h1>
300:         <p className="text-muted-foreground" data-testid="active-plants-count">
301:           {plants.length} active plant{plants.length !== 1 ? "s" : ""} growing
302:           {taskGroups.reduce((total, group) => total + group.tasks.length, 0) >
303:             0 && (
304:             <span className="ml-2">
305:               •{" "}
306:               {taskGroups.reduce(
307:                 (total, group) => total + group.tasks.length,
308:                 0
309:               )}{" "}
310:               task
311:               {taskGroups.reduce(
312:                 (total, group) => total + group.tasks.length,
313:                 0
314:               ) !== 1
315:                 ? "s"
316:                 : ""}{" "}
317:               pending
318:             </span>
319:           )}
320:         </p>
321:       </div>
322: 
323:       {/* Task Groups */}
324:       <div className="space-y-4">
325:         {taskGroups.map((group) => (
326:           <TaskGroup
327:             key={group.type}
328:             group={group}
329:             onQuickComplete={handleQuickComplete}
330:             onBypass={handleBypass}
331:           />
332:         ))}
333:       </div>
334: 
335:       {}
336:       <Card>
337:         <CardHeader>
338:           <CardTitle className="flex items-center gap-2">
339:             <span>⚡</span>
340:             Quick Actions
341:           </CardTitle>
342:         </CardHeader>
343:         <CardContent>
344:           <div className="grid grid-cols-3 md:grid-cols-4 gap-3">
345:             {quickActions.map((action) => (
346:               <Button
347:                 key={action.id}
348:                 variant={action.variant || "outline"}
349:                 onClick={action.action}
350:                 className={`h-20 flex-col gap-1 ${
351:                   action.isContextual
352:                     ? "border-green-200 bg-green-50 hover:bg-green-100 text-green-800"
353:                     : ""
354:                 }`}
355:               >
356:                 <span className="text-2xl">{action.emoji}</span>
357:                 <span className="text-sm text-center leading-tight">
358:                   {action.label}
359:                 </span>
360:               </Button>
361:             ))}
362:           </div>
363: 
364:           {}
365:           {quickActions.some((action) => action.isContextual) && (
366:             <p className="text-xs text-muted-foreground mt-3 text-center">
367:               Green actions are suggested based on your urgent tasks
368:             </p>
369:           )}
370:         </CardContent>
371:       </Card>
372:     </div>
373:   );
374: };
375: 
376: export default Dashboard;




================================================================
End of Codebase
================================================================
